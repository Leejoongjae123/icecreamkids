/**
 * Generated by orval v7.4.1 üç∫
 * Do not edit manually.
 * Message API
 * isd / kinder board api doc
 * OpenAPI spec version: v1.1.0
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';
import type {
  ApiResponseInteger,
  ApiResponseLong,
  ApiResponseNotificationPageListableResult,
  ApiResponseSmsUserValidateSendResponse,
  ApiResponseString,
  ApiResponseUserValidationCodeState,
  NotReadsParams,
  NotificationRequest,
  ReadsParams,
  SmsUserValidateRequest,
  SmsUserValidateSendRequest,
} from './schemas';
import { customFetcher } from '../custom-fetcher';

type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1];

export const markAsReadAll = (
  profileId: string,
  markAsReadAllBody: number[],
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseString>(
    {
      url: `/message/v1/notifications-to/${profileId}/mark-as-read`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: markAsReadAllBody,
    },
    options,
  );
};

export const getMarkAsReadAllMutationOptions = <
  TData = Awaited<ReturnType<typeof markAsReadAll>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { profileId: string; data: number[] }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['markAsReadAll'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof markAsReadAll>>,
    { profileId: string; data: number[] }
  > = (props) => {
    const { profileId, data } = props ?? {};

    return markAsReadAll(profileId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { profileId: string; data: number[] },
    TContext
  >;
};

export type MarkAsReadAllMutationResult = NonNullable<Awaited<ReturnType<typeof markAsReadAll>>>;
export type MarkAsReadAllMutationBody = number[];
export type MarkAsReadAllMutationError = unknown;

export const useMarkAsReadAll = <
  TData = Awaited<ReturnType<typeof markAsReadAll>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { profileId: string; data: number[] }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { profileId: string; data: number[] }, TContext> => {
  const mutationOptions = getMarkAsReadAllMutationOptions(options);

  return useMutation(mutationOptions);
};

export const markAsReadAll1 = (profileId: string, options?: SecondParameter<typeof customFetcher>) => {
  return customFetcher<ApiResponseString>(
    { url: `/message/v1/notifications-to/${profileId}/mark-as-read-all`, method: 'PUT' },
    options,
  );
};

export const getMarkAsReadAll1MutationOptions = <
  TData = Awaited<ReturnType<typeof markAsReadAll1>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { profileId: string }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['markAsReadAll1'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof markAsReadAll1>>, { profileId: string }> = (props) => {
    const { profileId } = props ?? {};

    return markAsReadAll1(profileId, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError, { profileId: string }, TContext>;
};

export type MarkAsReadAll1MutationResult = NonNullable<Awaited<ReturnType<typeof markAsReadAll1>>>;

export type MarkAsReadAll1MutationError = unknown;

export const useMarkAsReadAll1 = <
  TData = Awaited<ReturnType<typeof markAsReadAll1>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { profileId: string }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { profileId: string }, TContext> => {
  const mutationOptions = getMarkAsReadAll1MutationOptions(options);

  return useMutation(mutationOptions);
};

export const newNotifiedMarkAsChecked = (profileId: string, options?: SecondParameter<typeof customFetcher>) => {
  return customFetcher<ApiResponseString>(
    { url: `/message/v1/message-counters/${profileId}/new-notified/mark-as-checked`, method: 'PUT' },
    options,
  );
};

export const getNewNotifiedMarkAsCheckedMutationOptions = <
  TData = Awaited<ReturnType<typeof newNotifiedMarkAsChecked>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { profileId: string }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['newNotifiedMarkAsChecked'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof newNotifiedMarkAsChecked>>, { profileId: string }> = (
    props,
  ) => {
    const { profileId } = props ?? {};

    return newNotifiedMarkAsChecked(profileId, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError, { profileId: string }, TContext>;
};

export type NewNotifiedMarkAsCheckedMutationResult = NonNullable<Awaited<ReturnType<typeof newNotifiedMarkAsChecked>>>;

export type NewNotifiedMarkAsCheckedMutationError = unknown;

export const useNewNotifiedMarkAsChecked = <
  TData = Awaited<ReturnType<typeof newNotifiedMarkAsChecked>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { profileId: string }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { profileId: string }, TContext> => {
  const mutationOptions = getNewNotifiedMarkAsCheckedMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * smsÎ°ú Ïù∏Ï¶ùÏΩîÎìúÎ•º Î∞úÏÜ°Ìï©ÎãàÎã§. Í∞úÎ∞úÏÑúÎ≤ÑÏóêÏÑ† codeIdÏóê Í∑∏ÎÉ• Ïù∏Ï¶ùÏΩîÎìú Ï†ÑÎã¨ ÎìúÎ¶ΩÎãàÎã§.
 * @summary Ïù∏Ï¶ùÏΩîÎìú Î∞úÏÜ° ÏöîÏ≤≠
 */
export const requestValidate = (
  smsUserValidateSendRequest: SmsUserValidateSendRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseSmsUserValidateSendResponse>(
    {
      url: `/message/v1/sms/validation/request`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: smsUserValidateSendRequest,
      signal,
    },
    options,
  );
};

export const getRequestValidateMutationOptions = <
  TData = Awaited<ReturnType<typeof requestValidate>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: SmsUserValidateSendRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['requestValidate'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof requestValidate>>,
    { data: SmsUserValidateSendRequest }
  > = (props) => {
    const { data } = props ?? {};

    return requestValidate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: SmsUserValidateSendRequest },
    TContext
  >;
};

export type RequestValidateMutationResult = NonNullable<Awaited<ReturnType<typeof requestValidate>>>;
export type RequestValidateMutationBody = SmsUserValidateSendRequest;
export type RequestValidateMutationError = unknown;

/**
 * @summary Ïù∏Ï¶ùÏΩîÎìú Î∞úÏÜ° ÏöîÏ≤≠
 */
export const useRequestValidate = <
  TData = Awaited<ReturnType<typeof requestValidate>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: SmsUserValidateSendRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: SmsUserValidateSendRequest }, TContext> => {
  const mutationOptions = getRequestValidateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Ïù∏Ï¶ùÏΩîÎìúÏôÄ Î∞úÏÜ°Ìïú Î≤àÌò∏Î°ú Í≤ÄÏ¶ùÏùÑ ÏßÑÌñâÌï©ÎãàÎã§.
 * @summary Ïù∏Ï¶ùÏΩîÎìú Î∞úÏÜ°Îêú Ïù∏Ï¶ùÏΩîÎìúÎ•º Í≤ÄÏ¶ùÌïòÎäî api
 */
export const validateCode = (
  smsUserValidateRequest: SmsUserValidateRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseUserValidationCodeState>(
    {
      url: `/message/v1/sms/validation/code`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: smsUserValidateRequest,
      signal,
    },
    options,
  );
};

export const getValidateCodeMutationOptions = <
  TData = Awaited<ReturnType<typeof validateCode>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: SmsUserValidateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['validateCode'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof validateCode>>, { data: SmsUserValidateRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return validateCode(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: SmsUserValidateRequest },
    TContext
  >;
};

export type ValidateCodeMutationResult = NonNullable<Awaited<ReturnType<typeof validateCode>>>;
export type ValidateCodeMutationBody = SmsUserValidateRequest;
export type ValidateCodeMutationError = unknown;

/**
 * @summary Ïù∏Ï¶ùÏΩîÎìú Î∞úÏÜ°Îêú Ïù∏Ï¶ùÏΩîÎìúÎ•º Í≤ÄÏ¶ùÌïòÎäî api
 */
export const useValidateCode = <
  TData = Awaited<ReturnType<typeof validateCode>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: SmsUserValidateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: SmsUserValidateRequest }, TContext> => {
  const mutationOptions = getValidateCodeMutationOptions(options);

  return useMutation(mutationOptions);
};

export const add = (
  notificationRequest: NotificationRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseLong>(
    {
      url: `/message/v1/notifications`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: notificationRequest,
      signal,
    },
    options,
  );
};

export const getAddMutationOptions = <
  TData = Awaited<ReturnType<typeof add>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: NotificationRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['add'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof add>>, { data: NotificationRequest }> = (props) => {
    const { data } = props ?? {};

    return add(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: NotificationRequest },
    TContext
  >;
};

export type AddMutationResult = NonNullable<Awaited<ReturnType<typeof add>>>;
export type AddMutationBody = NotificationRequest;
export type AddMutationError = unknown;

export const useAdd = <TData = Awaited<ReturnType<typeof add>>, TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: NotificationRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: NotificationRequest }, TContext> => {
  const mutationOptions = getAddMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * smsÎ°ú Ïù∏Ï¶ùÏΩîÎìúÎ•º Î∞úÏÜ°Ìï©ÎãàÎã§. Í∞úÎ∞úÏÑúÎ≤ÑÏóêÏÑ† codeIdÏóê Í∑∏ÎÉ• Ïù∏Ï¶ùÏΩîÎìú Ï†ÑÎã¨ ÎìúÎ¶ΩÎãàÎã§.
 * @summary Ïù∏Ï¶ùÏΩîÎìú Î∞úÏÜ° ÏöîÏ≤≠
 */
export const requestValidate1 = (
  smsUserValidateSendRequest: SmsUserValidateSendRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseSmsUserValidateSendResponse>(
    {
      url: `/message/open-api/v1/sms/validation/request`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: smsUserValidateSendRequest,
      signal,
    },
    options,
  );
};

export const getRequestValidate1MutationOptions = <
  TData = Awaited<ReturnType<typeof requestValidate1>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: SmsUserValidateSendRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['requestValidate1'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof requestValidate1>>,
    { data: SmsUserValidateSendRequest }
  > = (props) => {
    const { data } = props ?? {};

    return requestValidate1(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: SmsUserValidateSendRequest },
    TContext
  >;
};

export type RequestValidate1MutationResult = NonNullable<Awaited<ReturnType<typeof requestValidate1>>>;
export type RequestValidate1MutationBody = SmsUserValidateSendRequest;
export type RequestValidate1MutationError = unknown;

/**
 * @summary Ïù∏Ï¶ùÏΩîÎìú Î∞úÏÜ° ÏöîÏ≤≠
 */
export const useRequestValidate1 = <
  TData = Awaited<ReturnType<typeof requestValidate1>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: SmsUserValidateSendRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: SmsUserValidateSendRequest }, TContext> => {
  const mutationOptions = getRequestValidate1MutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Ïù∏Ï¶ùÏΩîÎìúÏôÄ Î∞úÏÜ°Ìïú Î≤àÌò∏Î°ú Í≤ÄÏ¶ùÏùÑ ÏßÑÌñâÌï©ÎãàÎã§.
 * @summary Ïù∏Ï¶ùÏΩîÎìú Î∞úÏÜ°Îêú Ïù∏Ï¶ùÏΩîÎìúÎ•º Í≤ÄÏ¶ùÌïòÎäî api
 */
export const validateCode1 = (
  smsUserValidateRequest: SmsUserValidateRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseUserValidationCodeState>(
    {
      url: `/message/open-api/v1/sms/validation/code`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: smsUserValidateRequest,
      signal,
    },
    options,
  );
};

export const getValidateCode1MutationOptions = <
  TData = Awaited<ReturnType<typeof validateCode1>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: SmsUserValidateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['validateCode1'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof validateCode1>>, { data: SmsUserValidateRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return validateCode1(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: SmsUserValidateRequest },
    TContext
  >;
};

export type ValidateCode1MutationResult = NonNullable<Awaited<ReturnType<typeof validateCode1>>>;
export type ValidateCode1MutationBody = SmsUserValidateRequest;
export type ValidateCode1MutationError = unknown;

/**
 * @summary Ïù∏Ï¶ùÏΩîÎìú Î∞úÏÜ°Îêú Ïù∏Ï¶ùÏΩîÎìúÎ•º Í≤ÄÏ¶ùÌïòÎäî api
 */
export const useValidateCode1 = <
  TData = Awaited<ReturnType<typeof validateCode1>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: SmsUserValidateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: SmsUserValidateRequest }, TContext> => {
  const mutationOptions = getValidateCode1MutationOptions(options);

  return useMutation(mutationOptions);
};

export const reads = (
  profileId: string,
  params?: ReadsParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseNotificationPageListableResult>(
    { url: `/message/v1/notifications-to/${profileId}/read`, method: 'GET', params, signal },
    options,
  );
};

export const getReadsQueryKey = (profileId: string, params?: ReadsParams) => {
  return [`/message/v1/notifications-to/${profileId}/read`, ...(params ? [params] : [])] as const;
};

export const getReadsQueryOptions = <TData = Awaited<ReturnType<typeof reads>>, TError = unknown>(
  profileId: string,
  params?: ReadsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof reads>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getReadsQueryKey(profileId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof reads>>> = ({ signal }) =>
    reads(profileId, params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof reads>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type ReadsQueryResult = NonNullable<Awaited<ReturnType<typeof reads>>>;
export type ReadsQueryError = unknown;

export function useReads<TData = Awaited<ReturnType<typeof reads>>, TError = unknown>(
  profileId: string,
  params: undefined | ReadsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof reads>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof reads>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useReads<TData = Awaited<ReturnType<typeof reads>>, TError = unknown>(
  profileId: string,
  params?: ReadsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof reads>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof reads>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useReads<TData = Awaited<ReturnType<typeof reads>>, TError = unknown>(
  profileId: string,
  params?: ReadsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof reads>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

export function useReads<TData = Awaited<ReturnType<typeof reads>>, TError = unknown>(
  profileId: string,
  params?: ReadsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof reads>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getReadsQueryOptions(profileId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const notReads = (
  profileId: string,
  params?: NotReadsParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseNotificationPageListableResult>(
    { url: `/message/v1/notifications-to/${profileId}/not-read`, method: 'GET', params, signal },
    options,
  );
};

export const getNotReadsQueryKey = (profileId: string, params?: NotReadsParams) => {
  return [`/message/v1/notifications-to/${profileId}/not-read`, ...(params ? [params] : [])] as const;
};

export const getNotReadsQueryOptions = <TData = Awaited<ReturnType<typeof notReads>>, TError = unknown>(
  profileId: string,
  params?: NotReadsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof notReads>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getNotReadsQueryKey(profileId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof notReads>>> = ({ signal }) =>
    notReads(profileId, params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof notReads>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type NotReadsQueryResult = NonNullable<Awaited<ReturnType<typeof notReads>>>;
export type NotReadsQueryError = unknown;

export function useNotReads<TData = Awaited<ReturnType<typeof notReads>>, TError = unknown>(
  profileId: string,
  params: undefined | NotReadsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof notReads>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof notReads>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useNotReads<TData = Awaited<ReturnType<typeof notReads>>, TError = unknown>(
  profileId: string,
  params?: NotReadsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof notReads>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof notReads>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useNotReads<TData = Awaited<ReturnType<typeof notReads>>, TError = unknown>(
  profileId: string,
  params?: NotReadsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof notReads>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

export function useNotReads<TData = Awaited<ReturnType<typeof notReads>>, TError = unknown>(
  profileId: string,
  params?: NotReadsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof notReads>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getNotReadsQueryOptions(profileId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const newNotified = (
  profileId: string,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseInteger>(
    { url: `/message/v1/message-counters/${profileId}/new-notified`, method: 'GET', signal },
    options,
  );
};

export const getNewNotifiedQueryKey = (profileId: string) => {
  return [`/message/v1/message-counters/${profileId}/new-notified`] as const;
};

export const getNewNotifiedQueryOptions = <TData = Awaited<ReturnType<typeof newNotified>>, TError = unknown>(
  profileId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof newNotified>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getNewNotifiedQueryKey(profileId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof newNotified>>> = ({ signal }) =>
    newNotified(profileId, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof newNotified>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type NewNotifiedQueryResult = NonNullable<Awaited<ReturnType<typeof newNotified>>>;
export type NewNotifiedQueryError = unknown;

export function useNewNotified<TData = Awaited<ReturnType<typeof newNotified>>, TError = unknown>(
  profileId: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof newNotified>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof newNotified>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useNewNotified<TData = Awaited<ReturnType<typeof newNotified>>, TError = unknown>(
  profileId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof newNotified>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof newNotified>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useNewNotified<TData = Awaited<ReturnType<typeof newNotified>>, TError = unknown>(
  profileId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof newNotified>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

export function useNewNotified<TData = Awaited<ReturnType<typeof newNotified>>, TError = unknown>(
  profileId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof newNotified>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getNewNotifiedQueryOptions(profileId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}
