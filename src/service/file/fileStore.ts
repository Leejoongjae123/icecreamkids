/**
 * Generated by orval v7.4.1 ğŸº
 * Do not edit manually.
 * File API
 * isd / kinder board api doc
 * OpenAPI spec version: v1.1.0
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';
import type {
  AddDriveItemToMyBoardRequest,
  AddDriveItemToMyFolderRequest,
  AddDriveItemViewCountRequest,
  AddReplyRequest,
  AddStudentPhotoRequest,
  ApiResponseBoolean,
  ApiResponseCourseResult,
  ApiResponseDriveItemLikeResult,
  ApiResponseDriveItemMemoResult,
  ApiResponseDriveItemResult,
  ApiResponseFileObjectSttTextPostResponse,
  ApiResponseImageTaskLogResult,
  ApiResponseInteger,
  ApiResponseLecturePlanResult,
  ApiResponseLecturePlanTermResult,
  ApiResponseLectureReportCardAiCreationLogResult,
  ApiResponseLectureReportResult,
  ApiResponseListCdnFileResult,
  ApiResponseListCourseResult,
  ApiResponseListDriveItemMemoResult,
  ApiResponseListDriveItemResult,
  ApiResponseListFileObjectResult,
  ApiResponseListLecturePlanResult,
  ApiResponseListRecentTaskResult,
  ApiResponseListRecommendationKeywordBundleResult,
  ApiResponseListReplyResult,
  ApiResponseListSmartFolderDocumentItem,
  ApiResponseListSmartFolderItemResult,
  ApiResponseListSmartFolderResult,
  ApiResponseListSmartFolderTreeResult,
  ApiResponseListStoryBoardResult,
  ApiResponseListString,
  ApiResponseListStudentEvaluationDomainResult,
  ApiResponseListStudentEvaluationIndicatorResult,
  ApiResponseListStudentRecordResult,
  ApiResponseMapStringString,
  ApiResponseMyBoardCountsResult,
  ApiResponsePublicUrlItemCodeResult,
  ApiResponsePublicUrlItemDetailedResult,
  ApiResponseRecommendationKeywordBundleResult,
  ApiResponseSearchListResultSmartFolderItemResult,
  ApiResponseSmartFolderItemDetailedResult,
  ApiResponseSmartFolderItemReplyResult,
  ApiResponseSmartFolderItemResult,
  ApiResponseSmartFolderResult,
  ApiResponseSmartFolderTreeResult,
  ApiResponseStorageUsageResult,
  ApiResponseStoryBoardResult,
  ApiResponseString,
  ApiResponseStudentEvaluationIndicatorResult,
  ApiResponseStudentRecordResult,
  CdnFileDownloadRequest,
  CdnFilesForDownloadRequest,
  ChangeLinkedStudentRequest,
  ChangeShareStatePublicItemRequest,
  CheckNotIndexedItems2Params,
  CommonAddDriveItemToSmartFolderRequest,
  CommonAddDriveItemToSmartFolderWithIdRequest,
  CommonChangeShareStateWithDriveItemKeyRequest,
  CommonChangeShareStateWithidRequest,
  CommonHideItemRequest,
  CommonMoveItemRequest,
  CommonRenameRequest,
  CommonUploadCompletedRequest,
  CreateCommonPhotoSmartFolderRequest,
  CreateDocumentSmartFolderRequest,
  CreateMyFolderRequest,
  CreateSmartFolderRequest,
  CreateStudentPhotoFolderRequest,
  DeleteDriveItemMemoParams,
  DeleteMyBoardItemRequest,
  DeleteRecommendationKeywordInfoParams,
  DriveItemAddTagRequest,
  DriveItemChangeThumbnailRequest,
  DriveItemMemoAddRequest,
  DriveItemMemoUpdateRequest,
  DriveItemSttUpdateRequest,
  FileObjectSttTextPostRequest,
  FileObjectThumbUrlsPostRequest,
  FileObjectUploadRequest,
  FindAllPagingReplies1Params,
  FindAllPagingRepliesParams,
  GetActivityFoldersParams,
  GetByIdOrKeyParams,
  GetChildPagingRepliesParams,
  GetCourseParams,
  GetDocsFolderTreeParams,
  GetDocsFoldersParams,
  GetDomainsParams,
  GetDriveItemMemosParams,
  GetFoldersParams,
  GetImageFlatPathParams,
  GetImageRootFolderParams,
  GetImageTaskParams,
  GetIncludedDocsItemsParams,
  GetIncludedItemsDeprecateParams,
  GetIncludedItemsParams,
  GetIncludedPhotoItemsParams,
  GetIndicatorsParams,
  GetItemFlatPathTreeParams,
  GetItemKeyListParams,
  GetItemListParams,
  GetItemPathTreeParams,
  GetLecturePlanListParams,
  GetLecturePlanListWithSearchParams,
  GetLecturePlanParams,
  GetLectureReportParams,
  GetMobileUploadedFilesParams,
  GetMyBoardItemsParams,
  GetMyFolders1Params,
  GetMyFoldersDeprecateParams,
  GetPhotoFolderTreeParams,
  GetPhotoFoldersParams,
  GetPhotoHomeFoldersParams,
  GetPhotosForReportParams,
  GetPublicItem1Params,
  GetPublicItemForMainParams,
  GetPublicItemForMyListParams,
  GetPublicItemParams,
  GetPublicUrlItemCodeParams,
  GetRecentTasksParams,
  GetRecommendItemsParams,
  GetRecommendPlansFromMyItemsParams,
  GetRecommendPlansFromPublicItemsParams,
  GetRecommendPlansParams,
  GetRecommendationKeywordInfoParams,
  GetRecommendationKeywordParams,
  GetReplyAndAttachedItemListParams,
  GetSmartFolderItem1Params,
  GetSmartFolderItemParams,
  GetSmartFolderItemsRecommendPublicItemList1Params,
  GetSmartFolderItemsRecommendPublicItemListParams,
  GetStoryBoardListParams,
  GetStoryBoardParams,
  GetStudentFoldersParams,
  GetStudentPhotoFolderWithStudentIdParams,
  GetStudentRecordHistoryParams,
  GetStudentRecordParams,
  GetTagsStartWithParams,
  GetTermParams,
  GetWidgetFoldersParams,
  ImageTaskLogAddRequest,
  LecturePlanAddRequest,
  LecturePlanUpdateRequest,
  LectureReportAddRequest,
  LectureReportCardAiCreationLogAddRequest,
  LectureReportUpdateRequest,
  MemoFileCreateRequest,
  MemoFileUpdateRequest,
  MoveItemRequest,
  MoveItemToTrashRequest,
  MyBoardChangeShareStateRequest,
  MyBoardRenameRequest,
  ProfileIdAndDriveItemKeyRequest,
  RecommendationKeywordBundleAddRequest,
  RecommendationKeywordBundleUpdateRequest,
  RejectRecommendationItemRequest,
  RemoveDriveItemFromMyFolderWithKeyRequest,
  RemoveSmartFolderItemWithIdRequest,
  RenameRequest,
  ScanMyFoldersParams,
  SearchKeywordAnalizeParams,
  SearchMyBoardDataParams,
  SearchMyDataParams,
  SearchStudentDataParams,
  StorageUsageCreateRequest,
  StoryBoardAddRequest,
  StoryBoardUpdateRequest,
  StudentRecordAddRequest,
  StudentRecordUpdateRequest,
  ToggleHiddenItemRequest,
  ToggleHiddenItemsRequest,
  TrashcanRequest,
  UpdateReplyRequest,
  UpdateTaggedStudentsRequest,
} from './schemas';
import { customFetcher } from '../custom-fetcher';

type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1];

export const restoreItems = (trashcanRequest: TrashcanRequest, options?: SecondParameter<typeof customFetcher>) => {
  return customFetcher<ApiResponseString>(
    {
      url: `/file/v1/trashcan/restore`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: trashcanRequest,
    },
    options,
  );
};

export const getRestoreItemsMutationOptions = <
  TData = Awaited<ReturnType<typeof restoreItems>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: TrashcanRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['restoreItems'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof restoreItems>>, { data: TrashcanRequest }> = (props) => {
    const { data } = props ?? {};

    return restoreItems(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError, { data: TrashcanRequest }, TContext>;
};

export type RestoreItemsMutationResult = NonNullable<Awaited<ReturnType<typeof restoreItems>>>;
export type RestoreItemsMutationBody = TrashcanRequest;
export type RestoreItemsMutationError = unknown;

export const useRestoreItems = <
  TData = Awaited<ReturnType<typeof restoreItems>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: TrashcanRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: TrashcanRequest }, TContext> => {
  const mutationOptions = getRestoreItemsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ê´€ì°° ê¸°ë¡ì„ ìˆ˜ì •í•©ë‹ˆë‹¤.
 * @summary ê´€ì°° ê¸°ë¡ ìˆ˜ì •
 */
export const updateStudentRecord = (
  studentRecordUpdateRequest: StudentRecordUpdateRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseStudentRecordResult>(
    {
      url: `/file/v1/student-record`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: studentRecordUpdateRequest,
    },
    options,
  );
};

export const getUpdateStudentRecordMutationOptions = <
  TData = Awaited<ReturnType<typeof updateStudentRecord>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: StudentRecordUpdateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['updateStudentRecord'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateStudentRecord>>,
    { data: StudentRecordUpdateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return updateStudentRecord(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: StudentRecordUpdateRequest },
    TContext
  >;
};

export type UpdateStudentRecordMutationResult = NonNullable<Awaited<ReturnType<typeof updateStudentRecord>>>;
export type UpdateStudentRecordMutationBody = StudentRecordUpdateRequest;
export type UpdateStudentRecordMutationError = unknown;

/**
 * @summary ê´€ì°° ê¸°ë¡ ìˆ˜ì •
 */
export const useUpdateStudentRecord = <
  TData = Awaited<ReturnType<typeof updateStudentRecord>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: StudentRecordUpdateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: StudentRecordUpdateRequest }, TContext> => {
  const mutationOptions = getUpdateStudentRecordMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ê´€ì°° ê¸°ë¡ì„ ì‹ ê·œë¡œ ì €ì¥í•©ë‹ˆë‹¤.
(2025.02.13)teacherAccountId,teacherProfileId -> creatorAccountId, creatorProfileId ë¡œ ë³€ê²½
 * @summary ê´€ì°° ê¸°ë¡ ì‹ ê·œ ì €ì¥
 */
export const createStudentRecord = (
  studentRecordAddRequest: StudentRecordAddRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseStudentRecordResult>(
    {
      url: `/file/v1/student-record`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: studentRecordAddRequest,
      signal,
    },
    options,
  );
};

export const getCreateStudentRecordMutationOptions = <
  TData = Awaited<ReturnType<typeof createStudentRecord>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: StudentRecordAddRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['createStudentRecord'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createStudentRecord>>,
    { data: StudentRecordAddRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createStudentRecord(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: StudentRecordAddRequest },
    TContext
  >;
};

export type CreateStudentRecordMutationResult = NonNullable<Awaited<ReturnType<typeof createStudentRecord>>>;
export type CreateStudentRecordMutationBody = StudentRecordAddRequest;
export type CreateStudentRecordMutationError = unknown;

/**
 * @summary ê´€ì°° ê¸°ë¡ ì‹ ê·œ ì €ì¥
 */
export const useCreateStudentRecord = <
  TData = Awaited<ReturnType<typeof createStudentRecord>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: StudentRecordAddRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: StudentRecordAddRequest }, TContext> => {
  const mutationOptions = getCreateStudentRecordMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ê¸°ì¡´ ìŠ¤í† ë¦¬ë³´ë“œì˜ ë‚´ìš©ì„ ìˆ˜ì •í•©ë‹ˆë‹¤.
 * @summary ìŠ¤í† ë¦¬ë³´ë“œ ìˆ˜ì •
 */
export const updateStoryBoard = (
  storyBoardUpdateRequest: StoryBoardUpdateRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseStoryBoardResult>(
    {
      url: `/file/v1/story-board`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: storyBoardUpdateRequest,
    },
    options,
  );
};

export const getUpdateStoryBoardMutationOptions = <
  TData = Awaited<ReturnType<typeof updateStoryBoard>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: StoryBoardUpdateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['updateStoryBoard'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateStoryBoard>>,
    { data: StoryBoardUpdateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return updateStoryBoard(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: StoryBoardUpdateRequest },
    TContext
  >;
};

export type UpdateStoryBoardMutationResult = NonNullable<Awaited<ReturnType<typeof updateStoryBoard>>>;
export type UpdateStoryBoardMutationBody = StoryBoardUpdateRequest;
export type UpdateStoryBoardMutationError = unknown;

/**
 * @summary ìŠ¤í† ë¦¬ë³´ë“œ ìˆ˜ì •
 */
export const useUpdateStoryBoard = <
  TData = Awaited<ReturnType<typeof updateStoryBoard>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: StoryBoardUpdateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: StoryBoardUpdateRequest }, TContext> => {
  const mutationOptions = getUpdateStoryBoardMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ìŠ¤í† ë¦¬ë³´ë“œë¥¼ ì‹ ê·œë¡œ ì €ì¥í•©ë‹ˆë‹¤.
 * @summary ìŠ¤í† ë¦¬ë³´ë“œ ì‹ ê·œ ì €ì¥
 */
export const createStoryBoard = (
  storyBoardAddRequest: StoryBoardAddRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseStoryBoardResult>(
    {
      url: `/file/v1/story-board`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: storyBoardAddRequest,
      signal,
    },
    options,
  );
};

export const getCreateStoryBoardMutationOptions = <
  TData = Awaited<ReturnType<typeof createStoryBoard>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: StoryBoardAddRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['createStoryBoard'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof createStoryBoard>>, { data: StoryBoardAddRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return createStoryBoard(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: StoryBoardAddRequest },
    TContext
  >;
};

export type CreateStoryBoardMutationResult = NonNullable<Awaited<ReturnType<typeof createStoryBoard>>>;
export type CreateStoryBoardMutationBody = StoryBoardAddRequest;
export type CreateStoryBoardMutationError = unknown;

/**
 * @summary ìŠ¤í† ë¦¬ë³´ë“œ ì‹ ê·œ ì €ì¥
 */
export const useCreateStoryBoard = <
  TData = Awaited<ReturnType<typeof createStoryBoard>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: StoryBoardAddRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: StoryBoardAddRequest }, TContext> => {
  const mutationOptions = getCreateStoryBoardMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ì•„ì´ í´ë”ë¥¼ ì‚­ì œê°€ ê°€ëŠ¥í•˜ê²Œ ë³€ê²½í•©ë‹ˆë‹¤.
 * @summary (ë‚´ë¶€ í†µì‹  api. í˜¸ì¶œ ì•ˆí•˜ì…”ë„ ë¨.)ì•„ì´ ì‚­ì œì‹œ ì‚­ì œ ê°€ëŠ¥í•œ í´ë”ë¡œ ë³€ê²½
 */
export const releaseStudentPhotoFolder = (
  createStudentPhotoFolderRequest: CreateStudentPhotoFolderRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseSmartFolderResult>(
    {
      url: `/file/v1/smart-folder/photo/student/release-folder`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: createStudentPhotoFolderRequest,
    },
    options,
  );
};

export const getReleaseStudentPhotoFolderMutationOptions = <
  TData = Awaited<ReturnType<typeof releaseStudentPhotoFolder>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CreateStudentPhotoFolderRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['releaseStudentPhotoFolder'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof releaseStudentPhotoFolder>>,
    { data: CreateStudentPhotoFolderRequest }
  > = (props) => {
    const { data } = props ?? {};

    return releaseStudentPhotoFolder(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: CreateStudentPhotoFolderRequest },
    TContext
  >;
};

export type ReleaseStudentPhotoFolderMutationResult = NonNullable<
  Awaited<ReturnType<typeof releaseStudentPhotoFolder>>
>;
export type ReleaseStudentPhotoFolderMutationBody = CreateStudentPhotoFolderRequest;
export type ReleaseStudentPhotoFolderMutationError = unknown;

/**
 * @summary (ë‚´ë¶€ í†µì‹  api. í˜¸ì¶œ ì•ˆí•˜ì…”ë„ ë¨.)ì•„ì´ ì‚­ì œì‹œ ì‚­ì œ ê°€ëŠ¥í•œ í´ë”ë¡œ ë³€ê²½
 */
export const useReleaseStudentPhotoFolder = <
  TData = Awaited<ReturnType<typeof releaseStudentPhotoFolder>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CreateStudentPhotoFolderRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: CreateStudentPhotoFolderRequest }, TContext> => {
  const mutationOptions = getReleaseStudentPhotoFolderMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ìš”ì²­í•œ ì‚¬ì§„ì„ ë‹¤ë¥¸ ì•„ì´ë¡œ ë“±ë¡í•˜ê³  í´ë”ë¥¼ ì´ë™í•©ë‹ˆë‹¤.
 * @summary ë¶„ë¥˜ëœ ì•„ì´ ì‚¬ì§„ ìë£Œë¥¼ ë‹¤ë¥¸ ì•„ì´ë¡œ ë“±ë¡.(í´ë” ì´ë™ ë° íƒœê¹…ëœ ì•„ì´ ì •ë³´ ë³€ê²½)
 */
export const moveStudentPhotoItem = (
  changeLinkedStudentRequest: ChangeLinkedStudentRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    {
      url: `/file/v1/smart-folder/photo/student/move`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: changeLinkedStudentRequest,
    },
    options,
  );
};

export const getMoveStudentPhotoItemMutationOptions = <
  TData = Awaited<ReturnType<typeof moveStudentPhotoItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: ChangeLinkedStudentRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['moveStudentPhotoItem'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof moveStudentPhotoItem>>,
    { data: ChangeLinkedStudentRequest }
  > = (props) => {
    const { data } = props ?? {};

    return moveStudentPhotoItem(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: ChangeLinkedStudentRequest },
    TContext
  >;
};

export type MoveStudentPhotoItemMutationResult = NonNullable<Awaited<ReturnType<typeof moveStudentPhotoItem>>>;
export type MoveStudentPhotoItemMutationBody = ChangeLinkedStudentRequest;
export type MoveStudentPhotoItemMutationError = unknown;

/**
 * @summary ë¶„ë¥˜ëœ ì•„ì´ ì‚¬ì§„ ìë£Œë¥¼ ë‹¤ë¥¸ ì•„ì´ë¡œ ë“±ë¡.(í´ë” ì´ë™ ë° íƒœê¹…ëœ ì•„ì´ ì •ë³´ ë³€ê²½)
 */
export const useMoveStudentPhotoItem = <
  TData = Awaited<ReturnType<typeof moveStudentPhotoItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: ChangeLinkedStudentRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: ChangeLinkedStudentRequest }, TContext> => {
  const mutationOptions = getMoveStudentPhotoItemMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ì•„ì´ ì´ë¦„ì´ ë³€ê²½ëì„ ë•Œ ë°˜ì˜í•©ë‹ˆë‹¤.
 * @summary (ë‚´ë¶€ api í†µì‹ ìš©)ì•„ì´ ì´ë¦„ ë³€ê²½ì‹œ í´ë”ëª… ë³€ê²½
 */
export const modifyStudentPhotoFolder = (
  createStudentPhotoFolderRequest: CreateStudentPhotoFolderRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseSmartFolderResult>(
    {
      url: `/file/v1/smart-folder/photo/student/modify-student-name`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: createStudentPhotoFolderRequest,
    },
    options,
  );
};

export const getModifyStudentPhotoFolderMutationOptions = <
  TData = Awaited<ReturnType<typeof modifyStudentPhotoFolder>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CreateStudentPhotoFolderRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['modifyStudentPhotoFolder'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof modifyStudentPhotoFolder>>,
    { data: CreateStudentPhotoFolderRequest }
  > = (props) => {
    const { data } = props ?? {};

    return modifyStudentPhotoFolder(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: CreateStudentPhotoFolderRequest },
    TContext
  >;
};

export type ModifyStudentPhotoFolderMutationResult = NonNullable<Awaited<ReturnType<typeof modifyStudentPhotoFolder>>>;
export type ModifyStudentPhotoFolderMutationBody = CreateStudentPhotoFolderRequest;
export type ModifyStudentPhotoFolderMutationError = unknown;

/**
 * @summary (ë‚´ë¶€ api í†µì‹ ìš©)ì•„ì´ ì´ë¦„ ë³€ê²½ì‹œ í´ë”ëª… ë³€ê²½
 */
export const useModifyStudentPhotoFolder = <
  TData = Awaited<ReturnType<typeof modifyStudentPhotoFolder>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CreateStudentPhotoFolderRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: CreateStudentPhotoFolderRequest }, TContext> => {
  const mutationOptions = getModifyStudentPhotoFolderMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ìš”ì²­ ìë£Œë¥¼ ì´ë™í•©ë‹ˆë‹¤. íŒŒì¼ë§Œì´ë™í•˜ê³ , ì´ë™ ì„±ê³µí•œ ìë£Œë“¤ì˜ ìµœì†Œ ì •ë³´ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
 * @summary ì‚¬ì§„ ìë£Œë¥¼ ì´ë™
 */
export const movePhotoItem = (moveItemRequest: MoveItemRequest, options?: SecondParameter<typeof customFetcher>) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    {
      url: `/file/v1/smart-folder/photo/move`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: moveItemRequest,
    },
    options,
  );
};

export const getMovePhotoItemMutationOptions = <
  TData = Awaited<ReturnType<typeof movePhotoItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MoveItemRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['movePhotoItem'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof movePhotoItem>>, { data: MoveItemRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return movePhotoItem(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError, { data: MoveItemRequest }, TContext>;
};

export type MovePhotoItemMutationResult = NonNullable<Awaited<ReturnType<typeof movePhotoItem>>>;
export type MovePhotoItemMutationBody = MoveItemRequest;
export type MovePhotoItemMutationError = unknown;

/**
 * @summary ì‚¬ì§„ ìë£Œë¥¼ ì´ë™
 */
export const useMovePhotoItem = <
  TData = Awaited<ReturnType<typeof movePhotoItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MoveItemRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: MoveItemRequest }, TContext> => {
  const mutationOptions = getMovePhotoItemMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ìœ„ì ¯ì„ ìë£Œë³´ë“œ í™ˆ í™”ë©´ì—ì„œ ë³´ì´ì§€ ì•Šê²Œ í•©ë‹ˆë‹¤.
 * @summary ìœ„ì ¯ì„ í•´ë‹¹ í´ë”ì—ì„œ ìˆ¨ê¸°ê¸°(ë” ì´ìƒ ë³´ì§€ì•Šê¸°)
 */
export const showWidgets = (
  toggleHiddenItemRequest: ToggleHiddenItemRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseSmartFolderResult>(
    {
      url: `/file/v1/smart-folder/docs/show-widget`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: toggleHiddenItemRequest,
    },
    options,
  );
};

export const getShowWidgetsMutationOptions = <
  TData = Awaited<ReturnType<typeof showWidgets>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: ToggleHiddenItemRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['showWidgets'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof showWidgets>>, { data: ToggleHiddenItemRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return showWidgets(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: ToggleHiddenItemRequest },
    TContext
  >;
};

export type ShowWidgetsMutationResult = NonNullable<Awaited<ReturnType<typeof showWidgets>>>;
export type ShowWidgetsMutationBody = ToggleHiddenItemRequest;
export type ShowWidgetsMutationError = unknown;

/**
 * @summary ìœ„ì ¯ì„ í•´ë‹¹ í´ë”ì—ì„œ ìˆ¨ê¸°ê¸°(ë” ì´ìƒ ë³´ì§€ì•Šê¸°)
 */
export const useShowWidgets = <
  TData = Awaited<ReturnType<typeof showWidgets>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: ToggleHiddenItemRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: ToggleHiddenItemRequest }, TContext> => {
  const mutationOptions = getShowWidgetsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ìš”ì²­ ìë£Œë¥¼ ì´ë™í•©ë‹ˆë‹¤. íŒŒì¼ë§Œì´ë™í•˜ê³ , ì´ë™ ì„±ê³µí•œ ìë£Œë“¤ì˜ ìµœì†Œ ì •ë³´ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
 * @summary ë¬¸ì„œ ìë£Œë¥¼ ì´ë™
 */
export const moveDocumentItem = (moveItemRequest: MoveItemRequest, options?: SecondParameter<typeof customFetcher>) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    {
      url: `/file/v1/smart-folder/docs/move`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: moveItemRequest,
    },
    options,
  );
};

export const getMoveDocumentItemMutationOptions = <
  TData = Awaited<ReturnType<typeof moveDocumentItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MoveItemRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['moveDocumentItem'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof moveDocumentItem>>, { data: MoveItemRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return moveDocumentItem(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError, { data: MoveItemRequest }, TContext>;
};

export type MoveDocumentItemMutationResult = NonNullable<Awaited<ReturnType<typeof moveDocumentItem>>>;
export type MoveDocumentItemMutationBody = MoveItemRequest;
export type MoveDocumentItemMutationError = unknown;

/**
 * @summary ë¬¸ì„œ ìë£Œë¥¼ ì´ë™
 */
export const useMoveDocumentItem = <
  TData = Awaited<ReturnType<typeof moveDocumentItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MoveItemRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: MoveItemRequest }, TContext> => {
  const mutationOptions = getMoveDocumentItemMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ìœ„ì ¯ì„ ìë£Œë³´ë“œ í™ˆì—ì„œ ë³´ì´ê¸°/ìˆ¨ê¸°ê¸° ë° ìˆœì„œë¥¼ ë³€ê²½í•©ë‹ˆë‹¤. (ë³€ê²½ í•„ìš”í•œ ë‚´ìš©ë§Œ ì €ì¥í•©ë‹ˆë‹¤.)
 * @summary ìœ„ì ¯ì„ ë³´ì´ê±°ë‚˜ ìˆ¨ê¸°ê±°ë‚˜ ìˆœì„œë¥¼ ë³€ê²½
 */
export const manageSortAndToggleHiddenWidgets = (
  toggleHiddenItemsRequest: ToggleHiddenItemsRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseString>(
    {
      url: `/file/v1/smart-folder/docs/manage-widgets`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: toggleHiddenItemsRequest,
    },
    options,
  );
};

export const getManageSortAndToggleHiddenWidgetsMutationOptions = <
  TData = Awaited<ReturnType<typeof manageSortAndToggleHiddenWidgets>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: ToggleHiddenItemsRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['manageSortAndToggleHiddenWidgets'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof manageSortAndToggleHiddenWidgets>>,
    { data: ToggleHiddenItemsRequest }
  > = (props) => {
    const { data } = props ?? {};

    return manageSortAndToggleHiddenWidgets(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: ToggleHiddenItemsRequest },
    TContext
  >;
};

export type ManageSortAndToggleHiddenWidgetsMutationResult = NonNullable<
  Awaited<ReturnType<typeof manageSortAndToggleHiddenWidgets>>
>;
export type ManageSortAndToggleHiddenWidgetsMutationBody = ToggleHiddenItemsRequest;
export type ManageSortAndToggleHiddenWidgetsMutationError = unknown;

/**
 * @summary ìœ„ì ¯ì„ ë³´ì´ê±°ë‚˜ ìˆ¨ê¸°ê±°ë‚˜ ìˆœì„œë¥¼ ë³€ê²½
 */
export const useManageSortAndToggleHiddenWidgets = <
  TData = Awaited<ReturnType<typeof manageSortAndToggleHiddenWidgets>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: ToggleHiddenItemsRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: ToggleHiddenItemsRequest }, TContext> => {
  const mutationOptions = getManageSortAndToggleHiddenWidgetsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ìœ„ì ¯ì„ ìë£Œë³´ë“œ í™ˆ í™”ë©´ì—ì„œ ë³´ì´ì§€ ì•Šê²Œ í•©ë‹ˆë‹¤.
 * @summary ìœ„ì ¯ì„ í•´ë‹¹ í´ë”ì—ì„œ ìˆ¨ê¸°ê¸°(ë” ì´ìƒ ë³´ì§€ì•Šê¸°)
 */
export const hideWidgets = (
  toggleHiddenItemRequest: ToggleHiddenItemRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseSmartFolderResult>(
    {
      url: `/file/v1/smart-folder/docs/hide-widget`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: toggleHiddenItemRequest,
    },
    options,
  );
};

export const getHideWidgetsMutationOptions = <
  TData = Awaited<ReturnType<typeof hideWidgets>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: ToggleHiddenItemRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['hideWidgets'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof hideWidgets>>, { data: ToggleHiddenItemRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return hideWidgets(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: ToggleHiddenItemRequest },
    TContext
  >;
};

export type HideWidgetsMutationResult = NonNullable<Awaited<ReturnType<typeof hideWidgets>>>;
export type HideWidgetsMutationBody = ToggleHiddenItemRequest;
export type HideWidgetsMutationError = unknown;

/**
 * @summary ìœ„ì ¯ì„ í•´ë‹¹ í´ë”ì—ì„œ ìˆ¨ê¸°ê¸°(ë” ì´ìƒ ë³´ì§€ì•Šê¸°)
 */
export const useHideWidgets = <
  TData = Awaited<ReturnType<typeof hideWidgets>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: ToggleHiddenItemRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: ToggleHiddenItemRequest }, TContext> => {
  const mutationOptions = getHideWidgetsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ì¶”ì²œ í‚¤ì›Œë“œ ì •ë³´ë¥¼ ìˆ˜ì •í•©ë‹ˆë‹¤.
 * @summary ì¶”ì²œ í‚¤ì›Œë“œ ì •ë³´ ìˆ˜ì •
 */
export const updateRecommendationKeywordInfo = (
  id: string,
  recommendationKeywordBundleUpdateRequest: RecommendationKeywordBundleUpdateRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseRecommendationKeywordBundleResult>(
    {
      url: `/file/v1/recommendation/common-keywords/${id}`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: recommendationKeywordBundleUpdateRequest,
    },
    options,
  );
};

export const getUpdateRecommendationKeywordInfoMutationOptions = <
  TData = Awaited<ReturnType<typeof updateRecommendationKeywordInfo>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { id: string; data: RecommendationKeywordBundleUpdateRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['updateRecommendationKeywordInfo'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateRecommendationKeywordInfo>>,
    { id: string; data: RecommendationKeywordBundleUpdateRequest }
  > = (props) => {
    const { id, data } = props ?? {};

    return updateRecommendationKeywordInfo(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { id: string; data: RecommendationKeywordBundleUpdateRequest },
    TContext
  >;
};

export type UpdateRecommendationKeywordInfoMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateRecommendationKeywordInfo>>
>;
export type UpdateRecommendationKeywordInfoMutationBody = RecommendationKeywordBundleUpdateRequest;
export type UpdateRecommendationKeywordInfoMutationError = unknown;

/**
 * @summary ì¶”ì²œ í‚¤ì›Œë“œ ì •ë³´ ìˆ˜ì •
 */
export const useUpdateRecommendationKeywordInfo = <
  TData = Awaited<ReturnType<typeof updateRecommendationKeywordInfo>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { id: string; data: RecommendationKeywordBundleUpdateRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { id: string; data: RecommendationKeywordBundleUpdateRequest }, TContext> => {
  const mutationOptions = getUpdateRecommendationKeywordInfoMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ìš”ì²­í•œ ìë£Œì˜ ê³µê°œ ìƒíƒœë¥¼ ë³€ê²½í•©ë‹ˆë‹¤. userEditableì´ falseì¸ ìë£ŒëŠ” ë³€ê²½ì´ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤.ìƒíƒœìš”ì²­ì— ë”°ë¼ PRIVATE(ë¹„ê³µê°œ), PUBLIC(ê³µê°œ -> PUBLIC_AND_URL_SHAREë¡œ ë””í´íŠ¸ë¡œ ì‚¬ìš©), PRIVATE_AND_URL_SHARE(ë¹„ê³µê°œ+URLê³µìœ ), PUBLIC_AND_URL_SHARE(ê³µê°œ+URLê³µìœ ) ê°„ ë³€ê²½ë©ë‹ˆë‹¤.
 * @summary ìë£Œì˜ ê³µê°œ ìƒíƒœ ë³€ê²½
 */
export const changePublicStateOfItem = (
  changeShareStatePublicItemRequest: ChangeShareStatePublicItemRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseSmartFolderItemResult>(
    {
      url: `/file/v1/public-url-item/share`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: changeShareStatePublicItemRequest,
    },
    options,
  );
};

export const getChangePublicStateOfItemMutationOptions = <
  TData = Awaited<ReturnType<typeof changePublicStateOfItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: ChangeShareStatePublicItemRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['changePublicStateOfItem'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof changePublicStateOfItem>>,
    { data: ChangeShareStatePublicItemRequest }
  > = (props) => {
    const { data } = props ?? {};

    return changePublicStateOfItem(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: ChangeShareStatePublicItemRequest },
    TContext
  >;
};

export type ChangePublicStateOfItemMutationResult = NonNullable<Awaited<ReturnType<typeof changePublicStateOfItem>>>;
export type ChangePublicStateOfItemMutationBody = ChangeShareStatePublicItemRequest;
export type ChangePublicStateOfItemMutationError = unknown;

/**
 * @summary ìë£Œì˜ ê³µê°œ ìƒíƒœ ë³€ê²½
 */
export const useChangePublicStateOfItem = <
  TData = Awaited<ReturnType<typeof changePublicStateOfItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: ChangeShareStatePublicItemRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: ChangeShareStatePublicItemRequest }, TContext> => {
  const mutationOptions = getChangePublicStateOfItemMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ìš”ì²­ ìë£Œì˜ ì´ë¦„ì„ ë³€ê²½í•©ë‹ˆë‹¤.(ì‘ë‹µìœ¼ë¡œ ìë£Œì˜ ìµœì†Œì •ë³´ë§Œ ì‘ë‹µí•©ë‹ˆë‹¤. ì¹´ìš´íŠ¸ìª½ì€ ì²´í¬í•˜ì§€ì•ŠìŠµë‹ˆë‹¤.)
 * @summary ë‚´ í´ë”/ìë£Œì˜ ì´ë¦„ ë³€ê²½
 */
export const renameItem = (
  smartFolderItemid: string,
  renameRequest: RenameRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseSmartFolderItemResult>(
    {
      url: `/file/v1/my-folder/${smartFolderItemid}/rename`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: renameRequest,
    },
    options,
  );
};

export const getRenameItemMutationOptions = <
  TData = Awaited<ReturnType<typeof renameItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { smartFolderItemid: string; data: RenameRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['renameItem'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof renameItem>>,
    { smartFolderItemid: string; data: RenameRequest }
  > = (props) => {
    const { smartFolderItemid, data } = props ?? {};

    return renameItem(smartFolderItemid, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { smartFolderItemid: string; data: RenameRequest },
    TContext
  >;
};

export type RenameItemMutationResult = NonNullable<Awaited<ReturnType<typeof renameItem>>>;
export type RenameItemMutationBody = RenameRequest;
export type RenameItemMutationError = unknown;

/**
 * @summary ë‚´ í´ë”/ìë£Œì˜ ì´ë¦„ ë³€ê²½
 */
export const useRenameItem = <
  TData = Awaited<ReturnType<typeof renameItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { smartFolderItemid: string; data: RenameRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { smartFolderItemid: string; data: RenameRequest }, TContext> => {
  const mutationOptions = getRenameItemMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ìš”ì²­í•œ ìë£Œì˜ ê³µê°œ ìƒíƒœë¥¼ ë³€ê²½í•©ë‹ˆë‹¤. userEditableì´ falseì¸ ìë£ŒëŠ” ë³€ê²½ì´ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤.ìƒíƒœìš”ì²­ì— ë”°ë¼ PRIVATE(ë¹„ê³µê°œ), PUBLIC(ê³µê°œ -> PUBLIC_AND_URL_SHAREë¡œ ë””í´íŠ¸ë¡œ ì‚¬ìš©), PRIVATE_AND_URL_SHARE(ë¹„ê³µê°œ+URLê³µìœ ), PUBLIC_AND_URL_SHARE(ê³µê°œ+URLê³µìœ ) ê°„ ë³€ê²½ë©ë‹ˆë‹¤.
 * @summary ë‚´ í´ë” ìë£Œì˜ ê³µê°œ ìƒíƒœ ë³€ê²½
 */
export const changePublicStateOfItem1 = (
  commonChangeShareStateWithidRequest: CommonChangeShareStateWithidRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseSmartFolderItemResult>(
    {
      url: `/file/v1/my-folder/share`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: commonChangeShareStateWithidRequest,
    },
    options,
  );
};

export const getChangePublicStateOfItem1MutationOptions = <
  TData = Awaited<ReturnType<typeof changePublicStateOfItem1>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CommonChangeShareStateWithidRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['changePublicStateOfItem1'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof changePublicStateOfItem1>>,
    { data: CommonChangeShareStateWithidRequest }
  > = (props) => {
    const { data } = props ?? {};

    return changePublicStateOfItem1(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: CommonChangeShareStateWithidRequest },
    TContext
  >;
};

export type ChangePublicStateOfItem1MutationResult = NonNullable<Awaited<ReturnType<typeof changePublicStateOfItem1>>>;
export type ChangePublicStateOfItem1MutationBody = CommonChangeShareStateWithidRequest;
export type ChangePublicStateOfItem1MutationError = unknown;

/**
 * @summary ë‚´ í´ë” ìë£Œì˜ ê³µê°œ ìƒíƒœ ë³€ê²½
 */
export const useChangePublicStateOfItem1 = <
  TData = Awaited<ReturnType<typeof changePublicStateOfItem1>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CommonChangeShareStateWithidRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: CommonChangeShareStateWithidRequest }, TContext> => {
  const mutationOptions = getChangePublicStateOfItem1MutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ìš”ì²­ ìë£Œë¥¼ ì´ë™í•©ë‹ˆë‹¤. íŒŒì¼ë§Œì´ë™í•˜ê³ , ì´ë™ ì„±ê³µí•œ ìë£Œë“¤ì˜ ìµœì†Œ ì •ë³´ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
 * @summary ìë£Œë¥¼ ì´ë™
 */
export const moveItem = (moveItemRequest: MoveItemRequest, options?: SecondParameter<typeof customFetcher>) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    {
      url: `/file/v1/my-folder/move`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: moveItemRequest,
    },
    options,
  );
};

export const getMoveItemMutationOptions = <
  TData = Awaited<ReturnType<typeof moveItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MoveItemRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['moveItem'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof moveItem>>, { data: MoveItemRequest }> = (props) => {
    const { data } = props ?? {};

    return moveItem(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError, { data: MoveItemRequest }, TContext>;
};

export type MoveItemMutationResult = NonNullable<Awaited<ReturnType<typeof moveItem>>>;
export type MoveItemMutationBody = MoveItemRequest;
export type MoveItemMutationError = unknown;

/**
 * @summary ìë£Œë¥¼ ì´ë™
 */
export const useMoveItem = <
  TData = Awaited<ReturnType<typeof moveItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MoveItemRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: MoveItemRequest }, TContext> => {
  const mutationOptions = getMoveItemMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ìš”ì²­í•œ ìë£Œì˜ ê³µê°œ ìƒíƒœë¥¼ ë³€ê²½í•©ë‹ˆë‹¤. userEditableì´ falseì¸ ìë£ŒëŠ” ë³€ê²½ì´ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤.ìƒíƒœìš”ì²­ì— ë”°ë¼ PRIVATE(ë¹„ê³µê°œ), PUBLIC(ê³µê°œ -> PUBLIC_AND_URL_SHAREë¡œ ë””í´íŠ¸ë¡œ ì‚¬ìš©), PRIVATE_AND_URL_SHARE(ë¹„ê³µê°œ+URLê³µìœ ), PUBLIC_AND_URL_SHARE(ê³µê°œ+URLê³µìœ )
 * @summary ë§ˆì´ë³´ë“œ ìë£Œì˜ ê³µê°œ ìƒíƒœ ë³€ê²½
 */
export const changePublicStateOfItem2 = (
  myBoardChangeShareStateRequest: MyBoardChangeShareStateRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseSmartFolderItemResult>(
    {
      url: `/file/v1/my-board/share`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: myBoardChangeShareStateRequest,
    },
    options,
  );
};

export const getChangePublicStateOfItem2MutationOptions = <
  TData = Awaited<ReturnType<typeof changePublicStateOfItem2>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MyBoardChangeShareStateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['changePublicStateOfItem2'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof changePublicStateOfItem2>>,
    { data: MyBoardChangeShareStateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return changePublicStateOfItem2(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: MyBoardChangeShareStateRequest },
    TContext
  >;
};

export type ChangePublicStateOfItem2MutationResult = NonNullable<Awaited<ReturnType<typeof changePublicStateOfItem2>>>;
export type ChangePublicStateOfItem2MutationBody = MyBoardChangeShareStateRequest;
export type ChangePublicStateOfItem2MutationError = unknown;

/**
 * @summary ë§ˆì´ë³´ë“œ ìë£Œì˜ ê³µê°œ ìƒíƒœ ë³€ê²½
 */
export const useChangePublicStateOfItem2 = <
  TData = Awaited<ReturnType<typeof changePublicStateOfItem2>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MyBoardChangeShareStateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: MyBoardChangeShareStateRequest }, TContext> => {
  const mutationOptions = getChangePublicStateOfItem2MutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ìš”ì²­í•œ ìë£Œì˜ ì´ë¦„ì„ ë³€ê²½í•©ë‹ˆë‹¤. userEditableì´ falseì¸ ìë£ŒëŠ” ë³€ê²½ì´ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤.
 * @summary ë§ˆì´ë³´ë“œ ìë£Œì˜ ì´ë¦„ ë³€ê²½
 */
export const renameItem1 = (
  myBoardRenameRequest: MyBoardRenameRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseSmartFolderItemResult>(
    {
      url: `/file/v1/my-board/rename-item`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: myBoardRenameRequest,
    },
    options,
  );
};

export const getRenameItem1MutationOptions = <
  TData = Awaited<ReturnType<typeof renameItem1>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MyBoardRenameRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['renameItem1'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof renameItem1>>, { data: MyBoardRenameRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return renameItem1(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: MyBoardRenameRequest },
    TContext
  >;
};

export type RenameItem1MutationResult = NonNullable<Awaited<ReturnType<typeof renameItem1>>>;
export type RenameItem1MutationBody = MyBoardRenameRequest;
export type RenameItem1MutationError = unknown;

/**
 * @summary ë§ˆì´ë³´ë“œ ìë£Œì˜ ì´ë¦„ ë³€ê²½
 */
export const useRenameItem1 = <
  TData = Awaited<ReturnType<typeof renameItem1>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MyBoardRenameRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: MyBoardRenameRequest }, TContext> => {
  const mutationOptions = getRenameItem1MutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ë†€ì´ë³´ê³ ì„œë¥¼ ìˆ˜ì •í•©ë‹ˆë‹¤.
 * @summary ë†€ì´ë³´ê³ ì„œ ìˆ˜ì •
 */
export const updateLectureReport = (
  lectureReportUpdateRequest: LectureReportUpdateRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseLectureReportResult>(
    {
      url: `/file/v1/lecture-report`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: lectureReportUpdateRequest,
    },
    options,
  );
};

export const getUpdateLectureReportMutationOptions = <
  TData = Awaited<ReturnType<typeof updateLectureReport>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: LectureReportUpdateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['updateLectureReport'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateLectureReport>>,
    { data: LectureReportUpdateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return updateLectureReport(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: LectureReportUpdateRequest },
    TContext
  >;
};

export type UpdateLectureReportMutationResult = NonNullable<Awaited<ReturnType<typeof updateLectureReport>>>;
export type UpdateLectureReportMutationBody = LectureReportUpdateRequest;
export type UpdateLectureReportMutationError = unknown;

/**
 * @summary ë†€ì´ë³´ê³ ì„œ ìˆ˜ì •
 */
export const useUpdateLectureReport = <
  TData = Awaited<ReturnType<typeof updateLectureReport>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: LectureReportUpdateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: LectureReportUpdateRequest }, TContext> => {
  const mutationOptions = getUpdateLectureReportMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ë†€ì´ë³´ê³ ì„œë¥¼ ì‹ ê·œë¡œ ì €ì¥í•©ë‹ˆë‹¤.
 * @summary ì‹ ê·œ ë†€ì´ë³´ê³ ì„œ ì €ì¥
 */
export const createLectureReport = (
  lectureReportAddRequest: LectureReportAddRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseLectureReportResult>(
    {
      url: `/file/v1/lecture-report`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: lectureReportAddRequest,
      signal,
    },
    options,
  );
};

export const getCreateLectureReportMutationOptions = <
  TData = Awaited<ReturnType<typeof createLectureReport>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: LectureReportAddRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['createLectureReport'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createLectureReport>>,
    { data: LectureReportAddRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createLectureReport(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: LectureReportAddRequest },
    TContext
  >;
};

export type CreateLectureReportMutationResult = NonNullable<Awaited<ReturnType<typeof createLectureReport>>>;
export type CreateLectureReportMutationBody = LectureReportAddRequest;
export type CreateLectureReportMutationError = unknown;

/**
 * @summary ì‹ ê·œ ë†€ì´ë³´ê³ ì„œ ì €ì¥
 */
export const useCreateLectureReport = <
  TData = Awaited<ReturnType<typeof createLectureReport>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: LectureReportAddRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: LectureReportAddRequest }, TContext> => {
  const mutationOptions = getCreateLectureReportMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ë†€ì´ê³„íšì„ ìˆ˜ì •í•©ë‹ˆë‹¤.
 * @summary ì‹ ê·œ ë†€ì´ê³„íš ìˆ˜ì •
 */
export const updateLecturePlan = (
  lecturePlanUpdateRequest: LecturePlanUpdateRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseLecturePlanResult>(
    {
      url: `/file/v1/lecture-plan`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: lecturePlanUpdateRequest,
    },
    options,
  );
};

export const getUpdateLecturePlanMutationOptions = <
  TData = Awaited<ReturnType<typeof updateLecturePlan>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: LecturePlanUpdateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['updateLecturePlan'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateLecturePlan>>,
    { data: LecturePlanUpdateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return updateLecturePlan(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: LecturePlanUpdateRequest },
    TContext
  >;
};

export type UpdateLecturePlanMutationResult = NonNullable<Awaited<ReturnType<typeof updateLecturePlan>>>;
export type UpdateLecturePlanMutationBody = LecturePlanUpdateRequest;
export type UpdateLecturePlanMutationError = unknown;

/**
 * @summary ì‹ ê·œ ë†€ì´ê³„íš ìˆ˜ì •
 */
export const useUpdateLecturePlan = <
  TData = Awaited<ReturnType<typeof updateLecturePlan>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: LecturePlanUpdateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: LecturePlanUpdateRequest }, TContext> => {
  const mutationOptions = getUpdateLecturePlanMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ë†€ì´ê³„íšì„ ì‹ ê·œë¡œ ì €ì¥í•©ë‹ˆë‹¤.
 * @summary ì‹ ê·œ ë†€ì´ê³„íš ì €ì¥
 */
export const createLecturePlan = (
  lecturePlanAddRequest: LecturePlanAddRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseLecturePlanResult>(
    {
      url: `/file/v1/lecture-plan`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: lecturePlanAddRequest,
      signal,
    },
    options,
  );
};

export const getCreateLecturePlanMutationOptions = <
  TData = Awaited<ReturnType<typeof createLecturePlan>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: LecturePlanAddRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['createLecturePlan'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof createLecturePlan>>, { data: LecturePlanAddRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return createLecturePlan(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: LecturePlanAddRequest },
    TContext
  >;
};

export type CreateLecturePlanMutationResult = NonNullable<Awaited<ReturnType<typeof createLecturePlan>>>;
export type CreateLecturePlanMutationBody = LecturePlanAddRequest;
export type CreateLecturePlanMutationError = unknown;

/**
 * @summary ì‹ ê·œ ë†€ì´ê³„íš ì €ì¥
 */
export const useCreateLecturePlan = <
  TData = Awaited<ReturnType<typeof createLecturePlan>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: LecturePlanAddRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: LecturePlanAddRequest }, TContext> => {
  const mutationOptions = getCreateLecturePlanMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * í”„ë¡œí•„ ì‚¬ì§„ì´ presigned urlì— ì—…ë¡œë“œí•˜ê³ ë‚˜ë©´ í•´ë‹¹ ì‚¬ì§„íŒŒì¼ì„ ì—…ë¡œë“œ ì™„ë£Œ ìƒíƒœë¡œ ë³€ê²½í•©ë‹ˆë‹¤.
 * @summary í”„ë¡œí•„ ì‚¬ì§„ ì—…ë¡œë“œ ì™„ë£Œ ì½œë°±
 */
export const uploadCompleted = (fileObjectId: number, options?: SecondParameter<typeof customFetcher>) => {
  return customFetcher<ApiResponseString>(
    { url: `/file/v1/file-objects/${fileObjectId}/uploaded`, method: 'PUT' },
    options,
  );
};

export const getUploadCompletedMutationOptions = <
  TData = Awaited<ReturnType<typeof uploadCompleted>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { fileObjectId: number }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['uploadCompleted'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof uploadCompleted>>, { fileObjectId: number }> = (
    props,
  ) => {
    const { fileObjectId } = props ?? {};

    return uploadCompleted(fileObjectId, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError, { fileObjectId: number }, TContext>;
};

export type UploadCompletedMutationResult = NonNullable<Awaited<ReturnType<typeof uploadCompleted>>>;

export type UploadCompletedMutationError = unknown;

/**
 * @summary í”„ë¡œí•„ ì‚¬ì§„ ì—…ë¡œë“œ ì™„ë£Œ ì½œë°±
 */
export const useUploadCompleted = <
  TData = Awaited<ReturnType<typeof uploadCompleted>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { fileObjectId: number }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { fileObjectId: number }, TContext> => {
  const mutationOptions = getUploadCompletedMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ìë£Œì˜ ì¸ë„¤ì¼ì„ ë³€ê²½í•©ë‹ˆë‹¤. (í•„ìš”ì‹œì—ë§Œ ì‚¬ìš©í•©ë‹ˆë‹¤.)
 * @summary ìë£Œì˜ ì¸ë„¤ì¼ ë³€ê²½
 */
export const changeThumbnail = (
  key: string,
  driveItemChangeThumbnailRequest: DriveItemChangeThumbnailRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseString>(
    {
      url: `/file/v1/drive-items/${key}/thumbnail`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: driveItemChangeThumbnailRequest,
    },
    options,
  );
};

export const getChangeThumbnailMutationOptions = <
  TData = Awaited<ReturnType<typeof changeThumbnail>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { key: string; data: DriveItemChangeThumbnailRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['changeThumbnail'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof changeThumbnail>>,
    { key: string; data: DriveItemChangeThumbnailRequest }
  > = (props) => {
    const { key, data } = props ?? {};

    return changeThumbnail(key, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { key: string; data: DriveItemChangeThumbnailRequest },
    TContext
  >;
};

export type ChangeThumbnailMutationResult = NonNullable<Awaited<ReturnType<typeof changeThumbnail>>>;
export type ChangeThumbnailMutationBody = DriveItemChangeThumbnailRequest;
export type ChangeThumbnailMutationError = unknown;

/**
 * @summary ìë£Œì˜ ì¸ë„¤ì¼ ë³€ê²½
 */
export const useChangeThumbnail = <
  TData = Awaited<ReturnType<typeof changeThumbnail>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { key: string; data: DriveItemChangeThumbnailRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { key: string; data: DriveItemChangeThumbnailRequest }, TContext> => {
  const mutationOptions = getChangeThumbnailMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ìë£Œì— íƒœê¹…ëœ í•™ìƒ ì •ë³´ë¥¼ ìˆ˜ì •í•©ë‹ˆë‹¤.
 * @summary ìë£Œì— ì•„ì´ íƒœê·¸ ìˆ˜ì •
 */
export const updateTaggedStudent = (
  idOrKey: string,
  updateTaggedStudentsRequest: UpdateTaggedStudentsRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseDriveItemResult>(
    {
      url: `/file/v1/drive-items/${idOrKey}/tagged-students`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: updateTaggedStudentsRequest,
    },
    options,
  );
};

export const getUpdateTaggedStudentMutationOptions = <
  TData = Awaited<ReturnType<typeof updateTaggedStudent>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { idOrKey: string; data: UpdateTaggedStudentsRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['updateTaggedStudent'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateTaggedStudent>>,
    { idOrKey: string; data: UpdateTaggedStudentsRequest }
  > = (props) => {
    const { idOrKey, data } = props ?? {};

    return updateTaggedStudent(idOrKey, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { idOrKey: string; data: UpdateTaggedStudentsRequest },
    TContext
  >;
};

export type UpdateTaggedStudentMutationResult = NonNullable<Awaited<ReturnType<typeof updateTaggedStudent>>>;
export type UpdateTaggedStudentMutationBody = UpdateTaggedStudentsRequest;
export type UpdateTaggedStudentMutationError = unknown;

/**
 * @summary ìë£Œì— ì•„ì´ íƒœê·¸ ìˆ˜ì •
 */
export const useUpdateTaggedStudent = <
  TData = Awaited<ReturnType<typeof updateTaggedStudent>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { idOrKey: string; data: UpdateTaggedStudentsRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { idOrKey: string; data: UpdateTaggedStudentsRequest }, TContext> => {
  const mutationOptions = getUpdateTaggedStudentMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ìë£Œì˜ í‚¤ë‚˜ ì´ì´ë””ì™€ stt ë‚´ìš©ì„ ìˆ˜ì •í•©ë‹ˆë‹¤.
 * @summary ìŒì„± ìë£Œì— ë“±ë¡ëœ stt ìˆ˜ì •
 */
export const updateDriveItemStt = (
  idOrKey: string,
  driveItemSttUpdateRequest: DriveItemSttUpdateRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseString>(
    {
      url: `/file/v1/drive-items/${idOrKey}/modify-audio-stt`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: driveItemSttUpdateRequest,
    },
    options,
  );
};

export const getUpdateDriveItemSttMutationOptions = <
  TData = Awaited<ReturnType<typeof updateDriveItemStt>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { idOrKey: string; data: DriveItemSttUpdateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['updateDriveItemStt'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateDriveItemStt>>,
    { idOrKey: string; data: DriveItemSttUpdateRequest }
  > = (props) => {
    const { idOrKey, data } = props ?? {};

    return updateDriveItemStt(idOrKey, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { idOrKey: string; data: DriveItemSttUpdateRequest },
    TContext
  >;
};

export type UpdateDriveItemSttMutationResult = NonNullable<Awaited<ReturnType<typeof updateDriveItemStt>>>;
export type UpdateDriveItemSttMutationBody = DriveItemSttUpdateRequest;
export type UpdateDriveItemSttMutationError = unknown;

/**
 * @summary ìŒì„± ìë£Œì— ë“±ë¡ëœ stt ìˆ˜ì •
 */
export const useUpdateDriveItemStt = <
  TData = Awaited<ReturnType<typeof updateDriveItemStt>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { idOrKey: string; data: DriveItemSttUpdateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { idOrKey: string; data: DriveItemSttUpdateRequest }, TContext> => {
  const mutationOptions = getUpdateDriveItemSttMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ìë£Œì˜ í‚¤ë‚˜ ì´ì´ë””ì™€ ë©”ëª¨ì˜ ì•„ì´ë””ë¡œ ë“±ë¡ë˜ì–´ ìˆëŠ” ë©”ëª¨ë¥¼ ìˆ˜ì •í•©ë‹ˆë‹¤
 * @summary ìë£Œì— ë“±ë¡ëœ ë©”ëª¨ ìˆ˜ì •
 */
export const updateDriveItemMemo = (
  idOrKey: string,
  memoId: string,
  driveItemMemoUpdateRequest: DriveItemMemoUpdateRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseDriveItemMemoResult>(
    {
      url: `/file/v1/drive-items/${idOrKey}/memos/${memoId}`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: driveItemMemoUpdateRequest,
    },
    options,
  );
};

export const getUpdateDriveItemMemoMutationOptions = <
  TData = Awaited<ReturnType<typeof updateDriveItemMemo>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { idOrKey: string; memoId: string; data: DriveItemMemoUpdateRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['updateDriveItemMemo'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateDriveItemMemo>>,
    { idOrKey: string; memoId: string; data: DriveItemMemoUpdateRequest }
  > = (props) => {
    const { idOrKey, memoId, data } = props ?? {};

    return updateDriveItemMemo(idOrKey, memoId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { idOrKey: string; memoId: string; data: DriveItemMemoUpdateRequest },
    TContext
  >;
};

export type UpdateDriveItemMemoMutationResult = NonNullable<Awaited<ReturnType<typeof updateDriveItemMemo>>>;
export type UpdateDriveItemMemoMutationBody = DriveItemMemoUpdateRequest;
export type UpdateDriveItemMemoMutationError = unknown;

/**
 * @summary ìë£Œì— ë“±ë¡ëœ ë©”ëª¨ ìˆ˜ì •
 */
export const useUpdateDriveItemMemo = <
  TData = Awaited<ReturnType<typeof updateDriveItemMemo>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { idOrKey: string; memoId: string; data: DriveItemMemoUpdateRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<
  TData,
  TError,
  { idOrKey: string; memoId: string; data: DriveItemMemoUpdateRequest },
  TContext
> => {
  const mutationOptions = getUpdateDriveItemMemoMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ìë£Œì˜ í‚¤ë‚˜ ì´ì´ë””ì™€ ë©”ëª¨ì˜ ì•„ì´ë””ë¡œ ë“±ë¡ë˜ì–´ ìˆëŠ” ë©”ëª¨ë¥¼ ì‚­ì œí•©ë‹ˆë‹¤
 * @summary ìë£Œì— ë“±ë¡ëœ ë©”ëª¨ ì‚­ì œ
 */
export const deleteDriveItemMemo = (
  idOrKey: string,
  memoId: string,
  params: DeleteDriveItemMemoParams,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseString>(
    { url: `/file/v1/drive-items/${idOrKey}/memos/${memoId}`, method: 'DELETE', params },
    options,
  );
};

export const getDeleteDriveItemMemoMutationOptions = <
  TData = Awaited<ReturnType<typeof deleteDriveItemMemo>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { idOrKey: string; memoId: string; params: DeleteDriveItemMemoParams },
    TContext
  >;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['deleteDriveItemMemo'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteDriveItemMemo>>,
    { idOrKey: string; memoId: string; params: DeleteDriveItemMemoParams }
  > = (props) => {
    const { idOrKey, memoId, params } = props ?? {};

    return deleteDriveItemMemo(idOrKey, memoId, params, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { idOrKey: string; memoId: string; params: DeleteDriveItemMemoParams },
    TContext
  >;
};

export type DeleteDriveItemMemoMutationResult = NonNullable<Awaited<ReturnType<typeof deleteDriveItemMemo>>>;

export type DeleteDriveItemMemoMutationError = unknown;

/**
 * @summary ìë£Œì— ë“±ë¡ëœ ë©”ëª¨ ì‚­ì œ
 */
export const useDeleteDriveItemMemo = <
  TData = Awaited<ReturnType<typeof deleteDriveItemMemo>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { idOrKey: string; memoId: string; params: DeleteDriveItemMemoParams },
    TContext
  >;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<
  TData,
  TError,
  { idOrKey: string; memoId: string; params: DeleteDriveItemMemoParams },
  TContext
> => {
  const mutationOptions = getDeleteDriveItemMemoMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ìë£Œì— ë“±ë¡ëœ ëŒ“ê¸€ì„ ìˆ˜ì •í•©ë‹ˆë‹¤.
 * @summary ëŒ“ê¸€ ìˆ˜ì •
 */
export const updateReply = (
  driveItemIdOrKey: string,
  replyId: string,
  updateReplyRequest: UpdateReplyRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<unknown>(
    {
      url: `/file/v1/drive-items/${driveItemIdOrKey}/replies/${replyId}`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: updateReplyRequest,
    },
    options,
  );
};

export const getUpdateReplyMutationOptions = <
  TData = Awaited<ReturnType<typeof updateReply>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { driveItemIdOrKey: string; replyId: string; data: UpdateReplyRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['updateReply'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateReply>>,
    { driveItemIdOrKey: string; replyId: string; data: UpdateReplyRequest }
  > = (props) => {
    const { driveItemIdOrKey, replyId, data } = props ?? {};

    return updateReply(driveItemIdOrKey, replyId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { driveItemIdOrKey: string; replyId: string; data: UpdateReplyRequest },
    TContext
  >;
};

export type UpdateReplyMutationResult = NonNullable<Awaited<ReturnType<typeof updateReply>>>;
export type UpdateReplyMutationBody = UpdateReplyRequest;
export type UpdateReplyMutationError = unknown;

/**
 * @summary ëŒ“ê¸€ ìˆ˜ì •
 */
export const useUpdateReply = <
  TData = Awaited<ReturnType<typeof updateReply>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { driveItemIdOrKey: string; replyId: string; data: UpdateReplyRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<
  TData,
  TError,
  { driveItemIdOrKey: string; replyId: string; data: UpdateReplyRequest },
  TContext
> => {
  const mutationOptions = getUpdateReplyMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ìë£Œì— ë“±ë¡ëœ ëŒ“ê¸€ê³¼ ìì‹ëŒ“ê¸€ì„ ì‚­ì œí•©ë‹ˆë‹¤.
 * @summary ëŒ“ê¸€ ì‚­ì œ
 */
export const deleteReply = (
  driveItemIdOrKey: string,
  replyId: string,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<unknown>(
    { url: `/file/v1/drive-items/${driveItemIdOrKey}/replies/${replyId}`, method: 'DELETE' },
    options,
  );
};

export const getDeleteReplyMutationOptions = <
  TData = Awaited<ReturnType<typeof deleteReply>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { driveItemIdOrKey: string; replyId: string }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['deleteReply'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteReply>>,
    { driveItemIdOrKey: string; replyId: string }
  > = (props) => {
    const { driveItemIdOrKey, replyId } = props ?? {};

    return deleteReply(driveItemIdOrKey, replyId, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { driveItemIdOrKey: string; replyId: string },
    TContext
  >;
};

export type DeleteReplyMutationResult = NonNullable<Awaited<ReturnType<typeof deleteReply>>>;

export type DeleteReplyMutationError = unknown;

/**
 * @summary ëŒ“ê¸€ ì‚­ì œ
 */
export const useDeleteReply = <
  TData = Awaited<ReturnType<typeof deleteReply>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { driveItemIdOrKey: string; replyId: string }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { driveItemIdOrKey: string; replyId: string }, TContext> => {
  const mutationOptions = getDeleteReplyMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ë©”ëª¨ íŒŒì¼ì„ ìˆ˜ì •í•©ë‹ˆë‹¤.
 * @summary ë©”ëª¨ íŒŒì¼ì„ ìˆ˜ì •í•˜ëŠ” api
 */
export const updateMemoFile = (
  memoFileUpdateRequest: MemoFileUpdateRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseSmartFolderItemResult>(
    {
      url: `/file/v1/common-smart-folder/update-memo-file`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: memoFileUpdateRequest,
    },
    options,
  );
};

export const getUpdateMemoFileMutationOptions = <
  TData = Awaited<ReturnType<typeof updateMemoFile>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MemoFileUpdateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['updateMemoFile'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateMemoFile>>, { data: MemoFileUpdateRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return updateMemoFile(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: MemoFileUpdateRequest },
    TContext
  >;
};

export type UpdateMemoFileMutationResult = NonNullable<Awaited<ReturnType<typeof updateMemoFile>>>;
export type UpdateMemoFileMutationBody = MemoFileUpdateRequest;
export type UpdateMemoFileMutationError = unknown;

/**
 * @summary ë©”ëª¨ íŒŒì¼ì„ ìˆ˜ì •í•˜ëŠ” api
 */
export const useUpdateMemoFile = <
  TData = Awaited<ReturnType<typeof updateMemoFile>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MemoFileUpdateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: MemoFileUpdateRequest }, TContext> => {
  const mutationOptions = getUpdateMemoFileMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ìš”ì²­í•œ ìë£Œì˜ ê³µê°œ ìƒíƒœë¥¼ ë³€ê²½í•©ë‹ˆë‹¤. userEditableì´ falseì¸ ìë£ŒëŠ” ë³€ê²½ì´ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤.ìƒíƒœìš”ì²­ì— ë”°ë¼ PRIVATE(ë¹„ê³µê°œ), PUBLIC(ê³µê°œ -> PUBLIC_AND_URL_SHAREë¡œ ë””í´íŠ¸ë¡œ ì‚¬ìš©), PRIVATE_AND_URL_SHARE(ë¹„ê³µê°œ+URLê³µìœ ), PUBLIC_AND_URL_SHARE(ê³µê°œ+URLê³µìœ ) ê°„ ë³€ê²½ë©ë‹ˆë‹¤.
 * @summary ìë£Œì˜ ê³µê°œ ìƒíƒœ ë³€ê²½
 */
export const changePublicStateOfItem3 = (
  commonChangeShareStateWithidRequest: CommonChangeShareStateWithidRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseSmartFolderItemResult>(
    {
      url: `/file/v1/common-smart-folder/share`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: commonChangeShareStateWithidRequest,
    },
    options,
  );
};

export const getChangePublicStateOfItem3MutationOptions = <
  TData = Awaited<ReturnType<typeof changePublicStateOfItem3>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CommonChangeShareStateWithidRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['changePublicStateOfItem3'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof changePublicStateOfItem3>>,
    { data: CommonChangeShareStateWithidRequest }
  > = (props) => {
    const { data } = props ?? {};

    return changePublicStateOfItem3(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: CommonChangeShareStateWithidRequest },
    TContext
  >;
};

export type ChangePublicStateOfItem3MutationResult = NonNullable<Awaited<ReturnType<typeof changePublicStateOfItem3>>>;
export type ChangePublicStateOfItem3MutationBody = CommonChangeShareStateWithidRequest;
export type ChangePublicStateOfItem3MutationError = unknown;

/**
 * @summary ìë£Œì˜ ê³µê°œ ìƒíƒœ ë³€ê²½
 */
export const useChangePublicStateOfItem3 = <
  TData = Awaited<ReturnType<typeof changePublicStateOfItem3>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CommonChangeShareStateWithidRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: CommonChangeShareStateWithidRequest }, TContext> => {
  const mutationOptions = getChangePublicStateOfItem3MutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ìš”ì²­í•œ ìë£Œì˜ ê³µê°œ ìƒíƒœë¥¼ ë³€ê²½í•©ë‹ˆë‹¤. userEditableì´ falseì¸ ìë£ŒëŠ” ë³€ê²½ì´ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤.ìƒíƒœìš”ì²­ì— ë”°ë¼ PRIVATE(ë¹„ê³µê°œ), PUBLIC(ê³µê°œ -> PUBLIC_AND_URL_SHAREë¡œ ë””í´íŠ¸ë¡œ ì‚¬ìš©), PRIVATE_AND_URL_SHARE(ë¹„ê³µê°œ+URLê³µìœ ), PUBLIC_AND_URL_SHARE(ê³µê°œ+URLê³µìœ ) ê°„ ë³€ê²½ë©ë‹ˆë‹¤.
 * @summary (driveItemKey)ìë£Œì˜ ê³µê°œ ìƒíƒœ ë³€ê²½
 */
export const changePublicStateOfItemWithKey = (
  commonChangeShareStateWithDriveItemKeyRequest: CommonChangeShareStateWithDriveItemKeyRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseSmartFolderItemResult>(
    {
      url: `/file/v1/common-smart-folder/share-with-drive-item-key`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: commonChangeShareStateWithDriveItemKeyRequest,
    },
    options,
  );
};

export const getChangePublicStateOfItemWithKeyMutationOptions = <
  TData = Awaited<ReturnType<typeof changePublicStateOfItemWithKey>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CommonChangeShareStateWithDriveItemKeyRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['changePublicStateOfItemWithKey'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof changePublicStateOfItemWithKey>>,
    { data: CommonChangeShareStateWithDriveItemKeyRequest }
  > = (props) => {
    const { data } = props ?? {};

    return changePublicStateOfItemWithKey(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: CommonChangeShareStateWithDriveItemKeyRequest },
    TContext
  >;
};

export type ChangePublicStateOfItemWithKeyMutationResult = NonNullable<
  Awaited<ReturnType<typeof changePublicStateOfItemWithKey>>
>;
export type ChangePublicStateOfItemWithKeyMutationBody = CommonChangeShareStateWithDriveItemKeyRequest;
export type ChangePublicStateOfItemWithKeyMutationError = unknown;

/**
 * @summary (driveItemKey)ìë£Œì˜ ê³µê°œ ìƒíƒœ ë³€ê²½
 */
export const useChangePublicStateOfItemWithKey = <
  TData = Awaited<ReturnType<typeof changePublicStateOfItemWithKey>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CommonChangeShareStateWithDriveItemKeyRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: CommonChangeShareStateWithDriveItemKeyRequest }, TContext> => {
  const mutationOptions = getChangePublicStateOfItemWithKeyMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ìš”ì²­í•œ ìë£Œì˜ ì´ë¦„ì„ ë³€ê²½í•©ë‹ˆë‹¤. userEditableì´ falseì¸ ìë£ŒëŠ” ë³€ê²½ì´ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤.
 * @summary ìë£Œì˜ ì´ë¦„ ë³€ê²½
 */
export const renameItem2 = (
  commonRenameRequest: CommonRenameRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseSmartFolderItemResult>(
    {
      url: `/file/v1/common-smart-folder/rename`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: commonRenameRequest,
    },
    options,
  );
};

export const getRenameItem2MutationOptions = <
  TData = Awaited<ReturnType<typeof renameItem2>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CommonRenameRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['renameItem2'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof renameItem2>>, { data: CommonRenameRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return renameItem2(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: CommonRenameRequest },
    TContext
  >;
};

export type RenameItem2MutationResult = NonNullable<Awaited<ReturnType<typeof renameItem2>>>;
export type RenameItem2MutationBody = CommonRenameRequest;
export type RenameItem2MutationError = unknown;

/**
 * @summary ìë£Œì˜ ì´ë¦„ ë³€ê²½
 */
export const useRenameItem2 = <
  TData = Awaited<ReturnType<typeof renameItem2>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CommonRenameRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: CommonRenameRequest }, TContext> => {
  const mutationOptions = getRenameItem2MutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ìš”ì²­ ìë£Œë¥¼ ì´ë™í•©ë‹ˆë‹¤. íŒŒì¼ë§Œì´ë™í•˜ê³ , ì´ë™ ì„±ê³µí•œ ìë£Œë“¤ì˜ ìµœì†Œ ì •ë³´ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
 * @summary ìë£Œë¥¼ ì´ë™
 */
export const moveItem1 = (
  commonMoveItemRequest: CommonMoveItemRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    {
      url: `/file/v1/common-smart-folder/move`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: commonMoveItemRequest,
    },
    options,
  );
};

export const getMoveItem1MutationOptions = <
  TData = Awaited<ReturnType<typeof moveItem1>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CommonMoveItemRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['moveItem1'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof moveItem1>>, { data: CommonMoveItemRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return moveItem1(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: CommonMoveItemRequest },
    TContext
  >;
};

export type MoveItem1MutationResult = NonNullable<Awaited<ReturnType<typeof moveItem1>>>;
export type MoveItem1MutationBody = CommonMoveItemRequest;
export type MoveItem1MutationError = unknown;

/**
 * @summary ìë£Œë¥¼ ì´ë™
 */
export const useMoveItem1 = <
  TData = Awaited<ReturnType<typeof moveItem1>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CommonMoveItemRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: CommonMoveItemRequest }, TContext> => {
  const mutationOptions = getMoveItem1MutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ìš”ì²­ ìë£Œë¥¼ ë³µì‚¬í•©ë‹ˆë‹¤. íŒŒì¼ë§Œ ë³µì‚¬í•˜ê³ , ì´ë™ ì„±ê³µí•œ ìë£Œë“¤ì˜ ìµœì†Œ ì •ë³´ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
 * @summary ìë£Œë¥¼ ë³µì‚¬
 */
export const copyItem = (
  commonMoveItemRequest: CommonMoveItemRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    {
      url: `/file/v1/common-smart-folder/copy`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: commonMoveItemRequest,
    },
    options,
  );
};

export const getCopyItemMutationOptions = <
  TData = Awaited<ReturnType<typeof copyItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CommonMoveItemRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['copyItem'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof copyItem>>, { data: CommonMoveItemRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return copyItem(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: CommonMoveItemRequest },
    TContext
  >;
};

export type CopyItemMutationResult = NonNullable<Awaited<ReturnType<typeof copyItem>>>;
export type CopyItemMutationBody = CommonMoveItemRequest;
export type CopyItemMutationError = unknown;

/**
 * @summary ìë£Œë¥¼ ë³µì‚¬
 */
export const useCopyItem = <
  TData = Awaited<ReturnType<typeof copyItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CommonMoveItemRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: CommonMoveItemRequest }, TContext> => {
  const mutationOptions = getCopyItemMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ì‚¬ìš©ìì˜ ì €ì¥ì†Œë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤. ë‚´ë“œë¼ì´ë¸Œ, ì„ì‹œë³´ê´€í•¨, ë‚´í´ë”, ìŠ¤ë§ˆíŠ¸í´ë” ì €ì¥ì†Œê°€ ìƒì„±ë©ë‹ˆë‹¤.
 * @summary í‚¨ë”ë³´ë“œìš©) ì‚¬ìš©ìì˜ ì €ì¥ì†Œë¥¼ ì´ˆê¸°í™”(ê°€ì…ì„±ê³µì‹œ í˜¸ì¶œ í•„ìš”)
 */
export const createV2 = (
  storageUsageCreateRequest: StorageUsageCreateRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseStorageUsageResult>(
    {
      url: `/file/v2/storage-usages`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: storageUsageCreateRequest,
      signal,
    },
    options,
  );
};

export const getCreateV2MutationOptions = <
  TData = Awaited<ReturnType<typeof createV2>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: StorageUsageCreateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['createV2'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof createV2>>, { data: StorageUsageCreateRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return createV2(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: StorageUsageCreateRequest },
    TContext
  >;
};

export type CreateV2MutationResult = NonNullable<Awaited<ReturnType<typeof createV2>>>;
export type CreateV2MutationBody = StorageUsageCreateRequest;
export type CreateV2MutationError = unknown;

/**
 * @summary í‚¨ë”ë³´ë“œìš©) ì‚¬ìš©ìì˜ ì €ì¥ì†Œë¥¼ ì´ˆê¸°í™”(ê°€ì…ì„±ê³µì‹œ í˜¸ì¶œ í•„ìš”)
 */
export const useCreateV2 = <
  TData = Awaited<ReturnType<typeof createV2>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: StorageUsageCreateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: StorageUsageCreateRequest }, TContext> => {
  const mutationOptions = getCreateV2MutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ë“œë¼ì´ë¸Œ ì‚¬ìš©ìì˜ ì €ì¥ì†Œë¥¼ ì¶”ê°€ë¡œ ì´ˆê¸°í™”í•©ë‹ˆë‹¤. ë‚´í´ë”, ìŠ¤ë§ˆíŠ¸í´ë” ì €ì¥ì†Œê°€ ìƒì„±ë©ë‹ˆë‹¤.
 * @summary ë‚´ë¶€ì‚¬ìš©ìš©) ë“œë¼ì´ë¸Œ ì‚¬ìš©ìì—ê²Œ í‚¨ë”ë³´ë“œìš© ê¸°ë³¸ í´ë” ìƒì„±
 */
export const createForPrevDriveUser = (
  storageUsageCreateRequest: StorageUsageCreateRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseString>(
    {
      url: `/file/v2/storage-update`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: storageUsageCreateRequest,
      signal,
    },
    options,
  );
};

export const getCreateForPrevDriveUserMutationOptions = <
  TData = Awaited<ReturnType<typeof createForPrevDriveUser>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: StorageUsageCreateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['createForPrevDriveUser'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createForPrevDriveUser>>,
    { data: StorageUsageCreateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createForPrevDriveUser(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: StorageUsageCreateRequest },
    TContext
  >;
};

export type CreateForPrevDriveUserMutationResult = NonNullable<Awaited<ReturnType<typeof createForPrevDriveUser>>>;
export type CreateForPrevDriveUserMutationBody = StorageUsageCreateRequest;
export type CreateForPrevDriveUserMutationError = unknown;

/**
 * @summary ë‚´ë¶€ì‚¬ìš©ìš©) ë“œë¼ì´ë¸Œ ì‚¬ìš©ìì—ê²Œ í‚¨ë”ë³´ë“œìš© ê¸°ë³¸ í´ë” ìƒì„±
 */
export const useCreateForPrevDriveUser = <
  TData = Awaited<ReturnType<typeof createForPrevDriveUser>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: StorageUsageCreateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: StorageUsageCreateRequest }, TContext> => {
  const mutationOptions = getCreateForPrevDriveUserMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ì›ë³¸ ìë£Œë¥¼ ë‹¤ìš´ ë°›ì„ ìˆ˜ ìˆëŠ” presigned urlë¥¼ ìš”ì²­í•˜ëŠ” api ì…ë‹ˆë‹¤.
 * @summary (ê³µê°œìë£Œìš©)ìë£Œì˜ ë‹¤ìš´ë¡œë“œ ë§í¬ ìš”ì²­
 */
export const getCdnFilesForDownloadV2 = (
  cdnFileDownloadRequest: CdnFileDownloadRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListCdnFileResult>(
    {
      url: `/file/v2/drive-items/presigned-urls`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: cdnFileDownloadRequest,
      signal,
    },
    options,
  );
};

export const getGetCdnFilesForDownloadV2MutationOptions = <
  TData = Awaited<ReturnType<typeof getCdnFilesForDownloadV2>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CdnFileDownloadRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['getCdnFilesForDownloadV2'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof getCdnFilesForDownloadV2>>,
    { data: CdnFileDownloadRequest }
  > = (props) => {
    const { data } = props ?? {};

    return getCdnFilesForDownloadV2(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: CdnFileDownloadRequest },
    TContext
  >;
};

export type GetCdnFilesForDownloadV2MutationResult = NonNullable<Awaited<ReturnType<typeof getCdnFilesForDownloadV2>>>;
export type GetCdnFilesForDownloadV2MutationBody = CdnFileDownloadRequest;
export type GetCdnFilesForDownloadV2MutationError = unknown;

/**
 * @summary (ê³µê°œìë£Œìš©)ìë£Œì˜ ë‹¤ìš´ë¡œë“œ ë§í¬ ìš”ì²­
 */
export const useGetCdnFilesForDownloadV2 = <
  TData = Awaited<ReturnType<typeof getCdnFilesForDownloadV2>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CdnFileDownloadRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: CdnFileDownloadRequest }, TContext> => {
  const mutationOptions = getGetCdnFilesForDownloadV2MutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ì‚¬ì§„ê´€ë ¨ ì‘ì—…ì„ ìµœì´ˆ ì €ì¥ì‹œ ì‚¬ìš©í•˜ëŠ” api ì…ë‹ˆë‹¤.    ì´ë¯¸ì§€ ì‘ì—…ì˜ ì¢…ë¥˜(taskType) => 
STUDENT_CLASSIFICATION : ì•„ì´ ë¶„ë¥˜. 
ACTIVITY_CLASSIFICATION : í™œë™ ë¶„ë¥˜. 
STUDENT_AND_ACTIVITY_CLASSIFICATION : ì•„ì´+í™œë™ë¶„ë¥˜. 
PHOTO_COMPOSITION : ì‚¬ì§„ í•©ì„±. 
PRIVATE_DATA_ENCRYPTION : ì´ˆìƒê¶Œ ë³´í˜¸. 
SKETCH_CREATION : ë„ì•ˆìƒì„±. 
PHOTO_ALBUM : ì•¨ë²” ì‚¬ì§„ ì •ë¦¬.
 * @summary ì‚¬ì§„ ì‘ì—… ë¡œê·¸ ì¶”ê°€
 */
export const createImageTaskLog = (
  imageTaskLogAddRequest: ImageTaskLogAddRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseImageTaskLogResult>(
    {
      url: `/file/v1/task/log/image`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: imageTaskLogAddRequest,
      signal,
    },
    options,
  );
};

export const getCreateImageTaskLogMutationOptions = <
  TData = Awaited<ReturnType<typeof createImageTaskLog>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: ImageTaskLogAddRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['createImageTaskLog'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createImageTaskLog>>,
    { data: ImageTaskLogAddRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createImageTaskLog(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: ImageTaskLogAddRequest },
    TContext
  >;
};

export type CreateImageTaskLogMutationResult = NonNullable<Awaited<ReturnType<typeof createImageTaskLog>>>;
export type CreateImageTaskLogMutationBody = ImageTaskLogAddRequest;
export type CreateImageTaskLogMutationError = unknown;

/**
 * @summary ì‚¬ì§„ ì‘ì—… ë¡œê·¸ ì¶”ê°€
 */
export const useCreateImageTaskLog = <
  TData = Awaited<ReturnType<typeof createImageTaskLog>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: ImageTaskLogAddRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: ImageTaskLogAddRequest }, TContext> => {
  const mutationOptions = getCreateImageTaskLogMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ì‚¬ìš©ìê°€ ì§€ì •í•œ í´ë”ì— ì‚¬ì§„ë“¤ì„ ì¶”ê°€í•©ë‹ˆë‹¤. í´ë”ëŠ” ì¶”ê°€í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.ìƒìœ„ í´ë”ì˜ ê³µê°œëœ ìƒíƒœë¥¼ ì´ì–´ë°›ê³ , ë‹¤ë¥¸ì‚¬ëŒì˜ ìë£Œë©´ ë‚´ ë“œë¼ì´ë¸Œì˜ ë‚´ í´ë” í•˜ìœ„ì— ë³µì‚¬ë„ ì§„í–‰í•©ë‹ˆë‹¤.
 * @summary ì‚¬ì§„ ìŠ¤ë§ˆíŠ¸ í´ë”ì— ì‚¬ì§„ ì¶”ê°€
 */
export const addPhotoItem = (
  smartFolderItemId: string,
  addDriveItemToMyFolderRequest: AddDriveItemToMyFolderRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseString>(
    {
      url: `/file/v1/smart-folder/photo/${smartFolderItemId}/add-item`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: addDriveItemToMyFolderRequest,
      signal,
    },
    options,
  );
};

export const getAddPhotoItemMutationOptions = <
  TData = Awaited<ReturnType<typeof addPhotoItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { smartFolderItemId: string; data: AddDriveItemToMyFolderRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['addPhotoItem'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addPhotoItem>>,
    { smartFolderItemId: string; data: AddDriveItemToMyFolderRequest }
  > = (props) => {
    const { smartFolderItemId, data } = props ?? {};

    return addPhotoItem(smartFolderItemId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { smartFolderItemId: string; data: AddDriveItemToMyFolderRequest },
    TContext
  >;
};

export type AddPhotoItemMutationResult = NonNullable<Awaited<ReturnType<typeof addPhotoItem>>>;
export type AddPhotoItemMutationBody = AddDriveItemToMyFolderRequest;
export type AddPhotoItemMutationError = unknown;

/**
 * @summary ì‚¬ì§„ ìŠ¤ë§ˆíŠ¸ í´ë”ì— ì‚¬ì§„ ì¶”ê°€
 */
export const useAddPhotoItem = <
  TData = Awaited<ReturnType<typeof addPhotoItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { smartFolderItemId: string; data: AddDriveItemToMyFolderRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { smartFolderItemId: string; data: AddDriveItemToMyFolderRequest }, TContext> => {
  const mutationOptions = getAddPhotoItemMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ì•„ì´ í´ë”ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
 * @summary (ì•„ì´ ë“±ë¡ì‹œ í˜¸ì¶œí•˜ê¸° - ë‚´ë¶€ í†µì‹  apië¡œ ë³€ê²½. í˜¸ì¶œ ì•ˆí•˜ì…”ë„ ë¨.)ìš°ë¦¬ë°˜ ì‚¬ì§„ ë¶„ë¥˜ì— ì•„ì´ í´ë” ì¶”ê°€
 */
export const addStudentPhotoFolder = (
  createStudentPhotoFolderRequest: CreateStudentPhotoFolderRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseSmartFolderResult>(
    {
      url: `/file/v1/smart-folder/photo/student/add-folder`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createStudentPhotoFolderRequest,
      signal,
    },
    options,
  );
};

export const getAddStudentPhotoFolderMutationOptions = <
  TData = Awaited<ReturnType<typeof addStudentPhotoFolder>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CreateStudentPhotoFolderRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['addStudentPhotoFolder'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addStudentPhotoFolder>>,
    { data: CreateStudentPhotoFolderRequest }
  > = (props) => {
    const { data } = props ?? {};

    return addStudentPhotoFolder(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: CreateStudentPhotoFolderRequest },
    TContext
  >;
};

export type AddStudentPhotoFolderMutationResult = NonNullable<Awaited<ReturnType<typeof addStudentPhotoFolder>>>;
export type AddStudentPhotoFolderMutationBody = CreateStudentPhotoFolderRequest;
export type AddStudentPhotoFolderMutationError = unknown;

/**
 * @summary (ì•„ì´ ë“±ë¡ì‹œ í˜¸ì¶œí•˜ê¸° - ë‚´ë¶€ í†µì‹  apië¡œ ë³€ê²½. í˜¸ì¶œ ì•ˆí•˜ì…”ë„ ë¨.)ìš°ë¦¬ë°˜ ì‚¬ì§„ ë¶„ë¥˜ì— ì•„ì´ í´ë” ì¶”ê°€
 */
export const useAddStudentPhotoFolder = <
  TData = Awaited<ReturnType<typeof addStudentPhotoFolder>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CreateStudentPhotoFolderRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: CreateStudentPhotoFolderRequest }, TContext> => {
  const mutationOptions = getAddStudentPhotoFolderMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ì•„ì´ idë¥¼ ì‚¬ìš©í•˜ì—¬ ì§€ì •í•œ ì‚¬ì§„ë“¤ì„ ì•„ì´ ë¶„ë¥˜ ì‚¬ì§„ í´ë”ì— ì¶”ê°€í•©ë‹ˆë‹¤.
 * @summary ì•„ì´ ë¶„ë¥˜ ì‚¬ì§„ í´ë”ì— ì‚¬ì§„ ì¶”ê°€
 */
export const addStudentPhotoItemWithStudentId = (
  addStudentPhotoRequest: AddStudentPhotoRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseString>(
    {
      url: `/file/v1/smart-folder/photo/add-student-photo`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: addStudentPhotoRequest,
      signal,
    },
    options,
  );
};

export const getAddStudentPhotoItemWithStudentIdMutationOptions = <
  TData = Awaited<ReturnType<typeof addStudentPhotoItemWithStudentId>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: AddStudentPhotoRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['addStudentPhotoItemWithStudentId'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addStudentPhotoItemWithStudentId>>,
    { data: AddStudentPhotoRequest }
  > = (props) => {
    const { data } = props ?? {};

    return addStudentPhotoItemWithStudentId(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: AddStudentPhotoRequest },
    TContext
  >;
};

export type AddStudentPhotoItemWithStudentIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof addStudentPhotoItemWithStudentId>>
>;
export type AddStudentPhotoItemWithStudentIdMutationBody = AddStudentPhotoRequest;
export type AddStudentPhotoItemWithStudentIdMutationError = unknown;

/**
 * @summary ì•„ì´ ë¶„ë¥˜ ì‚¬ì§„ í´ë”ì— ì‚¬ì§„ ì¶”ê°€
 */
export const useAddStudentPhotoItemWithStudentId = <
  TData = Awaited<ReturnType<typeof addStudentPhotoItemWithStudentId>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: AddStudentPhotoRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: AddStudentPhotoRequest }, TContext> => {
  const mutationOptions = getAddStudentPhotoItemWithStudentIdMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * í´ë”ë¥¼ ìƒì„±í•˜ê±°ë‚˜ ìˆëŠ” í´ë”ë¥¼ ì¡°íšŒí•˜ëŠ” apiì…ë‹ˆë‹¤.
 * @summary (ì¤‘ë³µí™•ì¸)ì‚¬ì§„ ìŠ¤ë§ˆíŠ¸í´ë”ì—ì„œ ì‚¬ìš©ìì˜ í´ë” ìƒì„± í˜¹ì€ ì¡°íšŒ(ê³µìš©)
 */
export const addPhotoFolder = (
  createCommonPhotoSmartFolderRequest: CreateCommonPhotoSmartFolderRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseSmartFolderItemResult>(
    {
      url: `/file/v1/smart-folder/photo/add-folder`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createCommonPhotoSmartFolderRequest,
      signal,
    },
    options,
  );
};

export const getAddPhotoFolderMutationOptions = <
  TData = Awaited<ReturnType<typeof addPhotoFolder>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CreateCommonPhotoSmartFolderRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['addPhotoFolder'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addPhotoFolder>>,
    { data: CreateCommonPhotoSmartFolderRequest }
  > = (props) => {
    const { data } = props ?? {};

    return addPhotoFolder(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: CreateCommonPhotoSmartFolderRequest },
    TContext
  >;
};

export type AddPhotoFolderMutationResult = NonNullable<Awaited<ReturnType<typeof addPhotoFolder>>>;
export type AddPhotoFolderMutationBody = CreateCommonPhotoSmartFolderRequest;
export type AddPhotoFolderMutationError = unknown;

/**
 * @summary (ì¤‘ë³µí™•ì¸)ì‚¬ì§„ ìŠ¤ë§ˆíŠ¸í´ë”ì—ì„œ ì‚¬ìš©ìì˜ í´ë” ìƒì„± í˜¹ì€ ì¡°íšŒ(ê³µìš©)
 */
export const useAddPhotoFolder = <
  TData = Awaited<ReturnType<typeof addPhotoFolder>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CreateCommonPhotoSmartFolderRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: CreateCommonPhotoSmartFolderRequest }, TContext> => {
  const mutationOptions = getAddPhotoFolderMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ì‚¬ìš©ìê°€ ì§€ì •í•œ ë¬¸ì„œ ìŠ¤ë§ˆíŠ¸ í´ë”ì— ìë£Œë“¤ì„ ì¶”ê°€í•©ë‹ˆë‹¤. í´ë”ëŠ” ì¶”ê°€í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.ìƒìœ„ í´ë”ì˜ ê³µê°œëœ ìƒíƒœë¥¼ ì´ì–´ë°›ê³ , ë‹¤ë¥¸ì‚¬ëŒì˜ ìë£Œë©´ ë‚´ ë“œë¼ì´ë¸Œì˜ ë‚´ í´ë” í•˜ìœ„ì— ë³µì‚¬ë„ ì§„í–‰í•©ë‹ˆë‹¤.
 * @summary ë¬¸ì„œ ìŠ¤ë§ˆíŠ¸ í´ë”ì— ìë£Œ ì¶”ê°€
 */
export const addDocumentItem = (
  smartFolderItemId: string,
  addDriveItemToMyFolderRequest: AddDriveItemToMyFolderRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseString>(
    {
      url: `/file/v1/smart-folder/docs/${smartFolderItemId}/add-item`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: addDriveItemToMyFolderRequest,
      signal,
    },
    options,
  );
};

export const getAddDocumentItemMutationOptions = <
  TData = Awaited<ReturnType<typeof addDocumentItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { smartFolderItemId: string; data: AddDriveItemToMyFolderRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['addDocumentItem'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addDocumentItem>>,
    { smartFolderItemId: string; data: AddDriveItemToMyFolderRequest }
  > = (props) => {
    const { smartFolderItemId, data } = props ?? {};

    return addDocumentItem(smartFolderItemId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { smartFolderItemId: string; data: AddDriveItemToMyFolderRequest },
    TContext
  >;
};

export type AddDocumentItemMutationResult = NonNullable<Awaited<ReturnType<typeof addDocumentItem>>>;
export type AddDocumentItemMutationBody = AddDriveItemToMyFolderRequest;
export type AddDocumentItemMutationError = unknown;

/**
 * @summary ë¬¸ì„œ ìŠ¤ë§ˆíŠ¸ í´ë”ì— ìë£Œ ì¶”ê°€
 */
export const useAddDocumentItem = <
  TData = Awaited<ReturnType<typeof addDocumentItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { smartFolderItemId: string; data: AddDriveItemToMyFolderRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { smartFolderItemId: string; data: AddDriveItemToMyFolderRequest }, TContext> => {
  const mutationOptions = getAddDocumentItemMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * í´ë”ë¥¼ ìƒì„±í•˜ê±°ë‚˜ ìˆëŠ” í´ë”ë¥¼ ì¡°íšŒí•˜ëŠ” apiì…ë‹ˆë‹¤.
 * @summary (ì¤‘ë³µí™•ì¸)ë¬¸ì„œì—ì„œ ì‚¬ìš©ìì˜ í´ë” ìƒì„± í˜¹ì€ ì¡°íšŒ
 */
export const addDocsFolder = (
  createDocumentSmartFolderRequest: CreateDocumentSmartFolderRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseSmartFolderItemResult>(
    {
      url: `/file/v1/smart-folder/docs/add-folder`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createDocumentSmartFolderRequest,
      signal,
    },
    options,
  );
};

export const getAddDocsFolderMutationOptions = <
  TData = Awaited<ReturnType<typeof addDocsFolder>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CreateDocumentSmartFolderRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['addDocsFolder'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addDocsFolder>>,
    { data: CreateDocumentSmartFolderRequest }
  > = (props) => {
    const { data } = props ?? {};

    return addDocsFolder(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: CreateDocumentSmartFolderRequest },
    TContext
  >;
};

export type AddDocsFolderMutationResult = NonNullable<Awaited<ReturnType<typeof addDocsFolder>>>;
export type AddDocsFolderMutationBody = CreateDocumentSmartFolderRequest;
export type AddDocsFolderMutationError = unknown;

/**
 * @summary (ì¤‘ë³µí™•ì¸)ë¬¸ì„œì—ì„œ ì‚¬ìš©ìì˜ í´ë” ìƒì„± í˜¹ì€ ì¡°íšŒ
 */
export const useAddDocsFolder = <
  TData = Awaited<ReturnType<typeof addDocsFolder>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CreateDocumentSmartFolderRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: CreateDocumentSmartFolderRequest }, TContext> => {
  const mutationOptions = getAddDocsFolderMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ì¶”ì²œëœ ìë£Œë¥¼ ë” ì´ìƒ ì¶”ì²œë°›ì§€ ì•Šë„ë¡ í•©ë‹ˆë‹¤. ì„±ê³µí•˜ë©´ resultì— trueë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
 * @summary ì¶”ì²œëœ ìë£Œë¥¼ ë‹¤ì‹œ ì¶”ì²œë˜ì§€ ì•Šë„ë¡ í•˜ëŠ” api
 */
export const rejectRecommendationItem = (
  rejectRecommendationItemRequest: RejectRecommendationItemRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseBoolean>(
    {
      url: `/file/v1/recommendation/reject`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: rejectRecommendationItemRequest,
      signal,
    },
    options,
  );
};

export const getRejectRecommendationItemMutationOptions = <
  TData = Awaited<ReturnType<typeof rejectRecommendationItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: RejectRecommendationItemRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['rejectRecommendationItem'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof rejectRecommendationItem>>,
    { data: RejectRecommendationItemRequest }
  > = (props) => {
    const { data } = props ?? {};

    return rejectRecommendationItem(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: RejectRecommendationItemRequest },
    TContext
  >;
};

export type RejectRecommendationItemMutationResult = NonNullable<Awaited<ReturnType<typeof rejectRecommendationItem>>>;
export type RejectRecommendationItemMutationBody = RejectRecommendationItemRequest;
export type RejectRecommendationItemMutationError = unknown;

/**
 * @summary ì¶”ì²œëœ ìë£Œë¥¼ ë‹¤ì‹œ ì¶”ì²œë˜ì§€ ì•Šë„ë¡ í•˜ëŠ” api
 */
export const useRejectRecommendationItem = <
  TData = Awaited<ReturnType<typeof rejectRecommendationItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: RejectRecommendationItemRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: RejectRecommendationItemRequest }, TContext> => {
  const mutationOptions = getRejectRecommendationItemMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ë‚ ì§œ ê¸°ì¤€ìœ¼ë¡œ ì¶”ì²œ í‚¤ì›Œë“œ ëª©ë¡ì„ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary ì¶”ì²œ í‚¤ì›Œë“œ ì–»ê¸°
 */
export const getRecommendationKeyword = (
  params?: GetRecommendationKeywordParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListString>(
    { url: `/file/v1/recommendation/common-keywords`, method: 'GET', params, signal },
    options,
  );
};

export const getGetRecommendationKeywordQueryKey = (params?: GetRecommendationKeywordParams) => {
  return [`/file/v1/recommendation/common-keywords`, ...(params ? [params] : [])] as const;
};

export const getGetRecommendationKeywordQueryOptions = <
  TData = Awaited<ReturnType<typeof getRecommendationKeyword>>,
  TError = unknown,
>(
  params?: GetRecommendationKeywordParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendationKeyword>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRecommendationKeywordQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecommendationKeyword>>> = ({ signal }) =>
    getRecommendationKeyword(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRecommendationKeyword>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetRecommendationKeywordQueryResult = NonNullable<Awaited<ReturnType<typeof getRecommendationKeyword>>>;
export type GetRecommendationKeywordQueryError = unknown;

export function useGetRecommendationKeyword<
  TData = Awaited<ReturnType<typeof getRecommendationKeyword>>,
  TError = unknown,
>(
  params: undefined | GetRecommendationKeywordParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendationKeyword>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getRecommendationKeyword>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetRecommendationKeyword<
  TData = Awaited<ReturnType<typeof getRecommendationKeyword>>,
  TError = unknown,
>(
  params?: GetRecommendationKeywordParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendationKeyword>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getRecommendationKeyword>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetRecommendationKeyword<
  TData = Awaited<ReturnType<typeof getRecommendationKeyword>>,
  TError = unknown,
>(
  params?: GetRecommendationKeywordParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendationKeyword>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ì¶”ì²œ í‚¤ì›Œë“œ ì–»ê¸°
 */

export function useGetRecommendationKeyword<
  TData = Awaited<ReturnType<typeof getRecommendationKeyword>>,
  TError = unknown,
>(
  params?: GetRecommendationKeywordParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendationKeyword>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetRecommendationKeywordQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ì¶”ì²œí•  í‚¤ì›Œë“œë¥¼ ë“±ë¡í•©ë‹ˆë‹¤.
 * @summary ì¶”ì²œ í‚¤ì›Œë“œ ë“±ë¡
 */
export const addRecommendationKeyword = (
  recommendationKeywordBundleAddRequest: RecommendationKeywordBundleAddRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseRecommendationKeywordBundleResult>(
    {
      url: `/file/v1/recommendation/common-keywords`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: recommendationKeywordBundleAddRequest,
      signal,
    },
    options,
  );
};

export const getAddRecommendationKeywordMutationOptions = <
  TData = Awaited<ReturnType<typeof addRecommendationKeyword>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: RecommendationKeywordBundleAddRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['addRecommendationKeyword'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addRecommendationKeyword>>,
    { data: RecommendationKeywordBundleAddRequest }
  > = (props) => {
    const { data } = props ?? {};

    return addRecommendationKeyword(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: RecommendationKeywordBundleAddRequest },
    TContext
  >;
};

export type AddRecommendationKeywordMutationResult = NonNullable<Awaited<ReturnType<typeof addRecommendationKeyword>>>;
export type AddRecommendationKeywordMutationBody = RecommendationKeywordBundleAddRequest;
export type AddRecommendationKeywordMutationError = unknown;

/**
 * @summary ì¶”ì²œ í‚¤ì›Œë“œ ë“±ë¡
 */
export const useAddRecommendationKeyword = <
  TData = Awaited<ReturnType<typeof addRecommendationKeyword>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: RecommendationKeywordBundleAddRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: RecommendationKeywordBundleAddRequest }, TContext> => {
  const mutationOptions = getAddRecommendationKeywordMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * í´ë”ë¥¼ ìƒì„±í•˜ê±°ë‚˜ ìˆëŠ” í´ë”ë¥¼ ì¡°íšŒí•˜ëŠ” apiì…ë‹ˆë‹¤.parentSmartFolderId ë¥¼ ì „ë‹¬í•˜ì§€ ì•Šìœ¼ì‹œë©´ ë‚´í´ë” í™ˆì— ì¶”ê°€ ë©ë‹ˆë‹¤.
 * @summary (ì¤‘ë³µí™•ì¸)í´ë” ìƒì„±
 */
export const addFolder = (
  createMyFolderRequest: CreateMyFolderRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseSmartFolderItemResult>(
    {
      url: `/file/v1/my-folder`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createMyFolderRequest,
      signal,
    },
    options,
  );
};

export const getAddFolderMutationOptions = <
  TData = Awaited<ReturnType<typeof addFolder>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CreateMyFolderRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['addFolder'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof addFolder>>, { data: CreateMyFolderRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return addFolder(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: CreateMyFolderRequest },
    TContext
  >;
};

export type AddFolderMutationResult = NonNullable<Awaited<ReturnType<typeof addFolder>>>;
export type AddFolderMutationBody = CreateMyFolderRequest;
export type AddFolderMutationError = unknown;

/**
 * @summary (ì¤‘ë³µí™•ì¸)í´ë” ìƒì„±
 */
export const useAddFolder = <
  TData = Awaited<ReturnType<typeof addFolder>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CreateMyFolderRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: CreateMyFolderRequest }, TContext> => {
  const mutationOptions = getAddFolderMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ì§€ì •í•œ ë‚´í´ë”ì˜ idë¡œ ìë£Œ ëª©ë¡ì„ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary ë‚´ í´ë”ì˜ ìë£Œ ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ
 */
export const getIncludedItemsDeprecate = (
  smartFolderItemid: string,
  params?: GetIncludedItemsDeprecateParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/file/v1/my-folder/${smartFolderItemid}`, method: 'GET', params, signal },
    options,
  );
};

export const getGetIncludedItemsDeprecateQueryKey = (
  smartFolderItemid: string,
  params?: GetIncludedItemsDeprecateParams,
) => {
  return [`/file/v1/my-folder/${smartFolderItemid}`, ...(params ? [params] : [])] as const;
};

export const getGetIncludedItemsDeprecateQueryOptions = <
  TData = Awaited<ReturnType<typeof getIncludedItemsDeprecate>>,
  TError = unknown,
>(
  smartFolderItemid: string,
  params?: GetIncludedItemsDeprecateParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncludedItemsDeprecate>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetIncludedItemsDeprecateQueryKey(smartFolderItemid, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getIncludedItemsDeprecate>>> = ({ signal }) =>
    getIncludedItemsDeprecate(smartFolderItemid, params, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!smartFolderItemid, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getIncludedItemsDeprecate>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetIncludedItemsDeprecateQueryResult = NonNullable<Awaited<ReturnType<typeof getIncludedItemsDeprecate>>>;
export type GetIncludedItemsDeprecateQueryError = unknown;

export function useGetIncludedItemsDeprecate<
  TData = Awaited<ReturnType<typeof getIncludedItemsDeprecate>>,
  TError = unknown,
>(
  smartFolderItemid: string,
  params: undefined | GetIncludedItemsDeprecateParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncludedItemsDeprecate>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getIncludedItemsDeprecate>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetIncludedItemsDeprecate<
  TData = Awaited<ReturnType<typeof getIncludedItemsDeprecate>>,
  TError = unknown,
>(
  smartFolderItemid: string,
  params?: GetIncludedItemsDeprecateParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncludedItemsDeprecate>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getIncludedItemsDeprecate>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetIncludedItemsDeprecate<
  TData = Awaited<ReturnType<typeof getIncludedItemsDeprecate>>,
  TError = unknown,
>(
  smartFolderItemid: string,
  params?: GetIncludedItemsDeprecateParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncludedItemsDeprecate>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ë‚´ í´ë”ì˜ ìë£Œ ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ
 */

export function useGetIncludedItemsDeprecate<
  TData = Awaited<ReturnType<typeof getIncludedItemsDeprecate>>,
  TError = unknown,
>(
  smartFolderItemid: string,
  params?: GetIncludedItemsDeprecateParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncludedItemsDeprecate>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetIncludedItemsDeprecateQueryOptions(smartFolderItemid, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ì‚¬ìš©ìê°€ ì§€ì •í•œ ë‚´ í´ë”ì— ìë£Œë“¤ì„ ì¶”ê°€í•©ë‹ˆë””. í´ë”ëŠ” ì¶”ê°€í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.ìƒìœ„ í´ë”ì˜ ê³µê°œëœ ìƒíƒœë¥¼ ì´ì–´ë°›ê³ , ë‹¤ë¥¸ì‚¬ëŒì˜ ìë£Œë©´ ë‚´ ë“œë¼ì´ë¸Œì˜ ë‚´ í´ë” í•˜ìœ„ì— ë³µì‚¬ë„ ì§„í–‰í•©ë‹ˆë‹¤.
 * @summary ë‚´ í´ë”ì— ìë£Œ ì¶”ê°€
 */
export const addDriveItem = (
  smartFolderItemid: string,
  addDriveItemToMyFolderRequest: AddDriveItemToMyFolderRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseString>(
    {
      url: `/file/v1/my-folder/${smartFolderItemid}`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: addDriveItemToMyFolderRequest,
      signal,
    },
    options,
  );
};

export const getAddDriveItemMutationOptions = <
  TData = Awaited<ReturnType<typeof addDriveItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { smartFolderItemid: string; data: AddDriveItemToMyFolderRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['addDriveItem'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addDriveItem>>,
    { smartFolderItemid: string; data: AddDriveItemToMyFolderRequest }
  > = (props) => {
    const { smartFolderItemid, data } = props ?? {};

    return addDriveItem(smartFolderItemid, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { smartFolderItemid: string; data: AddDriveItemToMyFolderRequest },
    TContext
  >;
};

export type AddDriveItemMutationResult = NonNullable<Awaited<ReturnType<typeof addDriveItem>>>;
export type AddDriveItemMutationBody = AddDriveItemToMyFolderRequest;
export type AddDriveItemMutationError = unknown;

/**
 * @summary ë‚´ í´ë”ì— ìë£Œ ì¶”ê°€
 */
export const useAddDriveItem = <
  TData = Awaited<ReturnType<typeof addDriveItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { smartFolderItemid: string; data: AddDriveItemToMyFolderRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { smartFolderItemid: string; data: AddDriveItemToMyFolderRequest }, TContext> => {
  const mutationOptions = getAddDriveItemMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ë§ˆì´ë³´ë“œì—ì„œ íƒ­ ë³„ë¡œ ë³´ì—¬ì¤„ ìë£Œ ë¦¬ìŠ¤íŠ¸ì— ìë£Œë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤. ì¶”ê°€ëœ ìë£Œ ë§Œí¼ ê²Œì‹œê¸€ ìˆ˜ê°€ ìë™ìœ¼ë¡œ ì˜¬ë¼ê°‘ë‹ˆë‹¤.
 * @summary ë§ˆì´ë³´ë“œì—ì„œ ë³´ì—¬ì¤„ ìë£Œë¥¼ ì¶”ê°€ í•©ë‹ˆë‹¤.
 */
export const addItemsToMyBoard = (
  profileId: string,
  addDriveItemToMyBoardRequest: AddDriveItemToMyBoardRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseString>(
    {
      url: `/file/v1/my-board/${profileId}/add-item`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: addDriveItemToMyBoardRequest,
      signal,
    },
    options,
  );
};

export const getAddItemsToMyBoardMutationOptions = <
  TData = Awaited<ReturnType<typeof addItemsToMyBoard>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { profileId: string; data: AddDriveItemToMyBoardRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['addItemsToMyBoard'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addItemsToMyBoard>>,
    { profileId: string; data: AddDriveItemToMyBoardRequest }
  > = (props) => {
    const { profileId, data } = props ?? {};

    return addItemsToMyBoard(profileId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { profileId: string; data: AddDriveItemToMyBoardRequest },
    TContext
  >;
};

export type AddItemsToMyBoardMutationResult = NonNullable<Awaited<ReturnType<typeof addItemsToMyBoard>>>;
export type AddItemsToMyBoardMutationBody = AddDriveItemToMyBoardRequest;
export type AddItemsToMyBoardMutationError = unknown;

/**
 * @summary ë§ˆì´ë³´ë“œì—ì„œ ë³´ì—¬ì¤„ ìë£Œë¥¼ ì¶”ê°€ í•©ë‹ˆë‹¤.
 */
export const useAddItemsToMyBoard = <
  TData = Awaited<ReturnType<typeof addItemsToMyBoard>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { profileId: string; data: AddDriveItemToMyBoardRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { profileId: string; data: AddDriveItemToMyBoardRequest }, TContext> => {
  const mutationOptions = getAddItemsToMyBoardMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ë†€ì´ë³´ê³ ì„œ ìƒì„±ìš”ì²­í•œ ë¡œê·¸ë¥¼ ì €ì¥í•©ë‹ˆë‹¤.
 * @summary aiì—ê²Œ ë†€ì´ë³´ê³ ì„œ ìƒì„± ìš”ì²­ ë¡œê·¸ ì €ì¥
 */
export const createLectureReportAiLog = (
  lectureReportCardAiCreationLogAddRequest: LectureReportCardAiCreationLogAddRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseLectureReportCardAiCreationLogResult>(
    {
      url: `/file/v1/lecture-report/card-ai-creation-log`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: lectureReportCardAiCreationLogAddRequest,
      signal,
    },
    options,
  );
};

export const getCreateLectureReportAiLogMutationOptions = <
  TData = Awaited<ReturnType<typeof createLectureReportAiLog>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: LectureReportCardAiCreationLogAddRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['createLectureReportAiLog'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createLectureReportAiLog>>,
    { data: LectureReportCardAiCreationLogAddRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createLectureReportAiLog(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: LectureReportCardAiCreationLogAddRequest },
    TContext
  >;
};

export type CreateLectureReportAiLogMutationResult = NonNullable<Awaited<ReturnType<typeof createLectureReportAiLog>>>;
export type CreateLectureReportAiLogMutationBody = LectureReportCardAiCreationLogAddRequest;
export type CreateLectureReportAiLogMutationError = unknown;

/**
 * @summary aiì—ê²Œ ë†€ì´ë³´ê³ ì„œ ìƒì„± ìš”ì²­ ë¡œê·¸ ì €ì¥
 */
export const useCreateLectureReportAiLog = <
  TData = Awaited<ReturnType<typeof createLectureReportAiLog>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: LectureReportCardAiCreationLogAddRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: LectureReportCardAiCreationLogAddRequest }, TContext> => {
  const mutationOptions = getCreateLectureReportAiLogMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ì—…ë¡œë“œí•  ìë£Œì˜ ì •ë³´ë¥¼ ë“±ë¡í•˜ê³  ì—…ë¡œë“œí•  presigned urlì‘ ìƒì„± ìš”ì²­í•©ë‹ˆë‹¤.
ì—…ë¡œë“œ ìˆœì„œ.
1. ì´ apië¡œ ì—…ë¡œë“œí•  presigned url ìƒì„± ìš”ì²­. ì´ë•Œ ì „ë‹¬ë°›ì€ id ê¸°ì–µ í•„ìš”
2. ì „ë‹¬ ë°›ì€ presigned urlë¡œ íŒŒì¼ ì—…ë¡œë“œ
3. ì—…ë¡œë“œê°€ ì™„ë£Œë˜ë©´ 1ì—ì„œ ì „ë‹¬ ë°›ì€ id(result ë°°ì—´ì† ì›ë³¸ íŒŒì¼ì˜ id = fileObject.id)ì™€ íŒŒì¼ì˜ ì •ë³´ë¥¼ ë“±ë¡í•˜ë©° ì—…ë¡œë“œ í”„ë¡œì„¸ìŠ¤ë¥¼ ì™„ë£Œ
   [í”„ë¡œí•„ì‚¬ì§„ë¥˜(presigned url ìƒì„±í• ë•Œ ì†ŒìŠ¤ PROFILE ì¼ ë•Œ) ì™„ë£Œí–ˆì„ë•ŒëŠ” 2ë²ˆëŒ€ì‹  [PUT] /file/v1/file-objects/{id}/uploaded]
 * @summary íŒŒì¼ì˜ ì—…ë¡œë“œí•  resigned urlì„ ìƒì„± ìš”ì²­
 */
export const uploadPrepare = (
  fileObjectUploadRequest: FileObjectUploadRequest[],
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListFileObjectResult>(
    {
      url: `/file/v1/file-objects`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: fileObjectUploadRequest,
      signal,
    },
    options,
  );
};

export const getUploadPrepareMutationOptions = <
  TData = Awaited<ReturnType<typeof uploadPrepare>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: FileObjectUploadRequest[] }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['uploadPrepare'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof uploadPrepare>>, { data: FileObjectUploadRequest[] }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return uploadPrepare(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: FileObjectUploadRequest[] },
    TContext
  >;
};

export type UploadPrepareMutationResult = NonNullable<Awaited<ReturnType<typeof uploadPrepare>>>;
export type UploadPrepareMutationBody = FileObjectUploadRequest[];
export type UploadPrepareMutationError = unknown;

/**
 * @summary íŒŒì¼ì˜ ì—…ë¡œë“œí•  resigned urlì„ ìƒì„± ìš”ì²­
 */
export const useUploadPrepare = <
  TData = Awaited<ReturnType<typeof uploadPrepare>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: FileObjectUploadRequest[] }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: FileObjectUploadRequest[] }, TContext> => {
  const mutationOptions = getUploadPrepareMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ìë£Œì˜ í‚¤ ê°’ë“¤ë¡œ ì¸ë„¤ì¼ ì£¼ì†Œë¥¼ ìš”ì²­í•©ë‹ˆë‹¤.
 * @summary íŒŒì¼ì˜ ì¸ë„¤ì¼ url ë§í¬ ìš”ì²­
 */
export const getThumbUrls = (
  fileObjectThumbUrlsPostRequest: FileObjectThumbUrlsPostRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseMapStringString>(
    {
      url: `/file/v1/file-objects/thumb-urls`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: fileObjectThumbUrlsPostRequest,
      signal,
    },
    options,
  );
};

export const getGetThumbUrlsMutationOptions = <
  TData = Awaited<ReturnType<typeof getThumbUrls>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: FileObjectThumbUrlsPostRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['getThumbUrls'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof getThumbUrls>>,
    { data: FileObjectThumbUrlsPostRequest }
  > = (props) => {
    const { data } = props ?? {};

    return getThumbUrls(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: FileObjectThumbUrlsPostRequest },
    TContext
  >;
};

export type GetThumbUrlsMutationResult = NonNullable<Awaited<ReturnType<typeof getThumbUrls>>>;
export type GetThumbUrlsMutationBody = FileObjectThumbUrlsPostRequest;
export type GetThumbUrlsMutationError = unknown;

/**
 * @summary íŒŒì¼ì˜ ì¸ë„¤ì¼ url ë§í¬ ìš”ì²­
 */
export const useGetThumbUrls = <
  TData = Awaited<ReturnType<typeof getThumbUrls>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: FileObjectThumbUrlsPostRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: FileObjectThumbUrlsPostRequest }, TContext> => {
  const mutationOptions = getGetThumbUrlsMutationOptions(options);

  return useMutation(mutationOptions);
};

export const updateStt = (
  fileObjectSttTextPostRequest: FileObjectSttTextPostRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseFileObjectSttTextPostResponse>(
    {
      url: `/file/v1/file-objects/sttFullText`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: fileObjectSttTextPostRequest,
      signal,
    },
    options,
  );
};

export const getUpdateSttMutationOptions = <
  TData = Awaited<ReturnType<typeof updateStt>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: FileObjectSttTextPostRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['updateStt'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateStt>>, { data: FileObjectSttTextPostRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return updateStt(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: FileObjectSttTextPostRequest },
    TContext
  >;
};

export type UpdateSttMutationResult = NonNullable<Awaited<ReturnType<typeof updateStt>>>;
export type UpdateSttMutationBody = FileObjectSttTextPostRequest;
export type UpdateSttMutationError = unknown;

export const useUpdateStt = <
  TData = Awaited<ReturnType<typeof updateStt>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: FileObjectSttTextPostRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: FileObjectSttTextPostRequest }, TContext> => {
  const mutationOptions = getUpdateSttMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ìë£Œë¥¼ ë´¤ë‹¤ê³  íŒë‹¨ ë˜ëŠ” ê²½ìš° í˜¸ì¶œí•©ë‹ˆë‹¤. ì‘ë‹µì—” í•´ë‹¹ ìë£Œì˜ ë·°ì¹´ìš´íŠ¸ê°€ ì‘ë‹µë©ë‹ˆë‹¤.(10ì´ˆ ì´ë‚´ë¡œ ê°™ì€ ì‚¬ìš©ìê°€ ê°™ì€ ìë£Œì— ëŒ€í•´ì„œ ìš”ì²­í•˜ë©´ ë¬´ì‹œë©ë‹ˆë‹¤. ë³¸ì¸ì´ ì†Œìœ í•œ ìë£Œë¥¼ ë·° ì²˜ë¦¬í•´ë„ ë¬´ì‹œë©ë‹ˆë‹¤.)
 * @summary ìë£Œ ë·° ì²˜ë¦¬
 */
export const addViewCount = (
  idOrKey: string,
  addDriveItemViewCountRequest: AddDriveItemViewCountRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseInteger>(
    {
      url: `/file/v1/drive-items/${idOrKey}/view`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: addDriveItemViewCountRequest,
      signal,
    },
    options,
  );
};

export const getAddViewCountMutationOptions = <
  TData = Awaited<ReturnType<typeof addViewCount>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { idOrKey: string; data: AddDriveItemViewCountRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['addViewCount'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addViewCount>>,
    { idOrKey: string; data: AddDriveItemViewCountRequest }
  > = (props) => {
    const { idOrKey, data } = props ?? {};

    return addViewCount(idOrKey, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { idOrKey: string; data: AddDriveItemViewCountRequest },
    TContext
  >;
};

export type AddViewCountMutationResult = NonNullable<Awaited<ReturnType<typeof addViewCount>>>;
export type AddViewCountMutationBody = AddDriveItemViewCountRequest;
export type AddViewCountMutationError = unknown;

/**
 * @summary ìë£Œ ë·° ì²˜ë¦¬
 */
export const useAddViewCount = <
  TData = Awaited<ReturnType<typeof addViewCount>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { idOrKey: string; data: AddDriveItemViewCountRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { idOrKey: string; data: AddDriveItemViewCountRequest }, TContext> => {
  const mutationOptions = getAddViewCountMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ìë£Œì— ë“±ë¡ë˜ì–´ ìˆëŠ” ë©”ëª¨ ë¦¬ìŠ¤íŠ¸ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤  (1ì°¨ì—ì„œëŠ” 1ê°œì”©ë§Œ ì‚¬ìš©)
 * @summary ìë£Œì— ë“±ë¡ëœ ë©”ëª¨ ì¡°íšŒ
 */
export const getDriveItemMemos = (
  idOrKey: string,
  params: GetDriveItemMemosParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListDriveItemMemoResult>(
    { url: `/file/v1/drive-items/${idOrKey}/memos`, method: 'GET', params, signal },
    options,
  );
};

export const getGetDriveItemMemosQueryKey = (idOrKey: string, params: GetDriveItemMemosParams) => {
  return [`/file/v1/drive-items/${idOrKey}/memos`, ...(params ? [params] : [])] as const;
};

export const getGetDriveItemMemosQueryOptions = <
  TData = Awaited<ReturnType<typeof getDriveItemMemos>>,
  TError = unknown,
>(
  idOrKey: string,
  params: GetDriveItemMemosParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDriveItemMemos>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDriveItemMemosQueryKey(idOrKey, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDriveItemMemos>>> = ({ signal }) =>
    getDriveItemMemos(idOrKey, params, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!idOrKey, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getDriveItemMemos>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetDriveItemMemosQueryResult = NonNullable<Awaited<ReturnType<typeof getDriveItemMemos>>>;
export type GetDriveItemMemosQueryError = unknown;

export function useGetDriveItemMemos<TData = Awaited<ReturnType<typeof getDriveItemMemos>>, TError = unknown>(
  idOrKey: string,
  params: GetDriveItemMemosParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDriveItemMemos>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getDriveItemMemos>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetDriveItemMemos<TData = Awaited<ReturnType<typeof getDriveItemMemos>>, TError = unknown>(
  idOrKey: string,
  params: GetDriveItemMemosParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDriveItemMemos>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getDriveItemMemos>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetDriveItemMemos<TData = Awaited<ReturnType<typeof getDriveItemMemos>>, TError = unknown>(
  idOrKey: string,
  params: GetDriveItemMemosParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDriveItemMemos>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ìë£Œì— ë“±ë¡ëœ ë©”ëª¨ ì¡°íšŒ
 */

export function useGetDriveItemMemos<TData = Awaited<ReturnType<typeof getDriveItemMemos>>, TError = unknown>(
  idOrKey: string,
  params: GetDriveItemMemosParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDriveItemMemos>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetDriveItemMemosQueryOptions(idOrKey, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ìë£Œì— ë©”ëª¨ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤. (1ì°¨ì—ì„œëŠ” ì‚¬ì§„ ë©”ëª¨ë§Œ)
 * @summary ìë£Œ(ì‚¬ì§„)ì— ë©”ëª¨ ë“±ë¡
 */
export const addMemoToFile = (
  idOrKey: string,
  driveItemMemoAddRequest: DriveItemMemoAddRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseDriveItemMemoResult>(
    {
      url: `/file/v1/drive-items/${idOrKey}/memos`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: driveItemMemoAddRequest,
      signal,
    },
    options,
  );
};

export const getAddMemoToFileMutationOptions = <
  TData = Awaited<ReturnType<typeof addMemoToFile>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { idOrKey: string; data: DriveItemMemoAddRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['addMemoToFile'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addMemoToFile>>,
    { idOrKey: string; data: DriveItemMemoAddRequest }
  > = (props) => {
    const { idOrKey, data } = props ?? {};

    return addMemoToFile(idOrKey, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { idOrKey: string; data: DriveItemMemoAddRequest },
    TContext
  >;
};

export type AddMemoToFileMutationResult = NonNullable<Awaited<ReturnType<typeof addMemoToFile>>>;
export type AddMemoToFileMutationBody = DriveItemMemoAddRequest;
export type AddMemoToFileMutationError = unknown;

/**
 * @summary ìë£Œ(ì‚¬ì§„)ì— ë©”ëª¨ ë“±ë¡
 */
export const useAddMemoToFile = <
  TData = Awaited<ReturnType<typeof addMemoToFile>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { idOrKey: string; data: DriveItemMemoAddRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { idOrKey: string; data: DriveItemMemoAddRequest }, TContext> => {
  const mutationOptions = getAddMemoToFileMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ìë£Œë¥¼ ì¢‹ì•„ìš”ì²˜ë¦¬í•˜ê±°ë‚˜, í•´ì œí•©ë‹ˆë‹¤. ì‘ë‹µì€ ì‚¬ìš©ìì˜ ì¢‹ì•„ìš” ìƒíƒœì™€, ìë£Œì˜ ì¢‹ì•„ìš” ìˆ˜ë¥¼ ì‘ë‹µí•©ë‹ˆë‹¤.
 * @summary ìë£Œ ì¢‹ì•„ìš” ì²˜ë¦¬
 */
export const likeDriveItem = (
  profileId: string,
  idOrKey: string,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseDriveItemLikeResult>(
    { url: `/file/v1/drive-items/${idOrKey}/like/${profileId}`, method: 'POST', signal },
    options,
  );
};

export const getLikeDriveItemMutationOptions = <
  TData = Awaited<ReturnType<typeof likeDriveItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { profileId: string; idOrKey: string }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['likeDriveItem'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof likeDriveItem>>,
    { profileId: string; idOrKey: string }
  > = (props) => {
    const { profileId, idOrKey } = props ?? {};

    return likeDriveItem(profileId, idOrKey, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { profileId: string; idOrKey: string },
    TContext
  >;
};

export type LikeDriveItemMutationResult = NonNullable<Awaited<ReturnType<typeof likeDriveItem>>>;

export type LikeDriveItemMutationError = unknown;

/**
 * @summary ìë£Œ ì¢‹ì•„ìš” ì²˜ë¦¬
 */
export const useLikeDriveItem = <
  TData = Awaited<ReturnType<typeof likeDriveItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { profileId: string; idOrKey: string }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { profileId: string; idOrKey: string }, TContext> => {
  const mutationOptions = getLikeDriveItemMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ìë£Œì— ë“±ë¡ëœ ëŒ“ê¸€ ëª©ë¡ì„ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary ìë£Œì˜ ëŒ“ê¸€ ì¡°íšŒ
 */
export const findAllPagingReplies1 = (
  driveItemIdOrKey: string,
  params?: FindAllPagingReplies1Params,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListReplyResult>(
    { url: `/file/v1/drive-items/${driveItemIdOrKey}/replies`, method: 'GET', params, signal },
    options,
  );
};

export const getFindAllPagingReplies1QueryKey = (driveItemIdOrKey: string, params?: FindAllPagingReplies1Params) => {
  return [`/file/v1/drive-items/${driveItemIdOrKey}/replies`, ...(params ? [params] : [])] as const;
};

export const getFindAllPagingReplies1QueryOptions = <
  TData = Awaited<ReturnType<typeof findAllPagingReplies1>>,
  TError = unknown,
>(
  driveItemIdOrKey: string,
  params?: FindAllPagingReplies1Params,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findAllPagingReplies1>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFindAllPagingReplies1QueryKey(driveItemIdOrKey, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findAllPagingReplies1>>> = ({ signal }) =>
    findAllPagingReplies1(driveItemIdOrKey, params, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!driveItemIdOrKey, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findAllPagingReplies1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type FindAllPagingReplies1QueryResult = NonNullable<Awaited<ReturnType<typeof findAllPagingReplies1>>>;
export type FindAllPagingReplies1QueryError = unknown;

export function useFindAllPagingReplies1<TData = Awaited<ReturnType<typeof findAllPagingReplies1>>, TError = unknown>(
  driveItemIdOrKey: string,
  params: undefined | FindAllPagingReplies1Params,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof findAllPagingReplies1>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof findAllPagingReplies1>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useFindAllPagingReplies1<TData = Awaited<ReturnType<typeof findAllPagingReplies1>>, TError = unknown>(
  driveItemIdOrKey: string,
  params?: FindAllPagingReplies1Params,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findAllPagingReplies1>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof findAllPagingReplies1>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useFindAllPagingReplies1<TData = Awaited<ReturnType<typeof findAllPagingReplies1>>, TError = unknown>(
  driveItemIdOrKey: string,
  params?: FindAllPagingReplies1Params,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findAllPagingReplies1>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ìë£Œì˜ ëŒ“ê¸€ ì¡°íšŒ
 */

export function useFindAllPagingReplies1<TData = Awaited<ReturnType<typeof findAllPagingReplies1>>, TError = unknown>(
  driveItemIdOrKey: string,
  params?: FindAllPagingReplies1Params,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findAllPagingReplies1>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getFindAllPagingReplies1QueryOptions(driveItemIdOrKey, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ìë£Œì— ëŒ“ê¸€ì„ ë“±ë¡í•©ë‹ˆë‹¤.
 * @summary ëŒ“ê¸€ ì¶”ê°€
 */
export const addReply = (
  driveItemIdOrKey: string,
  addReplyRequest: AddReplyRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<unknown>(
    {
      url: `/file/v1/drive-items/${driveItemIdOrKey}/replies`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: addReplyRequest,
      signal,
    },
    options,
  );
};

export const getAddReplyMutationOptions = <
  TData = Awaited<ReturnType<typeof addReply>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { driveItemIdOrKey: string; data: AddReplyRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['addReply'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addReply>>,
    { driveItemIdOrKey: string; data: AddReplyRequest }
  > = (props) => {
    const { driveItemIdOrKey, data } = props ?? {};

    return addReply(driveItemIdOrKey, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { driveItemIdOrKey: string; data: AddReplyRequest },
    TContext
  >;
};

export type AddReplyMutationResult = NonNullable<Awaited<ReturnType<typeof addReply>>>;
export type AddReplyMutationBody = AddReplyRequest;
export type AddReplyMutationError = unknown;

/**
 * @summary ëŒ“ê¸€ ì¶”ê°€
 */
export const useAddReply = <
  TData = Awaited<ReturnType<typeof addReply>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { driveItemIdOrKey: string; data: AddReplyRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { driveItemIdOrKey: string; data: AddReplyRequest }, TContext> => {
  const mutationOptions = getAddReplyMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * 1. ë³¸ì¸ ìë£Œì—ë§Œ íƒœê·¸ë¥¼ ì¶”ê°€, ì‚­ì œí•  ìˆ˜ ìˆë‹¤.
2. í´ë”ì˜ ê²½ìš°, í•˜ìœ„ í•­ëª©ì—ëŠ” ì˜í–¥ì„ ë¯¸ì¹˜ì§€ ì•ŠëŠ”ë‹¤.
3. ìë£Œì— ì—°ê²°ëœ ê¸°ì¡´ íƒœê·¸ëŠ” ì‚­ì œë˜ê³  íŒŒë¼ë¯¸í„°ë¡œ ì „ë‹¬í•œ íƒœê·¸ê°€ ìˆœì„œë¥¼ ìœ ì§€í•˜ì—¬ ì €ì¥ëœë‹¤.
3-1. íƒœê·¸ ì €ì¥ì€ íƒœê·¸ ë­‰ì¹˜(Bundle) ë‹¨ìœ„ë¡œ ì§„í–‰
4. ìµœê·¼ ì‚¬ìš©í•œ íƒœê·¸ëŠ” FIFO ë°©ì‹ìœ¼ë¡œ ì—…ë°ì´íŠ¸í•œë‹¤. ë“±ë¡í•œ íƒœê·¸ ë­‰ì¹˜ì— íƒœê·¸ ìˆ˜ê°€ Nê°œ ì¼ë•Œ,
4-1. if N == 10, ì´ ì •ë³´ë¥¼ ê·¸ëŒ€ë¡œ ìµœê·¼ ì‚¬ìš© íƒœê·¸ë¡œ ì§€ì •í•œë‹¤.
4-2. if N < 10, ë¬¸ìì—´ ê²°í•©(`ë“±ë¡ íƒœê·¸ ë­‰ì¹˜` + `ìµœê·¼ íƒœê·¸ ë­‰ì¹˜` ìˆœì„œ) -> ë’¤ìª½ ì¤‘ë³µ íƒœê·¸ ì œê±° -> ë‚¨ì€ íƒœê·¸ ì¤‘, ìµœëŒ€ 10ê°œë¥¼ ì €ì¥í•œë‹¤.
5. íƒœê·¸ì˜ ì¶”ê°€, ì‚­ì œ ê¸°ë¡ì€ ë¡œê·¸ í…Œì´ë¸”ì— ì €ì¥ëœë‹¤.
 * @summary ìë£Œì— íƒœê·¸ ë“±ë¡
 */
export const addTag = (
  driveItemAddTagRequest: DriveItemAddTagRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseString>(
    {
      url: `/file/v1/drive-items/tagging`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: driveItemAddTagRequest,
      signal,
    },
    options,
  );
};

export const getAddTagMutationOptions = <
  TData = Awaited<ReturnType<typeof addTag>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: DriveItemAddTagRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['addTag'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof addTag>>, { data: DriveItemAddTagRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return addTag(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: DriveItemAddTagRequest },
    TContext
  >;
};

export type AddTagMutationResult = NonNullable<Awaited<ReturnType<typeof addTag>>>;
export type AddTagMutationBody = DriveItemAddTagRequest;
export type AddTagMutationError = unknown;

/**
 * @summary ìë£Œì— íƒœê·¸ ë“±ë¡
 */
export const useAddTag = <TData = Awaited<ReturnType<typeof addTag>>, TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: DriveItemAddTagRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: DriveItemAddTagRequest }, TContext> => {
  const mutationOptions = getAddTagMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ì›ë³¸ ìë£Œë¥¼ ë‹¤ìš´ ë°›ì„ ìˆ˜ ìˆëŠ” presigned urlë¥¼ ìš”ì²­í•˜ëŠ” api ì…ë‹ˆë‹¤.(í´ë”ë„ ê°€ëŠ¥.)
 * @summary ìë£Œì˜ ë‹¤ìš´ë¡œë“œ ë§í¬ ìš”ì²­
 */
export const getCdnFilesForDownload = (
  cdnFilesForDownloadRequest: CdnFilesForDownloadRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListCdnFileResult>(
    {
      url: `/file/v1/drive-items/presigned-urls`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: cdnFilesForDownloadRequest,
      signal,
    },
    options,
  );
};

export const getGetCdnFilesForDownloadMutationOptions = <
  TData = Awaited<ReturnType<typeof getCdnFilesForDownload>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CdnFilesForDownloadRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['getCdnFilesForDownload'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof getCdnFilesForDownload>>,
    { data: CdnFilesForDownloadRequest }
  > = (props) => {
    const { data } = props ?? {};

    return getCdnFilesForDownload(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: CdnFilesForDownloadRequest },
    TContext
  >;
};

export type GetCdnFilesForDownloadMutationResult = NonNullable<Awaited<ReturnType<typeof getCdnFilesForDownload>>>;
export type GetCdnFilesForDownloadMutationBody = CdnFilesForDownloadRequest;
export type GetCdnFilesForDownloadMutationError = unknown;

/**
 * @summary ìë£Œì˜ ë‹¤ìš´ë¡œë“œ ë§í¬ ìš”ì²­
 */
export const useGetCdnFilesForDownload = <
  TData = Awaited<ReturnType<typeof getCdnFilesForDownload>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CdnFilesForDownloadRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: CdnFilesForDownloadRequest }, TContext> => {
  const mutationOptions = getGetCdnFilesForDownloadMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ë‚´í´ë”ì•ˆì— ì¦ê²¨ì°¾ê¸°ì— ë„£ê±°ë‚˜ ë¹¼ê³ , ì¦ê²¨ì°¾ê¸°ì— ë„£ì–´ìˆì„ ê²½ìš° trueë¥¼ í•´ì œí–ˆì„ ê²½ìš° falseë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
 * @summary ì¦ê²¨ì°¾ê¸° í† ê¸€(ë³„í‘œì‹œ ì¼œê¸°ë„ê¸°)
 */
export const starred = (
  profileIdAndDriveItemKeyRequest: ProfileIdAndDriveItemKeyRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseBoolean>(
    {
      url: `/file/v1/common-smart-folder/toggle-favorite`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: profileIdAndDriveItemKeyRequest,
      signal,
    },
    options,
  );
};

export const getStarredMutationOptions = <
  TData = Awaited<ReturnType<typeof starred>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: ProfileIdAndDriveItemKeyRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['starred'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof starred>>, { data: ProfileIdAndDriveItemKeyRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return starred(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: ProfileIdAndDriveItemKeyRequest },
    TContext
  >;
};

export type StarredMutationResult = NonNullable<Awaited<ReturnType<typeof starred>>>;
export type StarredMutationBody = ProfileIdAndDriveItemKeyRequest;
export type StarredMutationError = unknown;

/**
 * @summary ì¦ê²¨ì°¾ê¸° í† ê¸€(ë³„í‘œì‹œ ì¼œê¸°ë„ê¸°)
 */
export const useStarred = <
  TData = Awaited<ReturnType<typeof starred>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: ProfileIdAndDriveItemKeyRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: ProfileIdAndDriveItemKeyRequest }, TContext> => {
  const mutationOptions = getStarredMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * presigned urlë¡œ ì—…ë¡œë“œë¥¼ ì™„ë£Œí•œ ê²½ìš° ì •ë³´ë¥¼ ì „ë‹¬ ë°›ì•„ ì‹¤ì œë¡œ ì„œë¹„ìŠ¤ì— ë‚˜ì˜¬ ìˆ˜ ìˆë„ë¡ ì •ë³´ë¥¼ ì…ë ¥í•©ë‹ˆë‹¤.ì¸ë„¤ì¼ì€ ì „ì†¡í•˜ì§€ì•Šê³ , í”„ë¡œí•„ì‚¬ì§„/ì•„ì´ì‚¬ì§„ì¼ ê²½ìš° /file/v1/file-objects/{fileObjectId}/uploaded 
ì—…ë¡œë“œ ìˆœì„œ.
1. [POST]/file/v1/file-objectsë¡œ ì—…ë¡œë“œí•  presigned url ìƒì„± ìš”ì²­. ì´ë•Œ ì „ë‹¬ë°›ì€ id ê¸°ì–µ í•„ìš”
2. ì „ë‹¬ ë°›ì€ presigned urlë¡œ íŒŒì¼ ì—…ë¡œë“œ
3. ì—…ë¡œë“œê°€ ì™„ë£Œë˜ë©´ 1ì—ì„œ ì „ë‹¬ ë°›ì€ id(result ë°°ì—´ì† ì›ë³¸ íŒŒì¼ì˜ id = fileObject.id)ì™€ íŒŒì¼ì˜ ì •ë³´ë¥¼ ë“±ë¡í•˜ë©° ì—…ë¡œë“œ í”„ë¡œì„¸ìŠ¤ë¥¼ ì™„ë£Œ
   [í”„ë¡œí•„ì‚¬ì§„ë¥˜(presigned url ìƒì„±í• ë•Œ ì†ŒìŠ¤ PROFILE ì¼ ë•Œ) ì™„ë£Œí–ˆì„ë•ŒëŠ” 2ë²ˆëŒ€ì‹  [PUT] /file/v1/file-objects/{id}/uploaded]
 * @summary ìë£Œ ì—…ë¡œë“œ ì™„ë£Œ ì²˜ë¦¬
 */
export const uploadCompleted1 = (
  fileObjectId: string,
  commonUploadCompletedRequest: CommonUploadCompletedRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseSmartFolderItemResult>(
    {
      url: `/file/v1/common-smart-folder/file-object/${fileObjectId}/upload-complete`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: commonUploadCompletedRequest,
      signal,
    },
    options,
  );
};

export const getUploadCompleted1MutationOptions = <
  TData = Awaited<ReturnType<typeof uploadCompleted1>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { fileObjectId: string; data: CommonUploadCompletedRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['uploadCompleted1'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof uploadCompleted1>>,
    { fileObjectId: string; data: CommonUploadCompletedRequest }
  > = (props) => {
    const { fileObjectId, data } = props ?? {};

    return uploadCompleted1(fileObjectId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { fileObjectId: string; data: CommonUploadCompletedRequest },
    TContext
  >;
};

export type UploadCompleted1MutationResult = NonNullable<Awaited<ReturnType<typeof uploadCompleted1>>>;
export type UploadCompleted1MutationBody = CommonUploadCompletedRequest;
export type UploadCompleted1MutationError = unknown;

/**
 * @summary ìë£Œ ì—…ë¡œë“œ ì™„ë£Œ ì²˜ë¦¬
 */
export const useUploadCompleted1 = <
  TData = Awaited<ReturnType<typeof uploadCompleted1>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { fileObjectId: string; data: CommonUploadCompletedRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { fileObjectId: string; data: CommonUploadCompletedRequest }, TContext> => {
  const mutationOptions = getUploadCompleted1MutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ìƒˆ ë©”ëª¨ íŒŒì¼ì„ ë“±ë¡í•©ë‹ˆë‹¤.
 * @summary ë©”ëª¨ íŒŒì¼ì„ ìƒì„±í•˜ëŠ” api
 */
export const createMemoFile = (
  memoFileCreateRequest: MemoFileCreateRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseSmartFolderItemResult>(
    {
      url: `/file/v1/common-smart-folder/create-memo-file`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: memoFileCreateRequest,
      signal,
    },
    options,
  );
};

export const getCreateMemoFileMutationOptions = <
  TData = Awaited<ReturnType<typeof createMemoFile>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MemoFileCreateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['createMemoFile'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof createMemoFile>>, { data: MemoFileCreateRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return createMemoFile(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: MemoFileCreateRequest },
    TContext
  >;
};

export type CreateMemoFileMutationResult = NonNullable<Awaited<ReturnType<typeof createMemoFile>>>;
export type CreateMemoFileMutationBody = MemoFileCreateRequest;
export type CreateMemoFileMutationError = unknown;

/**
 * @summary ë©”ëª¨ íŒŒì¼ì„ ìƒì„±í•˜ëŠ” api
 */
export const useCreateMemoFile = <
  TData = Awaited<ReturnType<typeof createMemoFile>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MemoFileCreateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: MemoFileCreateRequest }, TContext> => {
  const mutationOptions = getCreateMemoFileMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ì‚¬ìš©ìê°€ ì§€ì •í•œ í´ë”ì— ìë£Œë“¤ì„ ì¶”ê°€í•©ë‹ˆë‹¤. í´ë”ëŠ” ì¶”ê°€í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.ìƒìœ„ í´ë”ì˜ ê³µê°œëœ ìƒíƒœë¥¼ ì´ì–´ë°›ê³ , ë‹¤ë¥¸ì‚¬ëŒì˜ ìë£Œë©´ ë‚´ ë“œë¼ì´ë¸Œì— ë³µì‚¬ë„ ì§„í–‰í•©ë‹ˆë‹¤.
 * @summary ìŠ¤ë§ˆíŠ¸ í´ë”ì— ìë£Œ ì¶”ê°€
 */
export const addItem = (
  commonAddDriveItemToSmartFolderRequest: CommonAddDriveItemToSmartFolderRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseString>(
    {
      url: `/file/v1/common-smart-folder/add-item`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: commonAddDriveItemToSmartFolderRequest,
      signal,
    },
    options,
  );
};

export const getAddItemMutationOptions = <
  TData = Awaited<ReturnType<typeof addItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CommonAddDriveItemToSmartFolderRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['addItem'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addItem>>,
    { data: CommonAddDriveItemToSmartFolderRequest }
  > = (props) => {
    const { data } = props ?? {};

    return addItem(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: CommonAddDriveItemToSmartFolderRequest },
    TContext
  >;
};

export type AddItemMutationResult = NonNullable<Awaited<ReturnType<typeof addItem>>>;
export type AddItemMutationBody = CommonAddDriveItemToSmartFolderRequest;
export type AddItemMutationError = unknown;

/**
 * @summary ìŠ¤ë§ˆíŠ¸ í´ë”ì— ìë£Œ ì¶”ê°€
 */
export const useAddItem = <
  TData = Awaited<ReturnType<typeof addItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CommonAddDriveItemToSmartFolderRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: CommonAddDriveItemToSmartFolderRequest }, TContext> => {
  const mutationOptions = getAddItemMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ì‚¬ìš©ìê°€ ì§€ì •í•œ í´ë”ì— ìë£Œë“¤ì„ ì¶”ê°€í•©ë‹ˆë‹¤. í´ë”ëŠ” ì¶”ê°€í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.ìƒìœ„ í´ë”ì˜ ê³µê°œëœ ìƒíƒœë¥¼ ì´ì–´ë°›ê³ , ë‹¤ë¥¸ì‚¬ëŒì˜ ìë£Œë©´ ë‚´ ë“œë¼ì´ë¸Œì— ë³µì‚¬ë„ ì§„í–‰í•©ë‹ˆë‹¤.
 * @summary ìŠ¤ë§ˆíŠ¸ í´ë”ì— ìë£Œ ì¶”ê°€
 */
export const addItemWithApiTypeAndId = (
  commonAddDriveItemToSmartFolderWithIdRequest: CommonAddDriveItemToSmartFolderWithIdRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseString>(
    {
      url: `/file/v1/common-smart-folder/add-item-with-ids`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: commonAddDriveItemToSmartFolderWithIdRequest,
      signal,
    },
    options,
  );
};

export const getAddItemWithApiTypeAndIdMutationOptions = <
  TData = Awaited<ReturnType<typeof addItemWithApiTypeAndId>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CommonAddDriveItemToSmartFolderWithIdRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['addItemWithApiTypeAndId'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addItemWithApiTypeAndId>>,
    { data: CommonAddDriveItemToSmartFolderWithIdRequest }
  > = (props) => {
    const { data } = props ?? {};

    return addItemWithApiTypeAndId(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: CommonAddDriveItemToSmartFolderWithIdRequest },
    TContext
  >;
};

export type AddItemWithApiTypeAndIdMutationResult = NonNullable<Awaited<ReturnType<typeof addItemWithApiTypeAndId>>>;
export type AddItemWithApiTypeAndIdMutationBody = CommonAddDriveItemToSmartFolderWithIdRequest;
export type AddItemWithApiTypeAndIdMutationError = unknown;

/**
 * @summary ìŠ¤ë§ˆíŠ¸ í´ë”ì— ìë£Œ ì¶”ê°€
 */
export const useAddItemWithApiTypeAndId = <
  TData = Awaited<ReturnType<typeof addItemWithApiTypeAndId>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CommonAddDriveItemToSmartFolderWithIdRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: CommonAddDriveItemToSmartFolderWithIdRequest }, TContext> => {
  const mutationOptions = getAddItemWithApiTypeAndIdMutationOptions(options);

  return useMutation(mutationOptions);
};

export const addFolder1 = (
  createSmartFolderRequest: CreateSmartFolderRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseSmartFolderItemResult>(
    {
      url: `/file/v1/common-smart-folder/add-folder`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createSmartFolderRequest,
      signal,
    },
    options,
  );
};

export const getAddFolder1MutationOptions = <
  TData = Awaited<ReturnType<typeof addFolder1>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CreateSmartFolderRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['addFolder1'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof addFolder1>>, { data: CreateSmartFolderRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return addFolder1(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: CreateSmartFolderRequest },
    TContext
  >;
};

export type AddFolder1MutationResult = NonNullable<Awaited<ReturnType<typeof addFolder1>>>;
export type AddFolder1MutationBody = CreateSmartFolderRequest;
export type AddFolder1MutationError = unknown;

export const useAddFolder1 = <
  TData = Awaited<ReturnType<typeof addFolder1>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CreateSmartFolderRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: CreateSmartFolderRequest }, TContext> => {
  const mutationOptions = getAddFolder1MutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ì‚¬ìš©ìì˜ í˜„ì¬ ì €ì¥ì†Œ ì •ë³´ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary ì‚¬ìš©ìì˜ ì €ì¥ì†Œ ì¡°íšŒ
 */
export const getByProfileId = (
  profileId: string,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseStorageUsageResult>(
    { url: `/file/v2/storage-usages/${profileId}`, method: 'GET', signal },
    options,
  );
};

export const getGetByProfileIdQueryKey = (profileId: string) => {
  return [`/file/v2/storage-usages/${profileId}`] as const;
};

export const getGetByProfileIdQueryOptions = <TData = Awaited<ReturnType<typeof getByProfileId>>, TError = unknown>(
  profileId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getByProfileId>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetByProfileIdQueryKey(profileId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getByProfileId>>> = ({ signal }) =>
    getByProfileId(profileId, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getByProfileId>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetByProfileIdQueryResult = NonNullable<Awaited<ReturnType<typeof getByProfileId>>>;
export type GetByProfileIdQueryError = unknown;

export function useGetByProfileId<TData = Awaited<ReturnType<typeof getByProfileId>>, TError = unknown>(
  profileId: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getByProfileId>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getByProfileId>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetByProfileId<TData = Awaited<ReturnType<typeof getByProfileId>>, TError = unknown>(
  profileId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getByProfileId>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getByProfileId>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetByProfileId<TData = Awaited<ReturnType<typeof getByProfileId>>, TError = unknown>(
  profileId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getByProfileId>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ì‚¬ìš©ìì˜ ì €ì¥ì†Œ ì¡°íšŒ
 */

export function useGetByProfileId<TData = Awaited<ReturnType<typeof getByProfileId>>, TError = unknown>(
  profileId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getByProfileId>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetByProfileIdQueryOptions(profileId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ì‚¬ìš©ì í”„ë¡œí•„ idë¡œ ìµœê·¼ì— íƒœê·¸ë¡œ ë“±ë¡í•œ í‚¤ì›Œë“œë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤. (ì—†ìœ¼ë©´ ë¹ˆ ë°°ì—´ ì‘ë‹µ)
 * @summary ìµœê·¼ ì‚¬ìš© íƒœê·¸ ì–»ê¸°v2
 */
export const getRecentTagsV2 = (
  profileId: string,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListString>(
    { url: `/file/v2/recent-tags/${profileId}`, method: 'GET', signal },
    options,
  );
};

export const getGetRecentTagsV2QueryKey = (profileId: string) => {
  return [`/file/v2/recent-tags/${profileId}`] as const;
};

export const getGetRecentTagsV2QueryOptions = <TData = Awaited<ReturnType<typeof getRecentTagsV2>>, TError = unknown>(
  profileId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentTagsV2>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRecentTagsV2QueryKey(profileId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecentTagsV2>>> = ({ signal }) =>
    getRecentTagsV2(profileId, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRecentTagsV2>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetRecentTagsV2QueryResult = NonNullable<Awaited<ReturnType<typeof getRecentTagsV2>>>;
export type GetRecentTagsV2QueryError = unknown;

export function useGetRecentTagsV2<TData = Awaited<ReturnType<typeof getRecentTagsV2>>, TError = unknown>(
  profileId: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentTagsV2>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getRecentTagsV2>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetRecentTagsV2<TData = Awaited<ReturnType<typeof getRecentTagsV2>>, TError = unknown>(
  profileId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentTagsV2>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getRecentTagsV2>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetRecentTagsV2<TData = Awaited<ReturnType<typeof getRecentTagsV2>>, TError = unknown>(
  profileId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentTagsV2>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ìµœê·¼ ì‚¬ìš© íƒœê·¸ ì–»ê¸°v2
 */

export function useGetRecentTagsV2<TData = Awaited<ReturnType<typeof getRecentTagsV2>>, TError = unknown>(
  profileId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentTagsV2>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetRecentTagsV2QueryOptions(profileId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ìƒì„¸ë³´ê¸°ìš© ì¶”ì²œ ìë£Œë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary [ìë£Œ ìƒì„¸ë³´ê¸°] íŒŒì¼ì˜ ìƒì„¸ë³´ê¸°ì—ì„œ ì¶”ì²œ ìë£Œ ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ
 */
export const getSmartFolderItemsRecommendPublicItemList = (
  params: GetSmartFolderItemsRecommendPublicItemListParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/file/v2/public-url-item/recommand-items-for-detailed-info`, method: 'GET', params, signal },
    options,
  );
};

export const getGetSmartFolderItemsRecommendPublicItemListQueryKey = (
  params: GetSmartFolderItemsRecommendPublicItemListParams,
) => {
  return [`/file/v2/public-url-item/recommand-items-for-detailed-info`, ...(params ? [params] : [])] as const;
};

export const getGetSmartFolderItemsRecommendPublicItemListQueryOptions = <
  TData = Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList>>,
  TError = unknown,
>(
  params: GetSmartFolderItemsRecommendPublicItemListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSmartFolderItemsRecommendPublicItemListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList>>> = ({ signal }) =>
    getSmartFolderItemsRecommendPublicItemList(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetSmartFolderItemsRecommendPublicItemListQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList>>
>;
export type GetSmartFolderItemsRecommendPublicItemListQueryError = unknown;

export function useGetSmartFolderItemsRecommendPublicItemList<
  TData = Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList>>,
  TError = unknown,
>(
  params: GetSmartFolderItemsRecommendPublicItemListParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList>>,
          TError,
          TData
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetSmartFolderItemsRecommendPublicItemList<
  TData = Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList>>,
  TError = unknown,
>(
  params: GetSmartFolderItemsRecommendPublicItemListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList>>,
          TError,
          TData
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetSmartFolderItemsRecommendPublicItemList<
  TData = Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList>>,
  TError = unknown,
>(
  params: GetSmartFolderItemsRecommendPublicItemListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary [ìë£Œ ìƒì„¸ë³´ê¸°] íŒŒì¼ì˜ ìƒì„¸ë³´ê¸°ì—ì„œ ì¶”ì²œ ìë£Œ ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ
 */

export function useGetSmartFolderItemsRecommendPublicItemList<
  TData = Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList>>,
  TError = unknown,
>(
  params: GetSmartFolderItemsRecommendPublicItemListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetSmartFolderItemsRecommendPublicItemListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ê³µê°œ ìë£Œ idë¥¼ ì´ìš©í•´ì„œ ìë£Œì˜ ì„¸ë¶€ì •ë³´ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary ê³µê°œëœ íŒŒì¼ì˜ ìƒì„¸ë³´ê¸° êµ¬í˜„ì„ ìœ„í•´ ì¡°íšŒí•˜ëŠ” api
 */
export const getPublicItem = (
  params: GetPublicItemParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponsePublicUrlItemDetailedResult>(
    { url: `/file/v2/public-url-item/detailed-info`, method: 'GET', params, signal },
    options,
  );
};

export const getGetPublicItemQueryKey = (params: GetPublicItemParams) => {
  return [`/file/v2/public-url-item/detailed-info`, ...(params ? [params] : [])] as const;
};

export const getGetPublicItemQueryOptions = <TData = Awaited<ReturnType<typeof getPublicItem>>, TError = unknown>(
  params: GetPublicItemParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicItem>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPublicItemQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPublicItem>>> = ({ signal }) =>
    getPublicItem(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPublicItem>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetPublicItemQueryResult = NonNullable<Awaited<ReturnType<typeof getPublicItem>>>;
export type GetPublicItemQueryError = unknown;

export function useGetPublicItem<TData = Awaited<ReturnType<typeof getPublicItem>>, TError = unknown>(
  params: GetPublicItemParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicItem>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getPublicItem>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetPublicItem<TData = Awaited<ReturnType<typeof getPublicItem>>, TError = unknown>(
  params: GetPublicItemParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicItem>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getPublicItem>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetPublicItem<TData = Awaited<ReturnType<typeof getPublicItem>>, TError = unknown>(
  params: GetPublicItemParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicItem>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ê³µê°œëœ íŒŒì¼ì˜ ìƒì„¸ë³´ê¸° êµ¬í˜„ì„ ìœ„í•´ ì¡°íšŒí•˜ëŠ” api
 */

export function useGetPublicItem<TData = Awaited<ReturnType<typeof getPublicItem>>, TError = unknown>(
  params: GetPublicItemParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicItem>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetPublicItemQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ìë£Œ í‚¤ë¥¼ ì´ìš©í•´ì„œ ëŒ“ê¸€ ê´€ë ¨ ë¦¬ìŠ¤íŠ¸ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary [ìë£Œ ìƒì„¸ë³´ê¸°]íŒŒì¼ì˜ ìƒì„¸ë³´ê¸° êµ¬í˜„ì„ ìœ„í•´ ëŒ“ê¸€ ë¦¬ìŠ¤íŠ¸ì™€ ëŒ“ê¸€ ì²¨ë¶€ìë£Œ ë¦¬ìŠ¤íŠ¸ë¥¼ ì¡°íšŒí•˜ëŠ” api
 */
export const getReplyAndAttachedItemList = (
  params: GetReplyAndAttachedItemListParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseSmartFolderItemReplyResult>(
    { url: `/file/v2/common-smart-folder/replies-for-detailed-info`, method: 'GET', params, signal },
    options,
  );
};

export const getGetReplyAndAttachedItemListQueryKey = (params: GetReplyAndAttachedItemListParams) => {
  return [`/file/v2/common-smart-folder/replies-for-detailed-info`, ...(params ? [params] : [])] as const;
};

export const getGetReplyAndAttachedItemListQueryOptions = <
  TData = Awaited<ReturnType<typeof getReplyAndAttachedItemList>>,
  TError = unknown,
>(
  params: GetReplyAndAttachedItemListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getReplyAndAttachedItemList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetReplyAndAttachedItemListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getReplyAndAttachedItemList>>> = ({ signal }) =>
    getReplyAndAttachedItemList(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getReplyAndAttachedItemList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetReplyAndAttachedItemListQueryResult = NonNullable<
  Awaited<ReturnType<typeof getReplyAndAttachedItemList>>
>;
export type GetReplyAndAttachedItemListQueryError = unknown;

export function useGetReplyAndAttachedItemList<
  TData = Awaited<ReturnType<typeof getReplyAndAttachedItemList>>,
  TError = unknown,
>(
  params: GetReplyAndAttachedItemListParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getReplyAndAttachedItemList>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getReplyAndAttachedItemList>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetReplyAndAttachedItemList<
  TData = Awaited<ReturnType<typeof getReplyAndAttachedItemList>>,
  TError = unknown,
>(
  params: GetReplyAndAttachedItemListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getReplyAndAttachedItemList>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getReplyAndAttachedItemList>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetReplyAndAttachedItemList<
  TData = Awaited<ReturnType<typeof getReplyAndAttachedItemList>>,
  TError = unknown,
>(
  params: GetReplyAndAttachedItemListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getReplyAndAttachedItemList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary [ìë£Œ ìƒì„¸ë³´ê¸°]íŒŒì¼ì˜ ìƒì„¸ë³´ê¸° êµ¬í˜„ì„ ìœ„í•´ ëŒ“ê¸€ ë¦¬ìŠ¤íŠ¸ì™€ ëŒ“ê¸€ ì²¨ë¶€ìë£Œ ë¦¬ìŠ¤íŠ¸ë¥¼ ì¡°íšŒí•˜ëŠ” api
 */

export function useGetReplyAndAttachedItemList<
  TData = Awaited<ReturnType<typeof getReplyAndAttachedItemList>>,
  TError = unknown,
>(
  params: GetReplyAndAttachedItemListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getReplyAndAttachedItemList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetReplyAndAttachedItemListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ìƒì„¸ë³´ê¸°ìš© ì¶”ì²œ ìë£Œë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary [ìë£Œ ìƒì„¸ë³´ê¸°]íŒŒì¼ì˜ ìƒì„¸ë³´ê¸°ì—ì„œ ì¶”ì²œ ìë£Œ ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ
 */
export const getSmartFolderItemsRecommendPublicItemList1 = (
  params: GetSmartFolderItemsRecommendPublicItemList1Params,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/file/v2/common-smart-folder/recommand-items-for-detailed-info`, method: 'GET', params, signal },
    options,
  );
};

export const getGetSmartFolderItemsRecommendPublicItemList1QueryKey = (
  params: GetSmartFolderItemsRecommendPublicItemList1Params,
) => {
  return [`/file/v2/common-smart-folder/recommand-items-for-detailed-info`, ...(params ? [params] : [])] as const;
};

export const getGetSmartFolderItemsRecommendPublicItemList1QueryOptions = <
  TData = Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList1>>,
  TError = unknown,
>(
  params: GetSmartFolderItemsRecommendPublicItemList1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList1>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSmartFolderItemsRecommendPublicItemList1QueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList1>>> = ({
    signal,
  }) => getSmartFolderItemsRecommendPublicItemList1(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetSmartFolderItemsRecommendPublicItemList1QueryResult = NonNullable<
  Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList1>>
>;
export type GetSmartFolderItemsRecommendPublicItemList1QueryError = unknown;

export function useGetSmartFolderItemsRecommendPublicItemList1<
  TData = Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList1>>,
  TError = unknown,
>(
  params: GetSmartFolderItemsRecommendPublicItemList1Params,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList1>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList1>>,
          TError,
          TData
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetSmartFolderItemsRecommendPublicItemList1<
  TData = Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList1>>,
  TError = unknown,
>(
  params: GetSmartFolderItemsRecommendPublicItemList1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList1>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList1>>,
          TError,
          TData
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetSmartFolderItemsRecommendPublicItemList1<
  TData = Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList1>>,
  TError = unknown,
>(
  params: GetSmartFolderItemsRecommendPublicItemList1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList1>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary [ìë£Œ ìƒì„¸ë³´ê¸°]íŒŒì¼ì˜ ìƒì„¸ë³´ê¸°ì—ì„œ ì¶”ì²œ ìë£Œ ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ
 */

export function useGetSmartFolderItemsRecommendPublicItemList1<
  TData = Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList1>>,
  TError = unknown,
>(
  params: GetSmartFolderItemsRecommendPublicItemList1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList1>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetSmartFolderItemsRecommendPublicItemList1QueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ìë£Œë³´ë“œì˜ ìë£Œ idë¥¼ ì´ìš©í•´ì„œ ìë£Œì˜ ì„¸ë¶€ì •ë³´ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary [íŒŒì¼ ìƒì„¸ë³´ê¸°]íŒŒì¼ì˜ ìƒì„¸ë³´ê¸° êµ¬í˜„ì„ ìœ„í•´ ì¡°íšŒí•˜ëŠ” api
 */
export const getSmartFolderItem = (
  params: GetSmartFolderItemParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseSmartFolderItemDetailedResult>(
    { url: `/file/v2/common-smart-folder/detailed-info`, method: 'GET', params, signal },
    options,
  );
};

export const getGetSmartFolderItemQueryKey = (params: GetSmartFolderItemParams) => {
  return [`/file/v2/common-smart-folder/detailed-info`, ...(params ? [params] : [])] as const;
};

export const getGetSmartFolderItemQueryOptions = <
  TData = Awaited<ReturnType<typeof getSmartFolderItem>>,
  TError = unknown,
>(
  params: GetSmartFolderItemParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItem>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSmartFolderItemQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSmartFolderItem>>> = ({ signal }) =>
    getSmartFolderItem(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSmartFolderItem>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetSmartFolderItemQueryResult = NonNullable<Awaited<ReturnType<typeof getSmartFolderItem>>>;
export type GetSmartFolderItemQueryError = unknown;

export function useGetSmartFolderItem<TData = Awaited<ReturnType<typeof getSmartFolderItem>>, TError = unknown>(
  params: GetSmartFolderItemParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItem>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getSmartFolderItem>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetSmartFolderItem<TData = Awaited<ReturnType<typeof getSmartFolderItem>>, TError = unknown>(
  params: GetSmartFolderItemParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItem>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getSmartFolderItem>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetSmartFolderItem<TData = Awaited<ReturnType<typeof getSmartFolderItem>>, TError = unknown>(
  params: GetSmartFolderItemParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItem>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary [íŒŒì¼ ìƒì„¸ë³´ê¸°]íŒŒì¼ì˜ ìƒì„¸ë³´ê¸° êµ¬í˜„ì„ ìœ„í•´ ì¡°íšŒí•˜ëŠ” api
 */

export function useGetSmartFolderItem<TData = Awaited<ReturnType<typeof getSmartFolderItem>>, TError = unknown>(
  params: GetSmartFolderItemParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItem>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetSmartFolderItemQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ì‚¬ìš©ìì˜ íœ´ì§€í†µ ìë£Œëª©ë¡ì„ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary ì‚¬ìš©ìì˜ íœ´ì§€í†µ ì¡°íšŒ
 */
export const findAllPagingReplies = (
  params?: FindAllPagingRepliesParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/file/v1/trashcan/item-list`, method: 'GET', params, signal },
    options,
  );
};

export const getFindAllPagingRepliesQueryKey = (params?: FindAllPagingRepliesParams) => {
  return [`/file/v1/trashcan/item-list`, ...(params ? [params] : [])] as const;
};

export const getFindAllPagingRepliesQueryOptions = <
  TData = Awaited<ReturnType<typeof findAllPagingReplies>>,
  TError = unknown,
>(
  params?: FindAllPagingRepliesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findAllPagingReplies>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFindAllPagingRepliesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findAllPagingReplies>>> = ({ signal }) =>
    findAllPagingReplies(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findAllPagingReplies>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type FindAllPagingRepliesQueryResult = NonNullable<Awaited<ReturnType<typeof findAllPagingReplies>>>;
export type FindAllPagingRepliesQueryError = unknown;

export function useFindAllPagingReplies<TData = Awaited<ReturnType<typeof findAllPagingReplies>>, TError = unknown>(
  params: undefined | FindAllPagingRepliesParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof findAllPagingReplies>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof findAllPagingReplies>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useFindAllPagingReplies<TData = Awaited<ReturnType<typeof findAllPagingReplies>>, TError = unknown>(
  params?: FindAllPagingRepliesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findAllPagingReplies>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof findAllPagingReplies>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useFindAllPagingReplies<TData = Awaited<ReturnType<typeof findAllPagingReplies>>, TError = unknown>(
  params?: FindAllPagingRepliesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findAllPagingReplies>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ì‚¬ìš©ìì˜ íœ´ì§€í†µ ì¡°íšŒ
 */

export function useFindAllPagingReplies<TData = Awaited<ReturnType<typeof findAllPagingReplies>>, TError = unknown>(
  params?: FindAllPagingRepliesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findAllPagingReplies>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getFindAllPagingRepliesQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ì‚¬ìš©ìì˜ í”„ë¡œí•„ idë¡œ ìµœê·¼ ì‘ì—…ì„ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary ìµœê·¼ ì‘ì—… ì¡°íšŒ
 */
export const getRecentTasks = (
  params?: GetRecentTasksParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListRecentTaskResult>(
    { url: `/file/v1/task/recent`, method: 'GET', params, signal },
    options,
  );
};

export const getGetRecentTasksQueryKey = (params?: GetRecentTasksParams) => {
  return [`/file/v1/task/recent`, ...(params ? [params] : [])] as const;
};

export const getGetRecentTasksQueryOptions = <TData = Awaited<ReturnType<typeof getRecentTasks>>, TError = unknown>(
  params?: GetRecentTasksParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentTasks>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRecentTasksQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecentTasks>>> = ({ signal }) =>
    getRecentTasks(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRecentTasks>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetRecentTasksQueryResult = NonNullable<Awaited<ReturnType<typeof getRecentTasks>>>;
export type GetRecentTasksQueryError = unknown;

export function useGetRecentTasks<TData = Awaited<ReturnType<typeof getRecentTasks>>, TError = unknown>(
  params: undefined | GetRecentTasksParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentTasks>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getRecentTasks>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetRecentTasks<TData = Awaited<ReturnType<typeof getRecentTasks>>, TError = unknown>(
  params?: GetRecentTasksParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentTasks>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getRecentTasks>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetRecentTasks<TData = Awaited<ReturnType<typeof getRecentTasks>>, TError = unknown>(
  params?: GetRecentTasksParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentTasks>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ìµœê·¼ ì‘ì—… ì¡°íšŒ
 */

export function useGetRecentTasks<TData = Awaited<ReturnType<typeof getRecentTasks>>, TError = unknown>(
  params?: GetRecentTasksParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentTasks>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetRecentTasksQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ì‚¬ì§„ ì‘ì—…ì˜ idë¡œ ì‘ì—…ì— ì‚¬ìš©ëœ ìë£Œì™€ ì‚°ì¶œë¬¼ ì •ë³´ë¥¼ ì¡°íšŒí•˜ëŠ” api ì…ë‹ˆë‹¤.
 * @summary ì‚¬ì§„ ì‘ì—…ì˜ ì •ë³´ ì¡°íšŒ
 */
export const getImageTask = (
  taskItemId: string,
  params?: GetImageTaskParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseImageTaskLogResult>(
    { url: `/file/v1/task/log/image/${taskItemId}`, method: 'GET', params, signal },
    options,
  );
};

export const getGetImageTaskQueryKey = (taskItemId: string, params?: GetImageTaskParams) => {
  return [`/file/v1/task/log/image/${taskItemId}`, ...(params ? [params] : [])] as const;
};

export const getGetImageTaskQueryOptions = <TData = Awaited<ReturnType<typeof getImageTask>>, TError = unknown>(
  taskItemId: string,
  params?: GetImageTaskParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImageTask>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetImageTaskQueryKey(taskItemId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getImageTask>>> = ({ signal }) =>
    getImageTask(taskItemId, params, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!taskItemId, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getImageTask>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetImageTaskQueryResult = NonNullable<Awaited<ReturnType<typeof getImageTask>>>;
export type GetImageTaskQueryError = unknown;

export function useGetImageTask<TData = Awaited<ReturnType<typeof getImageTask>>, TError = unknown>(
  taskItemId: string,
  params: undefined | GetImageTaskParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImageTask>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getImageTask>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetImageTask<TData = Awaited<ReturnType<typeof getImageTask>>, TError = unknown>(
  taskItemId: string,
  params?: GetImageTaskParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImageTask>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getImageTask>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetImageTask<TData = Awaited<ReturnType<typeof getImageTask>>, TError = unknown>(
  taskItemId: string,
  params?: GetImageTaskParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImageTask>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ì‚¬ì§„ ì‘ì—…ì˜ ì •ë³´ ì¡°íšŒ
 */

export function useGetImageTask<TData = Awaited<ReturnType<typeof getImageTask>>, TError = unknown>(
  taskItemId: string,
  params?: GetImageTaskParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImageTask>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetImageTaskQueryOptions(taskItemId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ë“±ë¡ëœ íƒœê·¸ì¤‘ì— ì‹œì‘í•˜ëŠ” ì…ë ¥í•˜ëŠ” ë‹¨ì–´ë¡œë¶€í„° ì‹œì‘í•˜ëŠ” í‚¤ì›Œë“œ ë“¤ì„ ê²€ìƒ‰í•©ë‹ˆë‹¤.
 * @summary íƒœê·¸ ê²€ìƒ‰(startsWith ê²€ìƒ‰)
 */
export const getTagsStartWith = (
  keyword: string,
  params?: GetTagsStartWithParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListString>(
    { url: `/file/v1/tags/start-with/${keyword}`, method: 'GET', params, signal },
    options,
  );
};

export const getGetTagsStartWithQueryKey = (keyword: string, params?: GetTagsStartWithParams) => {
  return [`/file/v1/tags/start-with/${keyword}`, ...(params ? [params] : [])] as const;
};

export const getGetTagsStartWithQueryOptions = <TData = Awaited<ReturnType<typeof getTagsStartWith>>, TError = unknown>(
  keyword: string,
  params?: GetTagsStartWithParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTagsStartWith>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTagsStartWithQueryKey(keyword, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTagsStartWith>>> = ({ signal }) =>
    getTagsStartWith(keyword, params, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!keyword, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getTagsStartWith>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetTagsStartWithQueryResult = NonNullable<Awaited<ReturnType<typeof getTagsStartWith>>>;
export type GetTagsStartWithQueryError = unknown;

export function useGetTagsStartWith<TData = Awaited<ReturnType<typeof getTagsStartWith>>, TError = unknown>(
  keyword: string,
  params: undefined | GetTagsStartWithParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTagsStartWith>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getTagsStartWith>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetTagsStartWith<TData = Awaited<ReturnType<typeof getTagsStartWith>>, TError = unknown>(
  keyword: string,
  params?: GetTagsStartWithParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTagsStartWith>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getTagsStartWith>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetTagsStartWith<TData = Awaited<ReturnType<typeof getTagsStartWith>>, TError = unknown>(
  keyword: string,
  params?: GetTagsStartWithParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTagsStartWith>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary íƒœê·¸ ê²€ìƒ‰(startsWith ê²€ìƒ‰)
 */

export function useGetTagsStartWith<TData = Awaited<ReturnType<typeof getTagsStartWith>>, TError = unknown>(
  keyword: string,
  params?: GetTagsStartWithParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTagsStartWith>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetTagsStartWithQueryOptions(keyword, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ê´€ì°° ê¸°ë¡ì„ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary ê´€ì°° ê¸°ë¡ ì¡°íšŒ
 */
export const getStudentRecord = (
  studentRecordId: number,
  params?: GetStudentRecordParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseStudentRecordResult>(
    { url: `/file/v1/student-record/${studentRecordId}`, method: 'GET', params, signal },
    options,
  );
};

export const getGetStudentRecordQueryKey = (studentRecordId: number, params?: GetStudentRecordParams) => {
  return [`/file/v1/student-record/${studentRecordId}`, ...(params ? [params] : [])] as const;
};

export const getGetStudentRecordQueryOptions = <TData = Awaited<ReturnType<typeof getStudentRecord>>, TError = unknown>(
  studentRecordId: number,
  params?: GetStudentRecordParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentRecord>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStudentRecordQueryKey(studentRecordId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getStudentRecord>>> = ({ signal }) =>
    getStudentRecord(studentRecordId, params, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!studentRecordId, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getStudentRecord>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetStudentRecordQueryResult = NonNullable<Awaited<ReturnType<typeof getStudentRecord>>>;
export type GetStudentRecordQueryError = unknown;

export function useGetStudentRecord<TData = Awaited<ReturnType<typeof getStudentRecord>>, TError = unknown>(
  studentRecordId: number,
  params: undefined | GetStudentRecordParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentRecord>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getStudentRecord>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetStudentRecord<TData = Awaited<ReturnType<typeof getStudentRecord>>, TError = unknown>(
  studentRecordId: number,
  params?: GetStudentRecordParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentRecord>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getStudentRecord>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetStudentRecord<TData = Awaited<ReturnType<typeof getStudentRecord>>, TError = unknown>(
  studentRecordId: number,
  params?: GetStudentRecordParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentRecord>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ê´€ì°° ê¸°ë¡ ì¡°íšŒ
 */

export function useGetStudentRecord<TData = Awaited<ReturnType<typeof getStudentRecord>>, TError = unknown>(
  studentRecordId: number,
  params?: GetStudentRecordParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentRecord>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetStudentRecordQueryOptions(studentRecordId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ê³¼ì •ë³„ë¡œ ì–´ë–¤ ì˜ì—­ì— ì–´ë–¤ í•­ëª©ë“¤ì„ ë³´ì—¬ì¤„ì§€ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary ê´€ì°°ê·¸ë˜í”„ì—ì„œ ë³´ì—¬ì¤„ í•­ëª©ì„ ì¡°íšŒ
 */
export const getIndicators = (
  params: GetIndicatorsParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListStudentEvaluationIndicatorResult>(
    { url: `/file/v1/student-record/indicators`, method: 'GET', params, signal },
    options,
  );
};

export const getGetIndicatorsQueryKey = (params: GetIndicatorsParams) => {
  return [`/file/v1/student-record/indicators`, ...(params ? [params] : [])] as const;
};

export const getGetIndicatorsQueryOptions = <TData = Awaited<ReturnType<typeof getIndicators>>, TError = unknown>(
  params: GetIndicatorsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIndicators>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetIndicatorsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getIndicators>>> = ({ signal }) =>
    getIndicators(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getIndicators>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetIndicatorsQueryResult = NonNullable<Awaited<ReturnType<typeof getIndicators>>>;
export type GetIndicatorsQueryError = unknown;

export function useGetIndicators<TData = Awaited<ReturnType<typeof getIndicators>>, TError = unknown>(
  params: GetIndicatorsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIndicators>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getIndicators>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetIndicators<TData = Awaited<ReturnType<typeof getIndicators>>, TError = unknown>(
  params: GetIndicatorsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIndicators>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getIndicators>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetIndicators<TData = Awaited<ReturnType<typeof getIndicators>>, TError = unknown>(
  params: GetIndicatorsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIndicators>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ê´€ì°°ê·¸ë˜í”„ì—ì„œ ë³´ì—¬ì¤„ í•­ëª©ì„ ì¡°íšŒ
 */

export function useGetIndicators<TData = Awaited<ReturnType<typeof getIndicators>>, TError = unknown>(
  params: GetIndicatorsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIndicators>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetIndicatorsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ai proxyì—ì„œ ì§€í‘œë¥¼ ì¡°íšŒí•  ë•Œ ì“¸ apiì…ë‹ˆë‹¤.
 * @summary [AI]ì§€í‘œ ì •ë³´ ì¡°íšŒ
 */
export const getIndicator = (code: string, options?: SecondParameter<typeof customFetcher>, signal?: AbortSignal) => {
  return customFetcher<ApiResponseStudentEvaluationIndicatorResult>(
    { url: `/file/v1/student-record/indicator/${code}`, method: 'GET', signal },
    options,
  );
};

export const getGetIndicatorQueryKey = (code: string) => {
  return [`/file/v1/student-record/indicator/${code}`] as const;
};

export const getGetIndicatorQueryOptions = <TData = Awaited<ReturnType<typeof getIndicator>>, TError = unknown>(
  code: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIndicator>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetIndicatorQueryKey(code);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getIndicator>>> = ({ signal }) =>
    getIndicator(code, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!code, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getIndicator>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetIndicatorQueryResult = NonNullable<Awaited<ReturnType<typeof getIndicator>>>;
export type GetIndicatorQueryError = unknown;

export function useGetIndicator<TData = Awaited<ReturnType<typeof getIndicator>>, TError = unknown>(
  code: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIndicator>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getIndicator>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetIndicator<TData = Awaited<ReturnType<typeof getIndicator>>, TError = unknown>(
  code: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIndicator>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getIndicator>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetIndicator<TData = Awaited<ReturnType<typeof getIndicator>>, TError = unknown>(
  code: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIndicator>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary [AI]ì§€í‘œ ì •ë³´ ì¡°íšŒ
 */

export function useGetIndicator<TData = Awaited<ReturnType<typeof getIndicator>>, TError = unknown>(
  code: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIndicator>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetIndicatorQueryOptions(code, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * í•™ìƒì˜ idë¡œ ê´€ì°° ê¸°ë¡ íˆìŠ¤í† ë¦¬ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary ê´€ì°° ê¸°ë¡ íˆìŠ¤í† ë¦¬ ì¡°íšŒ
 */
export const getStudentRecordHistory = (
  studentId: number,
  params?: GetStudentRecordHistoryParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListStudentRecordResult>(
    { url: `/file/v1/student-record/history/${studentId}`, method: 'GET', params, signal },
    options,
  );
};

export const getGetStudentRecordHistoryQueryKey = (studentId: number, params?: GetStudentRecordHistoryParams) => {
  return [`/file/v1/student-record/history/${studentId}`, ...(params ? [params] : [])] as const;
};

export const getGetStudentRecordHistoryQueryOptions = <
  TData = Awaited<ReturnType<typeof getStudentRecordHistory>>,
  TError = unknown,
>(
  studentId: number,
  params?: GetStudentRecordHistoryParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentRecordHistory>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStudentRecordHistoryQueryKey(studentId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getStudentRecordHistory>>> = ({ signal }) =>
    getStudentRecordHistory(studentId, params, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!studentId, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getStudentRecordHistory>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetStudentRecordHistoryQueryResult = NonNullable<Awaited<ReturnType<typeof getStudentRecordHistory>>>;
export type GetStudentRecordHistoryQueryError = unknown;

export function useGetStudentRecordHistory<
  TData = Awaited<ReturnType<typeof getStudentRecordHistory>>,
  TError = unknown,
>(
  studentId: number,
  params: undefined | GetStudentRecordHistoryParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentRecordHistory>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getStudentRecordHistory>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetStudentRecordHistory<
  TData = Awaited<ReturnType<typeof getStudentRecordHistory>>,
  TError = unknown,
>(
  studentId: number,
  params?: GetStudentRecordHistoryParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentRecordHistory>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getStudentRecordHistory>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetStudentRecordHistory<
  TData = Awaited<ReturnType<typeof getStudentRecordHistory>>,
  TError = unknown,
>(
  studentId: number,
  params?: GetStudentRecordHistoryParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentRecordHistory>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ê´€ì°° ê¸°ë¡ íˆìŠ¤í† ë¦¬ ì¡°íšŒ
 */

export function useGetStudentRecordHistory<
  TData = Awaited<ReturnType<typeof getStudentRecordHistory>>,
  TError = unknown,
>(
  studentId: number,
  params?: GetStudentRecordHistoryParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentRecordHistory>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetStudentRecordHistoryQueryOptions(studentId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ê³¼ì •ë³„ë¡œ ì–´ë–¤ ì˜ì—­ë“¤ì„ ë³´ì—¬ì¤„ì§€ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary ê´€ì°°ê·¸ë˜í”„ì—ì„œ ë³´ì—¬ì¤„ ì˜ì—­ì •ë³´ë¥¼ ì¡°íšŒ
 */
export const getDomains = (
  params: GetDomainsParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListStudentEvaluationDomainResult>(
    { url: `/file/v1/student-record/domains`, method: 'GET', params, signal },
    options,
  );
};

export const getGetDomainsQueryKey = (params: GetDomainsParams) => {
  return [`/file/v1/student-record/domains`, ...(params ? [params] : [])] as const;
};

export const getGetDomainsQueryOptions = <TData = Awaited<ReturnType<typeof getDomains>>, TError = unknown>(
  params: GetDomainsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDomains>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDomainsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDomains>>> = ({ signal }) =>
    getDomains(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getDomains>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetDomainsQueryResult = NonNullable<Awaited<ReturnType<typeof getDomains>>>;
export type GetDomainsQueryError = unknown;

export function useGetDomains<TData = Awaited<ReturnType<typeof getDomains>>, TError = unknown>(
  params: GetDomainsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDomains>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getDomains>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetDomains<TData = Awaited<ReturnType<typeof getDomains>>, TError = unknown>(
  params: GetDomainsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDomains>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getDomains>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetDomains<TData = Awaited<ReturnType<typeof getDomains>>, TError = unknown>(
  params: GetDomainsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDomains>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ê´€ì°°ê·¸ë˜í”„ì—ì„œ ë³´ì—¬ì¤„ ì˜ì—­ì •ë³´ë¥¼ ì¡°íšŒ
 */

export function useGetDomains<TData = Awaited<ReturnType<typeof getDomains>>, TError = unknown>(
  params: GetDomainsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDomains>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetDomainsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ìŠ¤í† ë¦¬ë³´ë“œë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary ìŠ¤í† ë¦¬ë³´ë“œ ì¡°íšŒ
 */
export const getStoryBoard = (
  storyBoardId: number,
  params?: GetStoryBoardParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseStoryBoardResult>(
    { url: `/file/v1/story-board/${storyBoardId}`, method: 'GET', params, signal },
    options,
  );
};

export const getGetStoryBoardQueryKey = (storyBoardId: number, params?: GetStoryBoardParams) => {
  return [`/file/v1/story-board/${storyBoardId}`, ...(params ? [params] : [])] as const;
};

export const getGetStoryBoardQueryOptions = <TData = Awaited<ReturnType<typeof getStoryBoard>>, TError = unknown>(
  storyBoardId: number,
  params?: GetStoryBoardParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoryBoard>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStoryBoardQueryKey(storyBoardId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getStoryBoard>>> = ({ signal }) =>
    getStoryBoard(storyBoardId, params, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!storyBoardId, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getStoryBoard>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetStoryBoardQueryResult = NonNullable<Awaited<ReturnType<typeof getStoryBoard>>>;
export type GetStoryBoardQueryError = unknown;

export function useGetStoryBoard<TData = Awaited<ReturnType<typeof getStoryBoard>>, TError = unknown>(
  storyBoardId: number,
  params: undefined | GetStoryBoardParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoryBoard>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getStoryBoard>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetStoryBoard<TData = Awaited<ReturnType<typeof getStoryBoard>>, TError = unknown>(
  storyBoardId: number,
  params?: GetStoryBoardParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoryBoard>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getStoryBoard>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetStoryBoard<TData = Awaited<ReturnType<typeof getStoryBoard>>, TError = unknown>(
  storyBoardId: number,
  params?: GetStoryBoardParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoryBoard>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ìŠ¤í† ë¦¬ë³´ë“œ ì¡°íšŒ
 */

export function useGetStoryBoard<TData = Awaited<ReturnType<typeof getStoryBoard>>, TError = unknown>(
  storyBoardId: number,
  params?: GetStoryBoardParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoryBoard>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetStoryBoardQueryOptions(storyBoardId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ì‚¬ìš©ìì˜ í”„ë¡œí•„ idë¡œ ìŠ¤í† ë¦¬ë³´ë“œ ëª©ë¡ì„ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary ìŠ¤í† ë¦¬ë³´ë“œ ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ
 */
export const getStoryBoardList = (
  params?: GetStoryBoardListParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListStoryBoardResult>(
    { url: `/file/v1/story-board/list`, method: 'GET', params, signal },
    options,
  );
};

export const getGetStoryBoardListQueryKey = (params?: GetStoryBoardListParams) => {
  return [`/file/v1/story-board/list`, ...(params ? [params] : [])] as const;
};

export const getGetStoryBoardListQueryOptions = <
  TData = Awaited<ReturnType<typeof getStoryBoardList>>,
  TError = unknown,
>(
  params?: GetStoryBoardListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoryBoardList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStoryBoardListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getStoryBoardList>>> = ({ signal }) =>
    getStoryBoardList(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getStoryBoardList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetStoryBoardListQueryResult = NonNullable<Awaited<ReturnType<typeof getStoryBoardList>>>;
export type GetStoryBoardListQueryError = unknown;

export function useGetStoryBoardList<TData = Awaited<ReturnType<typeof getStoryBoardList>>, TError = unknown>(
  params: undefined | GetStoryBoardListParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoryBoardList>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getStoryBoardList>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetStoryBoardList<TData = Awaited<ReturnType<typeof getStoryBoardList>>, TError = unknown>(
  params?: GetStoryBoardListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoryBoardList>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getStoryBoardList>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetStoryBoardList<TData = Awaited<ReturnType<typeof getStoryBoardList>>, TError = unknown>(
  params?: GetStoryBoardListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoryBoardList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ìŠ¤í† ë¦¬ë³´ë“œ ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ
 */

export function useGetStoryBoardList<TData = Awaited<ReturnType<typeof getStoryBoardList>>, TError = unknown>(
  params?: GetStoryBoardListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoryBoardList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetStoryBoardListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ì§€ì •í•œ ì‚¬ì§„ ìŠ¤ë§ˆíŠ¸í´ë”ì˜ idë¡œ ìë£Œ ëª©ë¡ì„ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary ì‚¬ì§„ ìŠ¤ë§ˆíŠ¸ í´ë”ì˜ ìë£Œ ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ
 */
export const getIncludedPhotoItems = (
  smartFolderItemId: string,
  params?: GetIncludedPhotoItemsParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/file/v1/smart-folder/photo/${smartFolderItemId}/item-list`, method: 'GET', params, signal },
    options,
  );
};

export const getGetIncludedPhotoItemsQueryKey = (smartFolderItemId: string, params?: GetIncludedPhotoItemsParams) => {
  return [`/file/v1/smart-folder/photo/${smartFolderItemId}/item-list`, ...(params ? [params] : [])] as const;
};

export const getGetIncludedPhotoItemsQueryOptions = <
  TData = Awaited<ReturnType<typeof getIncludedPhotoItems>>,
  TError = unknown,
>(
  smartFolderItemId: string,
  params?: GetIncludedPhotoItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncludedPhotoItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetIncludedPhotoItemsQueryKey(smartFolderItemId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getIncludedPhotoItems>>> = ({ signal }) =>
    getIncludedPhotoItems(smartFolderItemId, params, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!smartFolderItemId, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getIncludedPhotoItems>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetIncludedPhotoItemsQueryResult = NonNullable<Awaited<ReturnType<typeof getIncludedPhotoItems>>>;
export type GetIncludedPhotoItemsQueryError = unknown;

export function useGetIncludedPhotoItems<TData = Awaited<ReturnType<typeof getIncludedPhotoItems>>, TError = unknown>(
  smartFolderItemId: string,
  params: undefined | GetIncludedPhotoItemsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncludedPhotoItems>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getIncludedPhotoItems>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetIncludedPhotoItems<TData = Awaited<ReturnType<typeof getIncludedPhotoItems>>, TError = unknown>(
  smartFolderItemId: string,
  params?: GetIncludedPhotoItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncludedPhotoItems>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getIncludedPhotoItems>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetIncludedPhotoItems<TData = Awaited<ReturnType<typeof getIncludedPhotoItems>>, TError = unknown>(
  smartFolderItemId: string,
  params?: GetIncludedPhotoItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncludedPhotoItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ì‚¬ì§„ ìŠ¤ë§ˆíŠ¸ í´ë”ì˜ ìë£Œ ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ
 */

export function useGetIncludedPhotoItems<TData = Awaited<ReturnType<typeof getIncludedPhotoItems>>, TError = unknown>(
  smartFolderItemId: string,
  params?: GetIncludedPhotoItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncludedPhotoItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetIncludedPhotoItemsQueryOptions(smartFolderItemId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ì‚¬ìš©ìì˜ í”„ë¡œí•„ idì™€ íŠ¹ì • í´ë”ê°€ ìˆë‹¤ë©´ íŠ¹ì •í´ë” idë¡œ í´ë” ëª©ë¡ì„ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary ì•„ì´ ì‚¬ì§„ ë¶„ë¥˜ ëª©ë¡ ë° ì‚¬ìš©ìê°€ ë§Œë“  í´ë” ì¡°íšŒ
 */
export const getStudentFolders = (
  params?: GetStudentFoldersParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/file/v1/smart-folder/photo/student/folder-list`, method: 'GET', params, signal },
    options,
  );
};

export const getGetStudentFoldersQueryKey = (params?: GetStudentFoldersParams) => {
  return [`/file/v1/smart-folder/photo/student/folder-list`, ...(params ? [params] : [])] as const;
};

export const getGetStudentFoldersQueryOptions = <
  TData = Awaited<ReturnType<typeof getStudentFolders>>,
  TError = unknown,
>(
  params?: GetStudentFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStudentFoldersQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getStudentFolders>>> = ({ signal }) =>
    getStudentFolders(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getStudentFolders>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetStudentFoldersQueryResult = NonNullable<Awaited<ReturnType<typeof getStudentFolders>>>;
export type GetStudentFoldersQueryError = unknown;

export function useGetStudentFolders<TData = Awaited<ReturnType<typeof getStudentFolders>>, TError = unknown>(
  params: undefined | GetStudentFoldersParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentFolders>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getStudentFolders>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetStudentFolders<TData = Awaited<ReturnType<typeof getStudentFolders>>, TError = unknown>(
  params?: GetStudentFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentFolders>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getStudentFolders>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetStudentFolders<TData = Awaited<ReturnType<typeof getStudentFolders>>, TError = unknown>(
  params?: GetStudentFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ì•„ì´ ì‚¬ì§„ ë¶„ë¥˜ ëª©ë¡ ë° ì‚¬ìš©ìê°€ ë§Œë“  í´ë” ì¡°íšŒ
 */

export function useGetStudentFolders<TData = Awaited<ReturnType<typeof getStudentFolders>>, TError = unknown>(
  params?: GetStudentFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetStudentFoldersQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ì•„ì´ idë¥¼ ì‚¬ìš©í•˜ì—¬ ì•„ì´ ë¶„ë¥˜ ì‚¬ì§„ í´ë”ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary ì•„ì´ ë¶„ë¥˜ ì‚¬ì§„ í´ë” ì¡°íšŒ
 */
export const getStudentPhotoFolderWithStudentId = (
  params: GetStudentPhotoFolderWithStudentIdParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseSmartFolderItemResult>(
    { url: `/file/v1/smart-folder/photo/student-photo-folder`, method: 'GET', params, signal },
    options,
  );
};

export const getGetStudentPhotoFolderWithStudentIdQueryKey = (params: GetStudentPhotoFolderWithStudentIdParams) => {
  return [`/file/v1/smart-folder/photo/student-photo-folder`, ...(params ? [params] : [])] as const;
};

export const getGetStudentPhotoFolderWithStudentIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getStudentPhotoFolderWithStudentId>>,
  TError = unknown,
>(
  params: GetStudentPhotoFolderWithStudentIdParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentPhotoFolderWithStudentId>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStudentPhotoFolderWithStudentIdQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getStudentPhotoFolderWithStudentId>>> = ({ signal }) =>
    getStudentPhotoFolderWithStudentId(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getStudentPhotoFolderWithStudentId>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetStudentPhotoFolderWithStudentIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getStudentPhotoFolderWithStudentId>>
>;
export type GetStudentPhotoFolderWithStudentIdQueryError = unknown;

export function useGetStudentPhotoFolderWithStudentId<
  TData = Awaited<ReturnType<typeof getStudentPhotoFolderWithStudentId>>,
  TError = unknown,
>(
  params: GetStudentPhotoFolderWithStudentIdParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentPhotoFolderWithStudentId>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getStudentPhotoFolderWithStudentId>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetStudentPhotoFolderWithStudentId<
  TData = Awaited<ReturnType<typeof getStudentPhotoFolderWithStudentId>>,
  TError = unknown,
>(
  params: GetStudentPhotoFolderWithStudentIdParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentPhotoFolderWithStudentId>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getStudentPhotoFolderWithStudentId>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetStudentPhotoFolderWithStudentId<
  TData = Awaited<ReturnType<typeof getStudentPhotoFolderWithStudentId>>,
  TError = unknown,
>(
  params: GetStudentPhotoFolderWithStudentIdParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentPhotoFolderWithStudentId>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ì•„ì´ ë¶„ë¥˜ ì‚¬ì§„ í´ë” ì¡°íšŒ
 */

export function useGetStudentPhotoFolderWithStudentId<
  TData = Awaited<ReturnType<typeof getStudentPhotoFolderWithStudentId>>,
  TError = unknown,
>(
  params: GetStudentPhotoFolderWithStudentIdParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentPhotoFolderWithStudentId>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetStudentPhotoFolderWithStudentIdQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ì‚¬ì§„ ìŠ¤ë§ˆíŠ¸í´ë” í™ˆì—ì„œ ë³´ì—¬ì¤„ ëª©ë¡ì„ ì¡°íšŒí•©ë‹ˆë‹¤. ë¶„ë¥˜ëŠ” rootType ê¸°ì¤€ìœ¼ë¡œ í•˜ì‹œë©´ ë©ë‹ˆë‹¤.
 * @summary ì‚¬ì§„ ìŠ¤ë§ˆíŠ¸í´ë” í™ˆ ëª©ë¡ì—ì„œ í•„ìš”í•œ ëª©ë¡ì„ ì¡°íšŒí•©ë‹ˆë‹¤.
 */
export const getPhotoHomeFolders = (
  params?: GetPhotoHomeFoldersParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderResult>(
    { url: `/file/v1/smart-folder/photo/home-folder-list`, method: 'GET', params, signal },
    options,
  );
};

export const getGetPhotoHomeFoldersQueryKey = (params?: GetPhotoHomeFoldersParams) => {
  return [`/file/v1/smart-folder/photo/home-folder-list`, ...(params ? [params] : [])] as const;
};

export const getGetPhotoHomeFoldersQueryOptions = <
  TData = Awaited<ReturnType<typeof getPhotoHomeFolders>>,
  TError = unknown,
>(
  params?: GetPhotoHomeFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotoHomeFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPhotoHomeFoldersQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPhotoHomeFolders>>> = ({ signal }) =>
    getPhotoHomeFolders(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPhotoHomeFolders>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetPhotoHomeFoldersQueryResult = NonNullable<Awaited<ReturnType<typeof getPhotoHomeFolders>>>;
export type GetPhotoHomeFoldersQueryError = unknown;

export function useGetPhotoHomeFolders<TData = Awaited<ReturnType<typeof getPhotoHomeFolders>>, TError = unknown>(
  params: undefined | GetPhotoHomeFoldersParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotoHomeFolders>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getPhotoHomeFolders>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetPhotoHomeFolders<TData = Awaited<ReturnType<typeof getPhotoHomeFolders>>, TError = unknown>(
  params?: GetPhotoHomeFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotoHomeFolders>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getPhotoHomeFolders>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetPhotoHomeFolders<TData = Awaited<ReturnType<typeof getPhotoHomeFolders>>, TError = unknown>(
  params?: GetPhotoHomeFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotoHomeFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ì‚¬ì§„ ìŠ¤ë§ˆíŠ¸í´ë” í™ˆ ëª©ë¡ì—ì„œ í•„ìš”í•œ ëª©ë¡ì„ ì¡°íšŒí•©ë‹ˆë‹¤.
 */

export function useGetPhotoHomeFolders<TData = Awaited<ReturnType<typeof getPhotoHomeFolders>>, TError = unknown>(
  params?: GetPhotoHomeFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotoHomeFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetPhotoHomeFoldersQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ì‚¬ìš©ìì˜ í”„ë¡œí•„ idë¡œ ì‚¬ì§„ ìŠ¤ë§ˆíŠ¸í´ë”ì˜ í´ë” êµ¬ì¡° ëª©ë¡ì„ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary ì‚¬ì§„ ìŠ¤ë§ˆíŠ¸í´ë”ì˜ í´ë” ëª©ë¡ ì¡°íšŒ
 */
export const getPhotoFolderTree = (
  params?: GetPhotoFolderTreeParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderTreeResult>(
    { url: `/file/v1/smart-folder/photo/folder-tree`, method: 'GET', params, signal },
    options,
  );
};

export const getGetPhotoFolderTreeQueryKey = (params?: GetPhotoFolderTreeParams) => {
  return [`/file/v1/smart-folder/photo/folder-tree`, ...(params ? [params] : [])] as const;
};

export const getGetPhotoFolderTreeQueryOptions = <
  TData = Awaited<ReturnType<typeof getPhotoFolderTree>>,
  TError = unknown,
>(
  params?: GetPhotoFolderTreeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotoFolderTree>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPhotoFolderTreeQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPhotoFolderTree>>> = ({ signal }) =>
    getPhotoFolderTree(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPhotoFolderTree>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetPhotoFolderTreeQueryResult = NonNullable<Awaited<ReturnType<typeof getPhotoFolderTree>>>;
export type GetPhotoFolderTreeQueryError = unknown;

export function useGetPhotoFolderTree<TData = Awaited<ReturnType<typeof getPhotoFolderTree>>, TError = unknown>(
  params: undefined | GetPhotoFolderTreeParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotoFolderTree>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getPhotoFolderTree>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetPhotoFolderTree<TData = Awaited<ReturnType<typeof getPhotoFolderTree>>, TError = unknown>(
  params?: GetPhotoFolderTreeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotoFolderTree>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getPhotoFolderTree>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetPhotoFolderTree<TData = Awaited<ReturnType<typeof getPhotoFolderTree>>, TError = unknown>(
  params?: GetPhotoFolderTreeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotoFolderTree>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ì‚¬ì§„ ìŠ¤ë§ˆíŠ¸í´ë”ì˜ í´ë” ëª©ë¡ ì¡°íšŒ
 */

export function useGetPhotoFolderTree<TData = Awaited<ReturnType<typeof getPhotoFolderTree>>, TError = unknown>(
  params?: GetPhotoFolderTreeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotoFolderTree>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetPhotoFolderTreeQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ì‚¬ìš©ìì˜ í”„ë¡œí•„ idì™€ íŠ¹ì • í´ë”ê°€ ìˆë‹¤ë©´ íŠ¹ì •í´ë” idë¡œ í´ë” ëª©ë¡ì„ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary ì‚¬ì§„ ìŠ¤ë§ˆíŠ¸í´ë” ëª©ë¡ ë° ì‚¬ìš©ìê°€ ë§Œë“  í´ë” ëª©ë¡ ì¡°íšŒ
 */
export const getPhotoFolders = (
  params?: GetPhotoFoldersParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderResult>(
    { url: `/file/v1/smart-folder/photo/folder-list`, method: 'GET', params, signal },
    options,
  );
};

export const getGetPhotoFoldersQueryKey = (params?: GetPhotoFoldersParams) => {
  return [`/file/v1/smart-folder/photo/folder-list`, ...(params ? [params] : [])] as const;
};

export const getGetPhotoFoldersQueryOptions = <TData = Awaited<ReturnType<typeof getPhotoFolders>>, TError = unknown>(
  params?: GetPhotoFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotoFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPhotoFoldersQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPhotoFolders>>> = ({ signal }) =>
    getPhotoFolders(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPhotoFolders>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetPhotoFoldersQueryResult = NonNullable<Awaited<ReturnType<typeof getPhotoFolders>>>;
export type GetPhotoFoldersQueryError = unknown;

export function useGetPhotoFolders<TData = Awaited<ReturnType<typeof getPhotoFolders>>, TError = unknown>(
  params: undefined | GetPhotoFoldersParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotoFolders>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getPhotoFolders>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetPhotoFolders<TData = Awaited<ReturnType<typeof getPhotoFolders>>, TError = unknown>(
  params?: GetPhotoFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotoFolders>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getPhotoFolders>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetPhotoFolders<TData = Awaited<ReturnType<typeof getPhotoFolders>>, TError = unknown>(
  params?: GetPhotoFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotoFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ì‚¬ì§„ ìŠ¤ë§ˆíŠ¸í´ë” ëª©ë¡ ë° ì‚¬ìš©ìê°€ ë§Œë“  í´ë” ëª©ë¡ ì¡°íšŒ
 */

export function useGetPhotoFolders<TData = Awaited<ReturnType<typeof getPhotoFolders>>, TError = unknown>(
  params?: GetPhotoFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotoFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetPhotoFoldersQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ì‚¬ìš©ìì˜ í”„ë¡œí•„ idì™€ íŠ¹ì • í´ë”ê°€ ìˆë‹¤ë©´ íŠ¹ì •í´ë” idë¡œ í´ë” ëª©ë¡ì„ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary í™œë™ ì‚¬ì§„ ë¶„ë¥˜ ëª©ë¡ ë° ì‚¬ìš©ìê°€ ë§Œë“  í´ë” ì¡°íšŒ
 */
export const getActivityFolders = (
  params?: GetActivityFoldersParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/file/v1/smart-folder/photo/activity/folder-list`, method: 'GET', params, signal },
    options,
  );
};

export const getGetActivityFoldersQueryKey = (params?: GetActivityFoldersParams) => {
  return [`/file/v1/smart-folder/photo/activity/folder-list`, ...(params ? [params] : [])] as const;
};

export const getGetActivityFoldersQueryOptions = <
  TData = Awaited<ReturnType<typeof getActivityFolders>>,
  TError = unknown,
>(
  params?: GetActivityFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivityFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetActivityFoldersQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getActivityFolders>>> = ({ signal }) =>
    getActivityFolders(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getActivityFolders>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetActivityFoldersQueryResult = NonNullable<Awaited<ReturnType<typeof getActivityFolders>>>;
export type GetActivityFoldersQueryError = unknown;

export function useGetActivityFolders<TData = Awaited<ReturnType<typeof getActivityFolders>>, TError = unknown>(
  params: undefined | GetActivityFoldersParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivityFolders>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getActivityFolders>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetActivityFolders<TData = Awaited<ReturnType<typeof getActivityFolders>>, TError = unknown>(
  params?: GetActivityFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivityFolders>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getActivityFolders>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetActivityFolders<TData = Awaited<ReturnType<typeof getActivityFolders>>, TError = unknown>(
  params?: GetActivityFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivityFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary í™œë™ ì‚¬ì§„ ë¶„ë¥˜ ëª©ë¡ ë° ì‚¬ìš©ìê°€ ë§Œë“  í´ë” ì¡°íšŒ
 */

export function useGetActivityFolders<TData = Awaited<ReturnType<typeof getActivityFolders>>, TError = unknown>(
  params?: GetActivityFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivityFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetActivityFoldersQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ì‚¬ìš©ìì˜ ì‚¬ì§„ ìŠ¤ë§ˆíŠ¸í´ë”ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary (ë‚´ë¶€ ì‚¬ìš©ìš©)ì‚¬ì§„ ê¸°ëŠ¥ë³„ ë£¨íŠ¸í´ë” ì¡°íšŒ
 */
export const getImageRootFolder = (
  params: GetImageRootFolderParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseSmartFolderItemResult>(
    { url: `/file/v1/smart-folder/photo-folder-with-type`, method: 'GET', params, signal },
    options,
  );
};

export const getGetImageRootFolderQueryKey = (params: GetImageRootFolderParams) => {
  return [`/file/v1/smart-folder/photo-folder-with-type`, ...(params ? [params] : [])] as const;
};

export const getGetImageRootFolderQueryOptions = <
  TData = Awaited<ReturnType<typeof getImageRootFolder>>,
  TError = unknown,
>(
  params: GetImageRootFolderParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImageRootFolder>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetImageRootFolderQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getImageRootFolder>>> = ({ signal }) =>
    getImageRootFolder(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getImageRootFolder>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetImageRootFolderQueryResult = NonNullable<Awaited<ReturnType<typeof getImageRootFolder>>>;
export type GetImageRootFolderQueryError = unknown;

export function useGetImageRootFolder<TData = Awaited<ReturnType<typeof getImageRootFolder>>, TError = unknown>(
  params: GetImageRootFolderParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImageRootFolder>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getImageRootFolder>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetImageRootFolder<TData = Awaited<ReturnType<typeof getImageRootFolder>>, TError = unknown>(
  params: GetImageRootFolderParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImageRootFolder>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getImageRootFolder>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetImageRootFolder<TData = Awaited<ReturnType<typeof getImageRootFolder>>, TError = unknown>(
  params: GetImageRootFolderParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImageRootFolder>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary (ë‚´ë¶€ ì‚¬ìš©ìš©)ì‚¬ì§„ ê¸°ëŠ¥ë³„ ë£¨íŠ¸í´ë” ì¡°íšŒ
 */

export function useGetImageRootFolder<TData = Awaited<ReturnType<typeof getImageRootFolder>>, TError = unknown>(
  params: GetImageRootFolderParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImageRootFolder>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetImageRootFolderQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getMobileUploadedFiles = (
  params?: GetMobileUploadedFilesParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/file/v1/smart-folder/mobile/item-list`, method: 'GET', params, signal },
    options,
  );
};

export const getGetMobileUploadedFilesQueryKey = (params?: GetMobileUploadedFilesParams) => {
  return [`/file/v1/smart-folder/mobile/item-list`, ...(params ? [params] : [])] as const;
};

export const getGetMobileUploadedFilesQueryOptions = <
  TData = Awaited<ReturnType<typeof getMobileUploadedFiles>>,
  TError = unknown,
>(
  params?: GetMobileUploadedFilesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMobileUploadedFiles>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMobileUploadedFilesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMobileUploadedFiles>>> = ({ signal }) =>
    getMobileUploadedFiles(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMobileUploadedFiles>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetMobileUploadedFilesQueryResult = NonNullable<Awaited<ReturnType<typeof getMobileUploadedFiles>>>;
export type GetMobileUploadedFilesQueryError = unknown;

export function useGetMobileUploadedFiles<TData = Awaited<ReturnType<typeof getMobileUploadedFiles>>, TError = unknown>(
  params: undefined | GetMobileUploadedFilesParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMobileUploadedFiles>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getMobileUploadedFiles>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetMobileUploadedFiles<TData = Awaited<ReturnType<typeof getMobileUploadedFiles>>, TError = unknown>(
  params?: GetMobileUploadedFilesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMobileUploadedFiles>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getMobileUploadedFiles>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetMobileUploadedFiles<TData = Awaited<ReturnType<typeof getMobileUploadedFiles>>, TError = unknown>(
  params?: GetMobileUploadedFilesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMobileUploadedFiles>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

export function useGetMobileUploadedFiles<TData = Awaited<ReturnType<typeof getMobileUploadedFiles>>, TError = unknown>(
  params?: GetMobileUploadedFilesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMobileUploadedFiles>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetMobileUploadedFilesQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ì‚¬ìš©ìì˜ ëª¨ë°”ì¼ ì—…ë¡œë“œ ë£¨íŠ¸í´ë”ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary (ë‚´ë¶€ ì‚¬ìš©ìš©)ëª¨ë°”ì¼ ì—…ë¡œë“œ ë£¨íŠ¸í´ë” ì¡°íšŒ
 */
export const getMobileUploadRootFolder = (options?: SecondParameter<typeof customFetcher>, signal?: AbortSignal) => {
  return customFetcher<ApiResponseSmartFolderItemResult>(
    { url: `/file/v1/smart-folder/mobile-upload-folder`, method: 'GET', signal },
    options,
  );
};

export const getGetMobileUploadRootFolderQueryKey = () => {
  return [`/file/v1/smart-folder/mobile-upload-folder`] as const;
};

export const getGetMobileUploadRootFolderQueryOptions = <
  TData = Awaited<ReturnType<typeof getMobileUploadRootFolder>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMobileUploadRootFolder>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMobileUploadRootFolderQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMobileUploadRootFolder>>> = ({ signal }) =>
    getMobileUploadRootFolder(requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMobileUploadRootFolder>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetMobileUploadRootFolderQueryResult = NonNullable<Awaited<ReturnType<typeof getMobileUploadRootFolder>>>;
export type GetMobileUploadRootFolderQueryError = unknown;

export function useGetMobileUploadRootFolder<
  TData = Awaited<ReturnType<typeof getMobileUploadRootFolder>>,
  TError = unknown,
>(options: {
  query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMobileUploadRootFolder>>, TError, TData>> &
    Pick<
      DefinedInitialDataOptions<Awaited<ReturnType<typeof getMobileUploadRootFolder>>, TError, TData>,
      'initialData'
    >;
  request?: SecondParameter<typeof customFetcher>;
}): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetMobileUploadRootFolder<
  TData = Awaited<ReturnType<typeof getMobileUploadRootFolder>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMobileUploadRootFolder>>, TError, TData>> &
    Pick<
      UndefinedInitialDataOptions<Awaited<ReturnType<typeof getMobileUploadRootFolder>>, TError, TData>,
      'initialData'
    >;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetMobileUploadRootFolder<
  TData = Awaited<ReturnType<typeof getMobileUploadRootFolder>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMobileUploadRootFolder>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary (ë‚´ë¶€ ì‚¬ìš©ìš©)ëª¨ë°”ì¼ ì—…ë¡œë“œ ë£¨íŠ¸í´ë” ì¡°íšŒ
 */

export function useGetMobileUploadRootFolder<
  TData = Awaited<ReturnType<typeof getMobileUploadRootFolder>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMobileUploadRootFolder>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetMobileUploadRootFolderQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ì‚¬ìš©ìì˜ í”„ë¡œí•„ idë¡œ ì „ì²´ ìŠ¤ë§ˆíŠ¸í´ë”ì˜ í´ë” êµ¬ì¡° ëª©ë¡ì„ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary ìŠ¤ë§ˆíŠ¸í´ë”ì˜ ì „ì²´ í´ë” ëª©ë¡ ì¡°íšŒ
 */
export const getFolderTreeFromRoot = (options?: SecondParameter<typeof customFetcher>, signal?: AbortSignal) => {
  return customFetcher<ApiResponseListSmartFolderTreeResult>(
    { url: `/file/v1/smart-folder/folder-tree`, method: 'GET', signal },
    options,
  );
};

export const getGetFolderTreeFromRootQueryKey = () => {
  return [`/file/v1/smart-folder/folder-tree`] as const;
};

export const getGetFolderTreeFromRootQueryOptions = <
  TData = Awaited<ReturnType<typeof getFolderTreeFromRoot>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFolderTreeFromRoot>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetFolderTreeFromRootQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFolderTreeFromRoot>>> = ({ signal }) =>
    getFolderTreeFromRoot(requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getFolderTreeFromRoot>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetFolderTreeFromRootQueryResult = NonNullable<Awaited<ReturnType<typeof getFolderTreeFromRoot>>>;
export type GetFolderTreeFromRootQueryError = unknown;

export function useGetFolderTreeFromRoot<
  TData = Awaited<ReturnType<typeof getFolderTreeFromRoot>>,
  TError = unknown,
>(options: {
  query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFolderTreeFromRoot>>, TError, TData>> &
    Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getFolderTreeFromRoot>>, TError, TData>, 'initialData'>;
  request?: SecondParameter<typeof customFetcher>;
}): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetFolderTreeFromRoot<
  TData = Awaited<ReturnType<typeof getFolderTreeFromRoot>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFolderTreeFromRoot>>, TError, TData>> &
    Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getFolderTreeFromRoot>>, TError, TData>, 'initialData'>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetFolderTreeFromRoot<
  TData = Awaited<ReturnType<typeof getFolderTreeFromRoot>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFolderTreeFromRoot>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ìŠ¤ë§ˆíŠ¸í´ë”ì˜ ì „ì²´ í´ë” ëª©ë¡ ì¡°íšŒ
 */

export function useGetFolderTreeFromRoot<
  TData = Awaited<ReturnType<typeof getFolderTreeFromRoot>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFolderTreeFromRoot>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetFolderTreeFromRootQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ì§€ì •í•œ ë¬¸ì„œ ìŠ¤ë§ˆíŠ¸í´ë”ì˜ idë¡œ ìë£Œ ëª©ë¡ì„ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary ë¬¸ì„œ ìŠ¤ë§ˆíŠ¸ í´ë”ì˜ ìë£Œ ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ
 */
export const getIncludedDocsItems = (
  smartFolderItemId: string,
  params?: GetIncludedDocsItemsParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/file/v1/smart-folder/docs/${smartFolderItemId}/item-list`, method: 'GET', params, signal },
    options,
  );
};

export const getGetIncludedDocsItemsQueryKey = (smartFolderItemId: string, params?: GetIncludedDocsItemsParams) => {
  return [`/file/v1/smart-folder/docs/${smartFolderItemId}/item-list`, ...(params ? [params] : [])] as const;
};

export const getGetIncludedDocsItemsQueryOptions = <
  TData = Awaited<ReturnType<typeof getIncludedDocsItems>>,
  TError = unknown,
>(
  smartFolderItemId: string,
  params?: GetIncludedDocsItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncludedDocsItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetIncludedDocsItemsQueryKey(smartFolderItemId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getIncludedDocsItems>>> = ({ signal }) =>
    getIncludedDocsItems(smartFolderItemId, params, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!smartFolderItemId, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getIncludedDocsItems>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetIncludedDocsItemsQueryResult = NonNullable<Awaited<ReturnType<typeof getIncludedDocsItems>>>;
export type GetIncludedDocsItemsQueryError = unknown;

export function useGetIncludedDocsItems<TData = Awaited<ReturnType<typeof getIncludedDocsItems>>, TError = unknown>(
  smartFolderItemId: string,
  params: undefined | GetIncludedDocsItemsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncludedDocsItems>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getIncludedDocsItems>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetIncludedDocsItems<TData = Awaited<ReturnType<typeof getIncludedDocsItems>>, TError = unknown>(
  smartFolderItemId: string,
  params?: GetIncludedDocsItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncludedDocsItems>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getIncludedDocsItems>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetIncludedDocsItems<TData = Awaited<ReturnType<typeof getIncludedDocsItems>>, TError = unknown>(
  smartFolderItemId: string,
  params?: GetIncludedDocsItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncludedDocsItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ë¬¸ì„œ ìŠ¤ë§ˆíŠ¸ í´ë”ì˜ ìë£Œ ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ
 */

export function useGetIncludedDocsItems<TData = Awaited<ReturnType<typeof getIncludedDocsItems>>, TError = unknown>(
  smartFolderItemId: string,
  params?: GetIncludedDocsItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncludedDocsItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetIncludedDocsItemsQueryOptions(smartFolderItemId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ìë£Œë³´ë“œ í™ˆì—ì„œ ìë£Œ ìœ„ì ¯ë“¤ ë³´ì—¬ì¤„ ëª©ë¡ì„ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary ìë£Œë³´ë“œ í™ˆì—ì„œ ìœ„ì ¯ í‘œì‹œì— í•„ìš”í•œ ëª©ë¡ì„ ì¡°íšŒí•©ë‹ˆë‹¤.
 */
export const getWidgetFolders = (
  params?: GetWidgetFoldersParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderResult>(
    { url: `/file/v1/smart-folder/docs/home-widget-list`, method: 'GET', params, signal },
    options,
  );
};

export const getGetWidgetFoldersQueryKey = (params?: GetWidgetFoldersParams) => {
  return [`/file/v1/smart-folder/docs/home-widget-list`, ...(params ? [params] : [])] as const;
};

export const getGetWidgetFoldersQueryOptions = <TData = Awaited<ReturnType<typeof getWidgetFolders>>, TError = unknown>(
  params?: GetWidgetFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWidgetFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetWidgetFoldersQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getWidgetFolders>>> = ({ signal }) =>
    getWidgetFolders(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getWidgetFolders>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetWidgetFoldersQueryResult = NonNullable<Awaited<ReturnType<typeof getWidgetFolders>>>;
export type GetWidgetFoldersQueryError = unknown;

export function useGetWidgetFolders<TData = Awaited<ReturnType<typeof getWidgetFolders>>, TError = unknown>(
  params: undefined | GetWidgetFoldersParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWidgetFolders>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getWidgetFolders>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetWidgetFolders<TData = Awaited<ReturnType<typeof getWidgetFolders>>, TError = unknown>(
  params?: GetWidgetFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWidgetFolders>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getWidgetFolders>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetWidgetFolders<TData = Awaited<ReturnType<typeof getWidgetFolders>>, TError = unknown>(
  params?: GetWidgetFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWidgetFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ìë£Œë³´ë“œ í™ˆì—ì„œ ìœ„ì ¯ í‘œì‹œì— í•„ìš”í•œ ëª©ë¡ì„ ì¡°íšŒí•©ë‹ˆë‹¤.
 */

export function useGetWidgetFolders<TData = Awaited<ReturnType<typeof getWidgetFolders>>, TError = unknown>(
  params?: GetWidgetFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWidgetFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetWidgetFoldersQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ì‚¬ìš©ìì˜ í”„ë¡œí•„ idë¡œ ìë£Œ ìŠ¤ë§ˆíŠ¸í´ë”ì˜ í´ë” êµ¬ì¡° ëª©ë¡ì„ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary ìë£Œ ìŠ¤ë§ˆíŠ¸í´ë”ì˜ í´ë” ëª©ë¡ ì¡°íšŒ
 */
export const getDocsFolderTree = (
  params?: GetDocsFolderTreeParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderTreeResult>(
    { url: `/file/v1/smart-folder/docs/folder-tree`, method: 'GET', params, signal },
    options,
  );
};

export const getGetDocsFolderTreeQueryKey = (params?: GetDocsFolderTreeParams) => {
  return [`/file/v1/smart-folder/docs/folder-tree`, ...(params ? [params] : [])] as const;
};

export const getGetDocsFolderTreeQueryOptions = <
  TData = Awaited<ReturnType<typeof getDocsFolderTree>>,
  TError = unknown,
>(
  params?: GetDocsFolderTreeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocsFolderTree>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDocsFolderTreeQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDocsFolderTree>>> = ({ signal }) =>
    getDocsFolderTree(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getDocsFolderTree>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetDocsFolderTreeQueryResult = NonNullable<Awaited<ReturnType<typeof getDocsFolderTree>>>;
export type GetDocsFolderTreeQueryError = unknown;

export function useGetDocsFolderTree<TData = Awaited<ReturnType<typeof getDocsFolderTree>>, TError = unknown>(
  params: undefined | GetDocsFolderTreeParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocsFolderTree>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getDocsFolderTree>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetDocsFolderTree<TData = Awaited<ReturnType<typeof getDocsFolderTree>>, TError = unknown>(
  params?: GetDocsFolderTreeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocsFolderTree>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getDocsFolderTree>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetDocsFolderTree<TData = Awaited<ReturnType<typeof getDocsFolderTree>>, TError = unknown>(
  params?: GetDocsFolderTreeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocsFolderTree>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ìë£Œ ìŠ¤ë§ˆíŠ¸í´ë”ì˜ í´ë” ëª©ë¡ ì¡°íšŒ
 */

export function useGetDocsFolderTree<TData = Awaited<ReturnType<typeof getDocsFolderTree>>, TError = unknown>(
  params?: GetDocsFolderTreeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocsFolderTree>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetDocsFolderTreeQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ì‚¬ìš©ìì˜ í”„ë¡œí•„ idì™€ íŠ¹ì • í´ë”ê°€ ìˆë‹¤ë©´ íŠ¹ì •í´ë” idë¡œ í´ë” ëª©ë¡ì„ ì¡°íšŒí•©ë‹ˆë‹¤.parentSmartFolderIdë¥¼ ìš”ì²­ì•ˆí•˜ë©´ ìë£Œë³´ë“œì˜ ìœ„ì ¯ ëª©ë¡ì´ ë˜ëŠ” í´ë”ë“¤ì´ ë°˜í™˜ë©ë‹ˆë‹¤.
 * @summary ë¬¸ì„œ ê´€ë ¨ ëª©ë¡ ë° ì‚¬ìš©ìê°€ ë§Œë“  í´ë” ëª©ë¡ ì¡°íšŒ
 */
export const getDocsFolders = (
  params?: GetDocsFoldersParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderResult>(
    { url: `/file/v1/smart-folder/docs/folder-list`, method: 'GET', params, signal },
    options,
  );
};

export const getGetDocsFoldersQueryKey = (params?: GetDocsFoldersParams) => {
  return [`/file/v1/smart-folder/docs/folder-list`, ...(params ? [params] : [])] as const;
};

export const getGetDocsFoldersQueryOptions = <TData = Awaited<ReturnType<typeof getDocsFolders>>, TError = unknown>(
  params?: GetDocsFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocsFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDocsFoldersQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDocsFolders>>> = ({ signal }) =>
    getDocsFolders(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getDocsFolders>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetDocsFoldersQueryResult = NonNullable<Awaited<ReturnType<typeof getDocsFolders>>>;
export type GetDocsFoldersQueryError = unknown;

export function useGetDocsFolders<TData = Awaited<ReturnType<typeof getDocsFolders>>, TError = unknown>(
  params: undefined | GetDocsFoldersParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocsFolders>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getDocsFolders>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetDocsFolders<TData = Awaited<ReturnType<typeof getDocsFolders>>, TError = unknown>(
  params?: GetDocsFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocsFolders>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getDocsFolders>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetDocsFolders<TData = Awaited<ReturnType<typeof getDocsFolders>>, TError = unknown>(
  params?: GetDocsFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocsFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ë¬¸ì„œ ê´€ë ¨ ëª©ë¡ ë° ì‚¬ìš©ìê°€ ë§Œë“  í´ë” ëª©ë¡ ì¡°íšŒ
 */

export function useGetDocsFolders<TData = Awaited<ReturnType<typeof getDocsFolders>>, TError = unknown>(
  params?: GetDocsFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocsFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetDocsFoldersQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ë¹ ë¥¸ ì‘ì—… ai ìª½ì—ì„œ ê¸°ëŠ¥ë³„ ë¸Œë˜ë“œ í¬ëŸ¼ í™•ì¸ìš© api ì…ë‹ˆë‹¤.
 * @summary AI ì´ë¯¸ì§€ ì‘ì—…ì˜ ê¸°ë³¸ í´ë” ê²½ë¡œë¥¼ ì¡°íšŒí•˜ëŠ” api
 */
export const getImageFlatPath = (
  params: GetImageFlatPathParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderTreeResult>(
    { url: `/file/v1/smart-folder/ai-image-task-flat-path`, method: 'GET', params, signal },
    options,
  );
};

export const getGetImageFlatPathQueryKey = (params: GetImageFlatPathParams) => {
  return [`/file/v1/smart-folder/ai-image-task-flat-path`, ...(params ? [params] : [])] as const;
};

export const getGetImageFlatPathQueryOptions = <TData = Awaited<ReturnType<typeof getImageFlatPath>>, TError = unknown>(
  params: GetImageFlatPathParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImageFlatPath>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetImageFlatPathQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getImageFlatPath>>> = ({ signal }) =>
    getImageFlatPath(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getImageFlatPath>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetImageFlatPathQueryResult = NonNullable<Awaited<ReturnType<typeof getImageFlatPath>>>;
export type GetImageFlatPathQueryError = unknown;

export function useGetImageFlatPath<TData = Awaited<ReturnType<typeof getImageFlatPath>>, TError = unknown>(
  params: GetImageFlatPathParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImageFlatPath>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getImageFlatPath>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetImageFlatPath<TData = Awaited<ReturnType<typeof getImageFlatPath>>, TError = unknown>(
  params: GetImageFlatPathParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImageFlatPath>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getImageFlatPath>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetImageFlatPath<TData = Awaited<ReturnType<typeof getImageFlatPath>>, TError = unknown>(
  params: GetImageFlatPathParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImageFlatPath>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary AI ì´ë¯¸ì§€ ì‘ì—…ì˜ ê¸°ë³¸ í´ë” ê²½ë¡œë¥¼ ì¡°íšŒí•˜ëŠ” api
 */

export function useGetImageFlatPath<TData = Awaited<ReturnType<typeof getImageFlatPath>>, TError = unknown>(
  params: GetImageFlatPathParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImageFlatPath>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetImageFlatPathQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ì‹œìŠ¤í…œì—ì„œ ì„¤ì •í•œ ì¶”ì²œí‚¤ì›Œë“œë‚˜ ê¸°ê°„ë³„ ìƒíƒœì— ë”°ë¼ì„œ ê³µê°œëœ ìë£Œì¤‘ì—ì„œ ì¶”ì²œí•  ìë£Œë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary (ë†€ì´ ê³„íš ì‘ì„±)í•˜ë‹¨ ë‚´ ìë£Œ ì¶”ì²œ ì¡°íšŒ.
 */
export const getRecommendPlansFromMyItems = (
  params?: GetRecommendPlansFromMyItemsParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/file/v1/recommendation/task/lecure-plan/user-items`, method: 'GET', params, signal },
    options,
  );
};

export const getGetRecommendPlansFromMyItemsQueryKey = (params?: GetRecommendPlansFromMyItemsParams) => {
  return [`/file/v1/recommendation/task/lecure-plan/user-items`, ...(params ? [params] : [])] as const;
};

export const getGetRecommendPlansFromMyItemsQueryOptions = <
  TData = Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>,
  TError = unknown,
>(
  params?: GetRecommendPlansFromMyItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRecommendPlansFromMyItemsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>> = ({ signal }) =>
    getRecommendPlansFromMyItems(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetRecommendPlansFromMyItemsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>
>;
export type GetRecommendPlansFromMyItemsQueryError = unknown;

export function useGetRecommendPlansFromMyItems<
  TData = Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>,
  TError = unknown,
>(
  params: undefined | GetRecommendPlansFromMyItemsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetRecommendPlansFromMyItems<
  TData = Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>,
  TError = unknown,
>(
  params?: GetRecommendPlansFromMyItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetRecommendPlansFromMyItems<
  TData = Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>,
  TError = unknown,
>(
  params?: GetRecommendPlansFromMyItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary (ë†€ì´ ê³„íš ì‘ì„±)í•˜ë‹¨ ë‚´ ìë£Œ ì¶”ì²œ ì¡°íšŒ.
 */

export function useGetRecommendPlansFromMyItems<
  TData = Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>,
  TError = unknown,
>(
  params?: GetRecommendPlansFromMyItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetRecommendPlansFromMyItemsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ì‹œìŠ¤í…œì—ì„œ ì„¤ì •í•œ ì¶”ì²œí‚¤ì›Œë“œë‚˜ ê¸°ê°„ë³„ ìƒíƒœì— ë”°ë¼ì„œ ê³µê°œëœ ìë£Œì¤‘ì—ì„œ ì¶”ì²œí•  ìë£Œë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary (ë†€ì´ ê³„íš ì‘ì„±)í•˜ë‹¨ ê³µê°œ ìë£Œ ì¶”ì²œ ì¡°íšŒ.
 */
export const getRecommendPlansFromPublicItems = (
  params?: GetRecommendPlansFromPublicItemsParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/file/v1/recommendation/task/lecure-plan/public-items`, method: 'GET', params, signal },
    options,
  );
};

export const getGetRecommendPlansFromPublicItemsQueryKey = (params?: GetRecommendPlansFromPublicItemsParams) => {
  return [`/file/v1/recommendation/task/lecure-plan/public-items`, ...(params ? [params] : [])] as const;
};

export const getGetRecommendPlansFromPublicItemsQueryOptions = <
  TData = Awaited<ReturnType<typeof getRecommendPlansFromPublicItems>>,
  TError = unknown,
>(
  params?: GetRecommendPlansFromPublicItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendPlansFromPublicItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRecommendPlansFromPublicItemsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecommendPlansFromPublicItems>>> = ({ signal }) =>
    getRecommendPlansFromPublicItems(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRecommendPlansFromPublicItems>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetRecommendPlansFromPublicItemsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRecommendPlansFromPublicItems>>
>;
export type GetRecommendPlansFromPublicItemsQueryError = unknown;

export function useGetRecommendPlansFromPublicItems<
  TData = Awaited<ReturnType<typeof getRecommendPlansFromPublicItems>>,
  TError = unknown,
>(
  params: undefined | GetRecommendPlansFromPublicItemsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendPlansFromPublicItems>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getRecommendPlansFromPublicItems>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetRecommendPlansFromPublicItems<
  TData = Awaited<ReturnType<typeof getRecommendPlansFromPublicItems>>,
  TError = unknown,
>(
  params?: GetRecommendPlansFromPublicItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendPlansFromPublicItems>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getRecommendPlansFromPublicItems>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetRecommendPlansFromPublicItems<
  TData = Awaited<ReturnType<typeof getRecommendPlansFromPublicItems>>,
  TError = unknown,
>(
  params?: GetRecommendPlansFromPublicItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendPlansFromPublicItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary (ë†€ì´ ê³„íš ì‘ì„±)í•˜ë‹¨ ê³µê°œ ìë£Œ ì¶”ì²œ ì¡°íšŒ.
 */

export function useGetRecommendPlansFromPublicItems<
  TData = Awaited<ReturnType<typeof getRecommendPlansFromPublicItems>>,
  TError = unknown,
>(
  params?: GetRecommendPlansFromPublicItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendPlansFromPublicItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetRecommendPlansFromPublicItemsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ì‹œìŠ¤í…œì—ì„œ ì„¤ì •í•œ ì¶”ì²œí‚¤ì›Œë“œë‚˜ ê¸°ê°„ë³„ ìƒíƒœì— ë”°ë¼ì„œ ê³µê°œëœ ìë£Œì¤‘ì—ì„œ ì¶”ì²œí•  ë†€ì´ì¹´ë“œë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary (ë†€ì´ ê³„íš ì‘ì„±)ì¶”ì²œ ë†€ì´ ì¹´ë“œ ì¡°íšŒ.
 */
export const getRecommendPlans = (
  params?: GetRecommendPlansParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/file/v1/recommendation/task/lecure-plan/plans`, method: 'GET', params, signal },
    options,
  );
};

export const getGetRecommendPlansQueryKey = (params?: GetRecommendPlansParams) => {
  return [`/file/v1/recommendation/task/lecure-plan/plans`, ...(params ? [params] : [])] as const;
};

export const getGetRecommendPlansQueryOptions = <
  TData = Awaited<ReturnType<typeof getRecommendPlans>>,
  TError = unknown,
>(
  params?: GetRecommendPlansParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendPlans>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRecommendPlansQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecommendPlans>>> = ({ signal }) =>
    getRecommendPlans(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRecommendPlans>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetRecommendPlansQueryResult = NonNullable<Awaited<ReturnType<typeof getRecommendPlans>>>;
export type GetRecommendPlansQueryError = unknown;

export function useGetRecommendPlans<TData = Awaited<ReturnType<typeof getRecommendPlans>>, TError = unknown>(
  params: undefined | GetRecommendPlansParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendPlans>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getRecommendPlans>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetRecommendPlans<TData = Awaited<ReturnType<typeof getRecommendPlans>>, TError = unknown>(
  params?: GetRecommendPlansParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendPlans>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getRecommendPlans>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetRecommendPlans<TData = Awaited<ReturnType<typeof getRecommendPlans>>, TError = unknown>(
  params?: GetRecommendPlansParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendPlans>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary (ë†€ì´ ê³„íš ì‘ì„±)ì¶”ì²œ ë†€ì´ ì¹´ë“œ ì¡°íšŒ.
 */

export function useGetRecommendPlans<TData = Awaited<ReturnType<typeof getRecommendPlans>>, TError = unknown>(
  params?: GetRecommendPlansParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendPlans>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetRecommendPlansQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ê¸°ëŠ¥ë³„ë¡œ ì¶”ì²œ ìë£Œë¥¼ ì¡°íšŒ í•©ë‹ˆë‹¤.(ë³¸ì¸ ìë£Œ ê¸°ì¤€)
 * @summary [TEST] ê³µìš© ì¶”ì²œìë£Œ ëª©ë¡ ì¡°íšŒ. (LNB)
 */
export const getRecommendItems = (
  params?: GetRecommendItemsParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/file/v1/recommendation/task/common-list`, method: 'GET', params, signal },
    options,
  );
};

export const getGetRecommendItemsQueryKey = (params?: GetRecommendItemsParams) => {
  return [`/file/v1/recommendation/task/common-list`, ...(params ? [params] : [])] as const;
};

export const getGetRecommendItemsQueryOptions = <
  TData = Awaited<ReturnType<typeof getRecommendItems>>,
  TError = unknown,
>(
  params?: GetRecommendItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRecommendItemsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecommendItems>>> = ({ signal }) =>
    getRecommendItems(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRecommendItems>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetRecommendItemsQueryResult = NonNullable<Awaited<ReturnType<typeof getRecommendItems>>>;
export type GetRecommendItemsQueryError = unknown;

export function useGetRecommendItems<TData = Awaited<ReturnType<typeof getRecommendItems>>, TError = unknown>(
  params: undefined | GetRecommendItemsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendItems>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getRecommendItems>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetRecommendItems<TData = Awaited<ReturnType<typeof getRecommendItems>>, TError = unknown>(
  params?: GetRecommendItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendItems>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getRecommendItems>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetRecommendItems<TData = Awaited<ReturnType<typeof getRecommendItems>>, TError = unknown>(
  params?: GetRecommendItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary [TEST] ê³µìš© ì¶”ì²œìë£Œ ëª©ë¡ ì¡°íšŒ. (LNB)
 */

export function useGetRecommendItems<TData = Awaited<ReturnType<typeof getRecommendItems>>, TError = unknown>(
  params?: GetRecommendItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetRecommendItemsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ìë£Œë³´ë“œ ë©”ì¸í™”ë©´ í•˜ë‹¨ì˜ ê³µê°œìë£Œë¥¼ ì¡°íšŒí•˜ëŠ” api ì…ë‹ˆë‹¤.
 * @summary ë‹¤ë¥¸ì‚¬ëŒì˜ ê³µê°œëœ ìë£Œ ë¦¬ìŠ¤íŠ¸ë¥¼ ì¡°íšŒí•˜ëŠ” api
 */
export const getPublicItemForMain = (
  params?: GetPublicItemForMainParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/file/v1/recommendation/public-item-list`, method: 'GET', params, signal },
    options,
  );
};

export const getGetPublicItemForMainQueryKey = (params?: GetPublicItemForMainParams) => {
  return [`/file/v1/recommendation/public-item-list`, ...(params ? [params] : [])] as const;
};

export const getGetPublicItemForMainQueryOptions = <
  TData = Awaited<ReturnType<typeof getPublicItemForMain>>,
  TError = unknown,
>(
  params?: GetPublicItemForMainParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicItemForMain>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPublicItemForMainQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPublicItemForMain>>> = ({ signal }) =>
    getPublicItemForMain(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPublicItemForMain>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetPublicItemForMainQueryResult = NonNullable<Awaited<ReturnType<typeof getPublicItemForMain>>>;
export type GetPublicItemForMainQueryError = unknown;

export function useGetPublicItemForMain<TData = Awaited<ReturnType<typeof getPublicItemForMain>>, TError = unknown>(
  params: undefined | GetPublicItemForMainParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicItemForMain>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getPublicItemForMain>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetPublicItemForMain<TData = Awaited<ReturnType<typeof getPublicItemForMain>>, TError = unknown>(
  params?: GetPublicItemForMainParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicItemForMain>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getPublicItemForMain>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetPublicItemForMain<TData = Awaited<ReturnType<typeof getPublicItemForMain>>, TError = unknown>(
  params?: GetPublicItemForMainParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicItemForMain>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ë‹¤ë¥¸ì‚¬ëŒì˜ ê³µê°œëœ ìë£Œ ë¦¬ìŠ¤íŠ¸ë¥¼ ì¡°íšŒí•˜ëŠ” api
 */

export function useGetPublicItemForMain<TData = Awaited<ReturnType<typeof getPublicItemForMain>>, TError = unknown>(
  params?: GetPublicItemForMainParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicItemForMain>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetPublicItemForMainQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ë‚ ì§œ ê¸°ì¤€ìœ¼ë¡œ ì¶”ì²œ í‚¤ì›Œë“œê°€ ì„¤ì •ëœ ì •ë³´ ëª©ë¡ì„ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary ì¶”ì²œ í‚¤ì›Œë“œ ê´€ë ¨ ì–»ê¸°
 */
export const getRecommendationKeywordInfo = (
  params?: GetRecommendationKeywordInfoParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListRecommendationKeywordBundleResult>(
    { url: `/file/v1/recommendation/common-keywords/info`, method: 'GET', params, signal },
    options,
  );
};

export const getGetRecommendationKeywordInfoQueryKey = (params?: GetRecommendationKeywordInfoParams) => {
  return [`/file/v1/recommendation/common-keywords/info`, ...(params ? [params] : [])] as const;
};

export const getGetRecommendationKeywordInfoQueryOptions = <
  TData = Awaited<ReturnType<typeof getRecommendationKeywordInfo>>,
  TError = unknown,
>(
  params?: GetRecommendationKeywordInfoParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendationKeywordInfo>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRecommendationKeywordInfoQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecommendationKeywordInfo>>> = ({ signal }) =>
    getRecommendationKeywordInfo(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRecommendationKeywordInfo>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetRecommendationKeywordInfoQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRecommendationKeywordInfo>>
>;
export type GetRecommendationKeywordInfoQueryError = unknown;

export function useGetRecommendationKeywordInfo<
  TData = Awaited<ReturnType<typeof getRecommendationKeywordInfo>>,
  TError = unknown,
>(
  params: undefined | GetRecommendationKeywordInfoParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendationKeywordInfo>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getRecommendationKeywordInfo>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetRecommendationKeywordInfo<
  TData = Awaited<ReturnType<typeof getRecommendationKeywordInfo>>,
  TError = unknown,
>(
  params?: GetRecommendationKeywordInfoParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendationKeywordInfo>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getRecommendationKeywordInfo>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetRecommendationKeywordInfo<
  TData = Awaited<ReturnType<typeof getRecommendationKeywordInfo>>,
  TError = unknown,
>(
  params?: GetRecommendationKeywordInfoParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendationKeywordInfo>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ì¶”ì²œ í‚¤ì›Œë“œ ê´€ë ¨ ì–»ê¸°
 */

export function useGetRecommendationKeywordInfo<
  TData = Awaited<ReturnType<typeof getRecommendationKeywordInfo>>,
  TError = unknown,
>(
  params?: GetRecommendationKeywordInfoParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendationKeywordInfo>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetRecommendationKeywordInfoQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ì‚¬ìš©ì í”„ë¡œí•„ idë¡œ ìµœê·¼ì— íƒœê·¸ë¡œ ë“±ë¡í•œ í‚¤ì›Œë“œë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤. (ì—†ìœ¼ë©´ 404 ì‘ë‹µ)
 * @summary ìµœê·¼ ì‚¬ìš© íƒœê·¸ ì–»ê¸°
 */
export const getRecentTags = (
  profileId: string,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListString>(
    { url: `/file/v1/recent-tags/${profileId}`, method: 'GET', signal },
    options,
  );
};

export const getGetRecentTagsQueryKey = (profileId: string) => {
  return [`/file/v1/recent-tags/${profileId}`] as const;
};

export const getGetRecentTagsQueryOptions = <TData = Awaited<ReturnType<typeof getRecentTags>>, TError = unknown>(
  profileId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentTags>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRecentTagsQueryKey(profileId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecentTags>>> = ({ signal }) =>
    getRecentTags(profileId, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRecentTags>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetRecentTagsQueryResult = NonNullable<Awaited<ReturnType<typeof getRecentTags>>>;
export type GetRecentTagsQueryError = unknown;

export function useGetRecentTags<TData = Awaited<ReturnType<typeof getRecentTags>>, TError = unknown>(
  profileId: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentTags>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getRecentTags>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetRecentTags<TData = Awaited<ReturnType<typeof getRecentTags>>, TError = unknown>(
  profileId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentTags>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getRecentTags>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetRecentTags<TData = Awaited<ReturnType<typeof getRecentTags>>, TError = unknown>(
  profileId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentTags>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ìµœê·¼ ì‚¬ìš© íƒœê·¸ ì–»ê¸°
 */

export function useGetRecentTags<TData = Awaited<ReturnType<typeof getRecentTags>>, TError = unknown>(
  profileId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentTags>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetRecentTagsQueryOptions(profileId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ê³µê°œ ìë£Œ idë¥¼ ì´ìš©í•´ì„œ ìë£Œì˜ ì„¸ë¶€ì •ë³´ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary ê³µê°œëœ íŒŒì¼ì˜ ìƒì„¸ë³´ê¸° êµ¬í˜„ì„ ìœ„í•´ ì¡°íšŒí•˜ëŠ” api
 */
export const getPublicItem1 = (
  params: GetPublicItem1Params,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponsePublicUrlItemDetailedResult>(
    { url: `/file/v1/public-url-item/detailed-info`, method: 'GET', params, signal },
    options,
  );
};

export const getGetPublicItem1QueryKey = (params: GetPublicItem1Params) => {
  return [`/file/v1/public-url-item/detailed-info`, ...(params ? [params] : [])] as const;
};

export const getGetPublicItem1QueryOptions = <TData = Awaited<ReturnType<typeof getPublicItem1>>, TError = unknown>(
  params: GetPublicItem1Params,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicItem1>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPublicItem1QueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPublicItem1>>> = ({ signal }) =>
    getPublicItem1(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPublicItem1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetPublicItem1QueryResult = NonNullable<Awaited<ReturnType<typeof getPublicItem1>>>;
export type GetPublicItem1QueryError = unknown;

export function useGetPublicItem1<TData = Awaited<ReturnType<typeof getPublicItem1>>, TError = unknown>(
  params: GetPublicItem1Params,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicItem1>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getPublicItem1>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetPublicItem1<TData = Awaited<ReturnType<typeof getPublicItem1>>, TError = unknown>(
  params: GetPublicItem1Params,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicItem1>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getPublicItem1>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetPublicItem1<TData = Awaited<ReturnType<typeof getPublicItem1>>, TError = unknown>(
  params: GetPublicItem1Params,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicItem1>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ê³µê°œëœ íŒŒì¼ì˜ ìƒì„¸ë³´ê¸° êµ¬í˜„ì„ ìœ„í•´ ì¡°íšŒí•˜ëŠ” api
 */

export function useGetPublicItem1<TData = Awaited<ReturnType<typeof getPublicItem1>>, TError = unknown>(
  params: GetPublicItem1Params,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicItem1>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetPublicItem1QueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ì§€ì •í•œ ë‚´í´ë”ì˜ idë¡œ ìë£Œ ëª©ë¡ì„ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary ë‚´ í´ë”ì˜ ìë£Œ ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ
 */
export const getIncludedItems = (
  smartFolderItemid: string,
  params?: GetIncludedItemsParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/file/v1/my-folder/${smartFolderItemid}/item-list`, method: 'GET', params, signal },
    options,
  );
};

export const getGetIncludedItemsQueryKey = (smartFolderItemid: string, params?: GetIncludedItemsParams) => {
  return [`/file/v1/my-folder/${smartFolderItemid}/item-list`, ...(params ? [params] : [])] as const;
};

export const getGetIncludedItemsQueryOptions = <TData = Awaited<ReturnType<typeof getIncludedItems>>, TError = unknown>(
  smartFolderItemid: string,
  params?: GetIncludedItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncludedItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetIncludedItemsQueryKey(smartFolderItemid, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getIncludedItems>>> = ({ signal }) =>
    getIncludedItems(smartFolderItemid, params, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!smartFolderItemid, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getIncludedItems>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetIncludedItemsQueryResult = NonNullable<Awaited<ReturnType<typeof getIncludedItems>>>;
export type GetIncludedItemsQueryError = unknown;

export function useGetIncludedItems<TData = Awaited<ReturnType<typeof getIncludedItems>>, TError = unknown>(
  smartFolderItemid: string,
  params: undefined | GetIncludedItemsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncludedItems>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getIncludedItems>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetIncludedItems<TData = Awaited<ReturnType<typeof getIncludedItems>>, TError = unknown>(
  smartFolderItemid: string,
  params?: GetIncludedItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncludedItems>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getIncludedItems>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetIncludedItems<TData = Awaited<ReturnType<typeof getIncludedItems>>, TError = unknown>(
  smartFolderItemid: string,
  params?: GetIncludedItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncludedItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ë‚´ í´ë”ì˜ ìë£Œ ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ
 */

export function useGetIncludedItems<TData = Awaited<ReturnType<typeof getIncludedItems>>, TError = unknown>(
  smartFolderItemid: string,
  params?: GetIncludedItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncludedItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetIncludedItemsQueryOptions(smartFolderItemid, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ì‚¬ìš©ìì˜ í”„ë¡œí•„ idë¡œ ë‚´ í´ë” ëª©ë¡ì„ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary ì‚¬ìš©ìì˜ ë‚´ í´ë” ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ
 */
export const getMyFoldersDeprecate = (
  params?: GetMyFoldersDeprecateParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderResult>(
    { url: `/file/v1/my-folder/list`, method: 'GET', params, signal },
    options,
  );
};

export const getGetMyFoldersDeprecateQueryKey = (params?: GetMyFoldersDeprecateParams) => {
  return [`/file/v1/my-folder/list`, ...(params ? [params] : [])] as const;
};

export const getGetMyFoldersDeprecateQueryOptions = <
  TData = Awaited<ReturnType<typeof getMyFoldersDeprecate>>,
  TError = unknown,
>(
  params?: GetMyFoldersDeprecateParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyFoldersDeprecate>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMyFoldersDeprecateQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyFoldersDeprecate>>> = ({ signal }) =>
    getMyFoldersDeprecate(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMyFoldersDeprecate>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetMyFoldersDeprecateQueryResult = NonNullable<Awaited<ReturnType<typeof getMyFoldersDeprecate>>>;
export type GetMyFoldersDeprecateQueryError = unknown;

export function useGetMyFoldersDeprecate<TData = Awaited<ReturnType<typeof getMyFoldersDeprecate>>, TError = unknown>(
  params: undefined | GetMyFoldersDeprecateParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyFoldersDeprecate>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getMyFoldersDeprecate>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetMyFoldersDeprecate<TData = Awaited<ReturnType<typeof getMyFoldersDeprecate>>, TError = unknown>(
  params?: GetMyFoldersDeprecateParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyFoldersDeprecate>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getMyFoldersDeprecate>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetMyFoldersDeprecate<TData = Awaited<ReturnType<typeof getMyFoldersDeprecate>>, TError = unknown>(
  params?: GetMyFoldersDeprecateParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyFoldersDeprecate>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ì‚¬ìš©ìì˜ ë‚´ í´ë” ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ
 */

export function useGetMyFoldersDeprecate<TData = Awaited<ReturnType<typeof getMyFoldersDeprecate>>, TError = unknown>(
  params?: GetMyFoldersDeprecateParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyFoldersDeprecate>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetMyFoldersDeprecateQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ì‚¬ìš©ìì˜ í”„ë¡œí•„ idë¡œ ëª¨ë°”ì¼ ì—…ë¡œë“œ í´ë”ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary (ë‚´ë¶€ìš©)ë‚´ í´ë”ì˜ ëª¨ë°”ì¼ ì—…ë¡œë“œ í´ë” ì¡°íšŒ
 */
export const getMyMobileUploadFolder = (options?: SecondParameter<typeof customFetcher>, signal?: AbortSignal) => {
  return customFetcher<ApiResponseSmartFolderResult>(
    { url: `/file/v1/my-folder/internal/mobile-upload-folder`, method: 'GET', signal },
    options,
  );
};

export const getGetMyMobileUploadFolderQueryKey = () => {
  return [`/file/v1/my-folder/internal/mobile-upload-folder`] as const;
};

export const getGetMyMobileUploadFolderQueryOptions = <
  TData = Awaited<ReturnType<typeof getMyMobileUploadFolder>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyMobileUploadFolder>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMyMobileUploadFolderQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyMobileUploadFolder>>> = ({ signal }) =>
    getMyMobileUploadFolder(requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMyMobileUploadFolder>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetMyMobileUploadFolderQueryResult = NonNullable<Awaited<ReturnType<typeof getMyMobileUploadFolder>>>;
export type GetMyMobileUploadFolderQueryError = unknown;

export function useGetMyMobileUploadFolder<
  TData = Awaited<ReturnType<typeof getMyMobileUploadFolder>>,
  TError = unknown,
>(options: {
  query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyMobileUploadFolder>>, TError, TData>> &
    Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getMyMobileUploadFolder>>, TError, TData>, 'initialData'>;
  request?: SecondParameter<typeof customFetcher>;
}): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetMyMobileUploadFolder<
  TData = Awaited<ReturnType<typeof getMyMobileUploadFolder>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyMobileUploadFolder>>, TError, TData>> &
    Pick<
      UndefinedInitialDataOptions<Awaited<ReturnType<typeof getMyMobileUploadFolder>>, TError, TData>,
      'initialData'
    >;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetMyMobileUploadFolder<
  TData = Awaited<ReturnType<typeof getMyMobileUploadFolder>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyMobileUploadFolder>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary (ë‚´ë¶€ìš©)ë‚´ í´ë”ì˜ ëª¨ë°”ì¼ ì—…ë¡œë“œ í´ë” ì¡°íšŒ
 */

export function useGetMyMobileUploadFolder<
  TData = Awaited<ReturnType<typeof getMyMobileUploadFolder>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyMobileUploadFolder>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetMyMobileUploadFolderQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ì‚¬ìš©ìì˜ í”„ë¡œí•„ idë¡œ ë‚´ í´ë” ëª©ë¡ì„ ì¡°íšŒí•©ë‹ˆë‹¤.(ìë£Œë³´ë“œ ë©”ì¸í™”ë©´, ì—…ë¡œë“œì°½ì—ì„œ ë‚´ í´ë” íƒ­ ë“±ì—ì„œ ì‚¬ìš©í•˜ì‹œë©´ ë  ê²ƒìœ¼ë¡œ ì˜ˆìƒë©ë‹ˆë‹¤.)
 * @summary ì‚¬ìš©ìì˜ í™ˆì—ì„œ ë³´ì—¬ì¤„ ë‚´ í´ë” ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ
 */
export const getMyFolders = (options?: SecondParameter<typeof customFetcher>, signal?: AbortSignal) => {
  return customFetcher<ApiResponseListSmartFolderResult>(
    { url: `/file/v1/my-folder/home-folder-list`, method: 'GET', signal },
    options,
  );
};

export const getGetMyFoldersQueryKey = () => {
  return [`/file/v1/my-folder/home-folder-list`] as const;
};

export const getGetMyFoldersQueryOptions = <
  TData = Awaited<ReturnType<typeof getMyFolders>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyFolders>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMyFoldersQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyFolders>>> = ({ signal }) =>
    getMyFolders(requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMyFolders>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetMyFoldersQueryResult = NonNullable<Awaited<ReturnType<typeof getMyFolders>>>;
export type GetMyFoldersQueryError = unknown;

export function useGetMyFolders<TData = Awaited<ReturnType<typeof getMyFolders>>, TError = unknown>(options: {
  query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyFolders>>, TError, TData>> &
    Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getMyFolders>>, TError, TData>, 'initialData'>;
  request?: SecondParameter<typeof customFetcher>;
}): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetMyFolders<TData = Awaited<ReturnType<typeof getMyFolders>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyFolders>>, TError, TData>> &
    Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getMyFolders>>, TError, TData>, 'initialData'>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetMyFolders<TData = Awaited<ReturnType<typeof getMyFolders>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyFolders>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ì‚¬ìš©ìì˜ í™ˆì—ì„œ ë³´ì—¬ì¤„ ë‚´ í´ë” ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ
 */

export function useGetMyFolders<TData = Awaited<ReturnType<typeof getMyFolders>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyFolders>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetMyFoldersQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ì‚¬ìš©ìì˜ í”„ë¡œí•„ idë¡œ í´ë”êµ¬ì¡°ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary ì‚¬ìš©ìì˜ ë‚´ í´ë” êµ¬ì¡° ì¡°íšŒ
 */
export const scanMyFolders = (
  params?: ScanMyFoldersParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderTreeResult>(
    { url: `/file/v1/my-folder/folder-tree`, method: 'GET', params, signal },
    options,
  );
};

export const getScanMyFoldersQueryKey = (params?: ScanMyFoldersParams) => {
  return [`/file/v1/my-folder/folder-tree`, ...(params ? [params] : [])] as const;
};

export const getScanMyFoldersQueryOptions = <TData = Awaited<ReturnType<typeof scanMyFolders>>, TError = unknown>(
  params?: ScanMyFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof scanMyFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getScanMyFoldersQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof scanMyFolders>>> = ({ signal }) =>
    scanMyFolders(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof scanMyFolders>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type ScanMyFoldersQueryResult = NonNullable<Awaited<ReturnType<typeof scanMyFolders>>>;
export type ScanMyFoldersQueryError = unknown;

export function useScanMyFolders<TData = Awaited<ReturnType<typeof scanMyFolders>>, TError = unknown>(
  params: undefined | ScanMyFoldersParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof scanMyFolders>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof scanMyFolders>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useScanMyFolders<TData = Awaited<ReturnType<typeof scanMyFolders>>, TError = unknown>(
  params?: ScanMyFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof scanMyFolders>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof scanMyFolders>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useScanMyFolders<TData = Awaited<ReturnType<typeof scanMyFolders>>, TError = unknown>(
  params?: ScanMyFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof scanMyFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ì‚¬ìš©ìì˜ ë‚´ í´ë” êµ¬ì¡° ì¡°íšŒ
 */

export function useScanMyFolders<TData = Awaited<ReturnType<typeof scanMyFolders>>, TError = unknown>(
  params?: ScanMyFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof scanMyFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getScanMyFoldersQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ì‚¬ìš©ìì˜ í”„ë¡œí•„ idë¡œ ë‚´ í´ë” ëª©ë¡ì„ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary ì‚¬ìš©ìì˜ ë‚´ í´ë” ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ
 */
export const getMyFolders1 = (
  params?: GetMyFolders1Params,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderResult>(
    { url: `/file/v1/my-folder/folder-list`, method: 'GET', params, signal },
    options,
  );
};

export const getGetMyFolders1QueryKey = (params?: GetMyFolders1Params) => {
  return [`/file/v1/my-folder/folder-list`, ...(params ? [params] : [])] as const;
};

export const getGetMyFolders1QueryOptions = <TData = Awaited<ReturnType<typeof getMyFolders1>>, TError = unknown>(
  params?: GetMyFolders1Params,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyFolders1>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMyFolders1QueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyFolders1>>> = ({ signal }) =>
    getMyFolders1(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMyFolders1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetMyFolders1QueryResult = NonNullable<Awaited<ReturnType<typeof getMyFolders1>>>;
export type GetMyFolders1QueryError = unknown;

export function useGetMyFolders1<TData = Awaited<ReturnType<typeof getMyFolders1>>, TError = unknown>(
  params: undefined | GetMyFolders1Params,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyFolders1>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getMyFolders1>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetMyFolders1<TData = Awaited<ReturnType<typeof getMyFolders1>>, TError = unknown>(
  params?: GetMyFolders1Params,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyFolders1>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getMyFolders1>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetMyFolders1<TData = Awaited<ReturnType<typeof getMyFolders1>>, TError = unknown>(
  params?: GetMyFolders1Params,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyFolders1>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ì‚¬ìš©ìì˜ ë‚´ í´ë” ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ
 */

export function useGetMyFolders1<TData = Awaited<ReturnType<typeof getMyFolders1>>, TError = unknown>(
  params?: GetMyFolders1Params,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyFolders1>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetMyFolders1QueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * í‚¤ì›Œë“œë¡œ ë§ˆì´ë³´ë“œë‚´ì˜ ìë£Œë¥¼ ê²€ìƒ‰í•©ë‹ˆë‹¤.
 * @summary ë§ˆì´ë³´ë“œì—ì„œ ìë£Œ ê²€ìƒ‰
 */
export const searchMyBoardData = (
  profileId: string,
  params: SearchMyBoardDataParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/file/v1/my-board/${profileId}/search`, method: 'GET', params, signal },
    options,
  );
};

export const getSearchMyBoardDataQueryKey = (profileId: string, params: SearchMyBoardDataParams) => {
  return [`/file/v1/my-board/${profileId}/search`, ...(params ? [params] : [])] as const;
};

export const getSearchMyBoardDataQueryOptions = <
  TData = Awaited<ReturnType<typeof searchMyBoardData>>,
  TError = unknown,
>(
  profileId: string,
  params: SearchMyBoardDataParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchMyBoardData>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSearchMyBoardDataQueryKey(profileId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof searchMyBoardData>>> = ({ signal }) =>
    searchMyBoardData(profileId, params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof searchMyBoardData>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type SearchMyBoardDataQueryResult = NonNullable<Awaited<ReturnType<typeof searchMyBoardData>>>;
export type SearchMyBoardDataQueryError = unknown;

export function useSearchMyBoardData<TData = Awaited<ReturnType<typeof searchMyBoardData>>, TError = unknown>(
  profileId: string,
  params: SearchMyBoardDataParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchMyBoardData>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof searchMyBoardData>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useSearchMyBoardData<TData = Awaited<ReturnType<typeof searchMyBoardData>>, TError = unknown>(
  profileId: string,
  params: SearchMyBoardDataParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchMyBoardData>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof searchMyBoardData>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useSearchMyBoardData<TData = Awaited<ReturnType<typeof searchMyBoardData>>, TError = unknown>(
  profileId: string,
  params: SearchMyBoardDataParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchMyBoardData>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ë§ˆì´ë³´ë“œì—ì„œ ìë£Œ ê²€ìƒ‰
 */

export function useSearchMyBoardData<TData = Awaited<ReturnType<typeof searchMyBoardData>>, TError = unknown>(
  profileId: string,
  params: SearchMyBoardDataParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchMyBoardData>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getSearchMyBoardDataQueryOptions(profileId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ë§ˆì´ë³´ë“œì—ì„œ íƒ­ ë³„ë¡œ ë³´ì—¬ì¤„ ìë£Œ ë¦¬ìŠ¤íŠ¸ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary ë§ˆì´ë³´ë“œì—ì„œ íƒ­ì—ë”°ë¼ ë³´ì—¬ì¤„ ìë£Œ ë¦¬ìŠ¤íŠ¸ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.
 */
export const getMyBoardItems = (
  profileId: string,
  params: GetMyBoardItemsParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/file/v1/my-board/${profileId}/list`, method: 'GET', params, signal },
    options,
  );
};

export const getGetMyBoardItemsQueryKey = (profileId: string, params: GetMyBoardItemsParams) => {
  return [`/file/v1/my-board/${profileId}/list`, ...(params ? [params] : [])] as const;
};

export const getGetMyBoardItemsQueryOptions = <TData = Awaited<ReturnType<typeof getMyBoardItems>>, TError = unknown>(
  profileId: string,
  params: GetMyBoardItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyBoardItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMyBoardItemsQueryKey(profileId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyBoardItems>>> = ({ signal }) =>
    getMyBoardItems(profileId, params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMyBoardItems>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetMyBoardItemsQueryResult = NonNullable<Awaited<ReturnType<typeof getMyBoardItems>>>;
export type GetMyBoardItemsQueryError = unknown;

export function useGetMyBoardItems<TData = Awaited<ReturnType<typeof getMyBoardItems>>, TError = unknown>(
  profileId: string,
  params: GetMyBoardItemsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyBoardItems>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getMyBoardItems>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetMyBoardItems<TData = Awaited<ReturnType<typeof getMyBoardItems>>, TError = unknown>(
  profileId: string,
  params: GetMyBoardItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyBoardItems>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getMyBoardItems>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetMyBoardItems<TData = Awaited<ReturnType<typeof getMyBoardItems>>, TError = unknown>(
  profileId: string,
  params: GetMyBoardItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyBoardItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ë§ˆì´ë³´ë“œì—ì„œ íƒ­ì—ë”°ë¼ ë³´ì—¬ì¤„ ìë£Œ ë¦¬ìŠ¤íŠ¸ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.
 */

export function useGetMyBoardItems<TData = Awaited<ReturnType<typeof getMyBoardItems>>, TError = unknown>(
  profileId: string,
  params: GetMyBoardItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyBoardItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetMyBoardItemsQueryOptions(profileId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ë§ˆì´ë³´ë“œì—ì„œ ë³´ì—¬ì¤„ ê²Œì‹œê¸€ ìˆ˜ì™€ ë·° ìˆ˜ë¥¼ ì²´í¬í•©ë‹ˆë‹¤.ë‚˜ì˜ ìë£ŒëŠ” all countë¥¼ ë‚¨ì˜ ìë£ŒëŠ” public countë¥¼ ë³´ì—¬ì£¼ëŠ”ê²Œ ë§ì„ ê²ƒ ê°™ì€ë°, ì¼ë‹¨ ê³µê°œëœ ìë£Œê¸°ì¤€ìœ¼ë¡œ public ì¹´ìš´íŠ¸ë¡œ í‘œì‹œí•´ë‘ëŠ”ê²Œ ë‚  ê²ƒ ê°™ìŠµë‹ˆë‹¤(myBoardPublicItemCount, myBoardPublicViewCount).
 * @summary í”„ë¡œí•„ì˜ ê²Œì‹œê¸€ ìˆ˜, ë·° ìˆ˜ ì¡°íšŒ
 */
export const getCounts = (profileId: string, options?: SecondParameter<typeof customFetcher>, signal?: AbortSignal) => {
  return customFetcher<ApiResponseMyBoardCountsResult>(
    { url: `/file/v1/my-board/${profileId}/counts`, method: 'GET', signal },
    options,
  );
};

export const getGetCountsQueryKey = (profileId: string) => {
  return [`/file/v1/my-board/${profileId}/counts`] as const;
};

export const getGetCountsQueryOptions = <TData = Awaited<ReturnType<typeof getCounts>>, TError = unknown>(
  profileId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCounts>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCountsQueryKey(profileId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCounts>>> = ({ signal }) =>
    getCounts(profileId, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getCounts>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetCountsQueryResult = NonNullable<Awaited<ReturnType<typeof getCounts>>>;
export type GetCountsQueryError = unknown;

export function useGetCounts<TData = Awaited<ReturnType<typeof getCounts>>, TError = unknown>(
  profileId: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCounts>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getCounts>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetCounts<TData = Awaited<ReturnType<typeof getCounts>>, TError = unknown>(
  profileId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCounts>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getCounts>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetCounts<TData = Awaited<ReturnType<typeof getCounts>>, TError = unknown>(
  profileId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCounts>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary í”„ë¡œí•„ì˜ ê²Œì‹œê¸€ ìˆ˜, ë·° ìˆ˜ ì¡°íšŒ
 */

export function useGetCounts<TData = Awaited<ReturnType<typeof getCounts>>, TError = unknown>(
  profileId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCounts>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetCountsQueryOptions(profileId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ë†€ì´ë³´ê³ ì„œë¥¼ idë¡œ ì¡°íšŒ í•©ë‹ˆë‹¤.
 * @summary ë†€ì´ë³´ê³ ì„œ ì¡°íšŒ
 */
export const getLectureReport = (
  id: number,
  params?: GetLectureReportParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseLectureReportResult>(
    { url: `/file/v1/lecture-report/${id}`, method: 'GET', params, signal },
    options,
  );
};

export const getGetLectureReportQueryKey = (id: number, params?: GetLectureReportParams) => {
  return [`/file/v1/lecture-report/${id}`, ...(params ? [params] : [])] as const;
};

export const getGetLectureReportQueryOptions = <TData = Awaited<ReturnType<typeof getLectureReport>>, TError = unknown>(
  id: number,
  params?: GetLectureReportParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLectureReport>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetLectureReportQueryKey(id, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLectureReport>>> = ({ signal }) =>
    getLectureReport(id, params, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!id, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getLectureReport>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetLectureReportQueryResult = NonNullable<Awaited<ReturnType<typeof getLectureReport>>>;
export type GetLectureReportQueryError = unknown;

export function useGetLectureReport<TData = Awaited<ReturnType<typeof getLectureReport>>, TError = unknown>(
  id: number,
  params: undefined | GetLectureReportParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLectureReport>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getLectureReport>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetLectureReport<TData = Awaited<ReturnType<typeof getLectureReport>>, TError = unknown>(
  id: number,
  params?: GetLectureReportParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLectureReport>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getLectureReport>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetLectureReport<TData = Awaited<ReturnType<typeof getLectureReport>>, TError = unknown>(
  id: number,
  params?: GetLectureReportParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLectureReport>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ë†€ì´ë³´ê³ ì„œ ì¡°íšŒ
 */

export function useGetLectureReport<TData = Awaited<ReturnType<typeof getLectureReport>>, TError = unknown>(
  id: number,
  params?: GetLectureReportParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLectureReport>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetLectureReportQueryOptions(id, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ê¸°ê°„ì— ë”°ë¼ì„œ ëª¨ë°”ì¼ì—…ë¡œë“œ, ìš°ë¦¬ë°˜ì‚¬ì§„ ë“±ì—ì„œ ìë£Œë¥¼ ê²€ìƒ‰í•©ë‹ˆë‹¤.
 * @summary í™œë™ ê¸°ê°„ì— ë”°ë¥¸ ì‚¬ì§„ ì¡°íšŒ
 */
export const getPhotosForReport = (
  profileId: string,
  params: GetPhotosForReportParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/file/v1/lecture-report/photos-for-report/${profileId}`, method: 'GET', params, signal },
    options,
  );
};

export const getGetPhotosForReportQueryKey = (profileId: string, params: GetPhotosForReportParams) => {
  return [`/file/v1/lecture-report/photos-for-report/${profileId}`, ...(params ? [params] : [])] as const;
};

export const getGetPhotosForReportQueryOptions = <
  TData = Awaited<ReturnType<typeof getPhotosForReport>>,
  TError = unknown,
>(
  profileId: string,
  params: GetPhotosForReportParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotosForReport>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPhotosForReportQueryKey(profileId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPhotosForReport>>> = ({ signal }) =>
    getPhotosForReport(profileId, params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPhotosForReport>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetPhotosForReportQueryResult = NonNullable<Awaited<ReturnType<typeof getPhotosForReport>>>;
export type GetPhotosForReportQueryError = unknown;

export function useGetPhotosForReport<TData = Awaited<ReturnType<typeof getPhotosForReport>>, TError = unknown>(
  profileId: string,
  params: GetPhotosForReportParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotosForReport>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getPhotosForReport>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetPhotosForReport<TData = Awaited<ReturnType<typeof getPhotosForReport>>, TError = unknown>(
  profileId: string,
  params: GetPhotosForReportParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotosForReport>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getPhotosForReport>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetPhotosForReport<TData = Awaited<ReturnType<typeof getPhotosForReport>>, TError = unknown>(
  profileId: string,
  params: GetPhotosForReportParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotosForReport>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary í™œë™ ê¸°ê°„ì— ë”°ë¥¸ ì‚¬ì§„ ì¡°íšŒ
 */

export function useGetPhotosForReport<TData = Awaited<ReturnType<typeof getPhotosForReport>>, TError = unknown>(
  profileId: string,
  params: GetPhotosForReportParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotosForReport>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetPhotosForReportQueryOptions(profileId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ë†€ì´ê³„íšì„ idë¡œ ì¡°íšŒ í•©ë‹ˆë‹¤.
 * @summary ë†€ì´ê³„íš ì¡°íšŒ
 */
export const getLecturePlan = (
  lecturePlanId: number,
  params?: GetLecturePlanParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseLecturePlanResult>(
    { url: `/file/v1/lecture-plan/${lecturePlanId}`, method: 'GET', params, signal },
    options,
  );
};

export const getGetLecturePlanQueryKey = (lecturePlanId: number, params?: GetLecturePlanParams) => {
  return [`/file/v1/lecture-plan/${lecturePlanId}`, ...(params ? [params] : [])] as const;
};

export const getGetLecturePlanQueryOptions = <TData = Awaited<ReturnType<typeof getLecturePlan>>, TError = unknown>(
  lecturePlanId: number,
  params?: GetLecturePlanParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlan>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetLecturePlanQueryKey(lecturePlanId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLecturePlan>>> = ({ signal }) =>
    getLecturePlan(lecturePlanId, params, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!lecturePlanId, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getLecturePlan>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetLecturePlanQueryResult = NonNullable<Awaited<ReturnType<typeof getLecturePlan>>>;
export type GetLecturePlanQueryError = unknown;

export function useGetLecturePlan<TData = Awaited<ReturnType<typeof getLecturePlan>>, TError = unknown>(
  lecturePlanId: number,
  params: undefined | GetLecturePlanParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlan>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getLecturePlan>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetLecturePlan<TData = Awaited<ReturnType<typeof getLecturePlan>>, TError = unknown>(
  lecturePlanId: number,
  params?: GetLecturePlanParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlan>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getLecturePlan>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetLecturePlan<TData = Awaited<ReturnType<typeof getLecturePlan>>, TError = unknown>(
  lecturePlanId: number,
  params?: GetLecturePlanParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlan>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ë†€ì´ê³„íš ì¡°íšŒ
 */

export function useGetLecturePlan<TData = Awaited<ReturnType<typeof getLecturePlan>>, TError = unknown>(
  lecturePlanId: number,
  params?: GetLecturePlanParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlan>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetLecturePlanQueryOptions(lecturePlanId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ë‹¹ì¼ ê¸°ì¤€ìœ¼ë¡œ ë†€ì´ê³„íšì•ˆì— ë¨¼ì € ë„£ì–´ì¤„ ê¸°ê°„ì„ ê³„ì‚°í•©ë‹ˆë‹¤.ì‹œì‘ì¼: ë†€ì´ ê³„íšì„ ìƒì„± ì‹œì‘í•œ ì¼ìì˜ ë‹¤ìŒ ë‚  (ì£¼ë§ì´ë©´ ì¼ë‹¨ ì›”ìš”ì¼ë¡œ)
ì¢…ë£Œì¼: 60ë¶„ ë¯¸ë§Œì€ ì‹œì‘ì¼ê³¼ ë™ì¼, 1ì¼, 3ì¼, 5ì¼, 2ì£¼, 3ì£¼, 4ì£¼ëŠ” ì‹œì‘ì¼ì— ê³„ì‚°í•˜ì—¬ ì ìš© 
ì—°ë ¹ì´ë‚˜ ì‚¬ìš©ìì˜ ì •ë³´ë„ ë°›ì•„ì„œ, ì¶”í›„ ì´ ì‚¬ëŒì´ ì£¼ë¡œ ê¸°íší•˜ëŠ” ì£¼ê¸°ë¥¼ ì˜ˆì¸¡í•˜ì—¬ ì‘ë‹µí•˜ê¸°í•  ìˆ˜ ìˆì„ ê²ƒ ê°™ìŠµë‹ˆë‹¤.
 * @summary ë†€ì´ê³„íšì—ì„œ ë¨¼ì € ì„¤ì •í•´ì¤„ ê¸°ê°„ì„ ì¡°íšŒ
 */
export const getTerm = (
  params: GetTermParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseLecturePlanTermResult>(
    { url: `/file/v1/lecture-plan/term`, method: 'GET', params, signal },
    options,
  );
};

export const getGetTermQueryKey = (params: GetTermParams) => {
  return [`/file/v1/lecture-plan/term`, ...(params ? [params] : [])] as const;
};

export const getGetTermQueryOptions = <TData = Awaited<ReturnType<typeof getTerm>>, TError = unknown>(
  params: GetTermParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTerm>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTermQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTerm>>> = ({ signal }) =>
    getTerm(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getTerm>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetTermQueryResult = NonNullable<Awaited<ReturnType<typeof getTerm>>>;
export type GetTermQueryError = unknown;

export function useGetTerm<TData = Awaited<ReturnType<typeof getTerm>>, TError = unknown>(
  params: GetTermParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTerm>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getTerm>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetTerm<TData = Awaited<ReturnType<typeof getTerm>>, TError = unknown>(
  params: GetTermParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTerm>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getTerm>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetTerm<TData = Awaited<ReturnType<typeof getTerm>>, TError = unknown>(
  params: GetTermParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTerm>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ë†€ì´ê³„íšì—ì„œ ë¨¼ì € ì„¤ì •í•´ì¤„ ê¸°ê°„ì„ ì¡°íšŒ
 */

export function useGetTerm<TData = Awaited<ReturnType<typeof getTerm>>, TError = unknown>(
  params: GetTermParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTerm>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetTermQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ì‚¬ìš©ìì˜ í”„ë¡œí•„ idë¡œ ë†€ì´ê³„íšëª©ë¡ì„ ì¡°íšŒ í•©ë‹ˆë‹¤.
 * @summary ì‚¬ìš©ì í”„ë¡œí•„ idë¡œ ë†€ì´ê³„íš ëª©ë¡ ì¡°íšŒ
 */
export const getLecturePlanList = (
  params?: GetLecturePlanListParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListLecturePlanResult>(
    { url: `/file/v1/lecture-plan/list`, method: 'GET', params, signal },
    options,
  );
};

export const getGetLecturePlanListQueryKey = (params?: GetLecturePlanListParams) => {
  return [`/file/v1/lecture-plan/list`, ...(params ? [params] : [])] as const;
};

export const getGetLecturePlanListQueryOptions = <
  TData = Awaited<ReturnType<typeof getLecturePlanList>>,
  TError = unknown,
>(
  params?: GetLecturePlanListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlanList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetLecturePlanListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLecturePlanList>>> = ({ signal }) =>
    getLecturePlanList(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getLecturePlanList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetLecturePlanListQueryResult = NonNullable<Awaited<ReturnType<typeof getLecturePlanList>>>;
export type GetLecturePlanListQueryError = unknown;

export function useGetLecturePlanList<TData = Awaited<ReturnType<typeof getLecturePlanList>>, TError = unknown>(
  params: undefined | GetLecturePlanListParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlanList>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getLecturePlanList>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetLecturePlanList<TData = Awaited<ReturnType<typeof getLecturePlanList>>, TError = unknown>(
  params?: GetLecturePlanListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlanList>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getLecturePlanList>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetLecturePlanList<TData = Awaited<ReturnType<typeof getLecturePlanList>>, TError = unknown>(
  params?: GetLecturePlanListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlanList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ì‚¬ìš©ì í”„ë¡œí•„ idë¡œ ë†€ì´ê³„íš ëª©ë¡ ì¡°íšŒ
 */

export function useGetLecturePlanList<TData = Awaited<ReturnType<typeof getLecturePlanList>>, TError = unknown>(
  params?: GetLecturePlanListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlanList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetLecturePlanListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ì‚¬ìš©ìì˜ í”„ë¡œí•„ idë¡œ ë†€ì´ê³„íšëª©ë¡ì„ ì¡°íšŒ í•©ë‹ˆë‹¤. ê²€ìƒ‰ì–´ê°€ nullì´ë‚˜ ë¹ˆ ë¬¸ìì—´ì´ë©´ ê·¸ëƒ¥ í•´ë‹¹ ì‚¬ìš©ìì˜ ë†€ì´ê³„íšì•ˆì„ ë¶ˆëŸ¬ì˜µë‹ˆë‹¤.
 * @summary ì‚¬ìš©ì í”„ë¡œí•„ idë¡œ ë†€ì´ê³„íš ëª©ë¡ ì¡°íšŒ(ê²€ìƒ‰ ì¶”ê°€)
 */
export const getLecturePlanListWithSearch = (
  params?: GetLecturePlanListWithSearchParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListLecturePlanResult>(
    { url: `/file/v1/lecture-plan/list-with-search`, method: 'GET', params, signal },
    options,
  );
};

export const getGetLecturePlanListWithSearchQueryKey = (params?: GetLecturePlanListWithSearchParams) => {
  return [`/file/v1/lecture-plan/list-with-search`, ...(params ? [params] : [])] as const;
};

export const getGetLecturePlanListWithSearchQueryOptions = <
  TData = Awaited<ReturnType<typeof getLecturePlanListWithSearch>>,
  TError = unknown,
>(
  params?: GetLecturePlanListWithSearchParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlanListWithSearch>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetLecturePlanListWithSearchQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLecturePlanListWithSearch>>> = ({ signal }) =>
    getLecturePlanListWithSearch(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getLecturePlanListWithSearch>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetLecturePlanListWithSearchQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLecturePlanListWithSearch>>
>;
export type GetLecturePlanListWithSearchQueryError = unknown;

export function useGetLecturePlanListWithSearch<
  TData = Awaited<ReturnType<typeof getLecturePlanListWithSearch>>,
  TError = unknown,
>(
  params: undefined | GetLecturePlanListWithSearchParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlanListWithSearch>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getLecturePlanListWithSearch>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetLecturePlanListWithSearch<
  TData = Awaited<ReturnType<typeof getLecturePlanListWithSearch>>,
  TError = unknown,
>(
  params?: GetLecturePlanListWithSearchParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlanListWithSearch>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getLecturePlanListWithSearch>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetLecturePlanListWithSearch<
  TData = Awaited<ReturnType<typeof getLecturePlanListWithSearch>>,
  TError = unknown,
>(
  params?: GetLecturePlanListWithSearchParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlanListWithSearch>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ì‚¬ìš©ì í”„ë¡œí•„ idë¡œ ë†€ì´ê³„íš ëª©ë¡ ì¡°íšŒ(ê²€ìƒ‰ ì¶”ê°€)
 */

export function useGetLecturePlanListWithSearch<
  TData = Awaited<ReturnType<typeof getLecturePlanListWithSearch>>,
  TError = unknown,
>(
  params?: GetLecturePlanListWithSearchParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlanListWithSearch>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetLecturePlanListWithSearchQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ìë£Œì˜ idë‚˜ í‚¤ ê°’ìœ¼ë¡œ ìë£Œì˜ ì •ë³´ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary ìë£Œ ì •ë³´ ì¡°íšŒ
 */
export const getByIdOrKey = (
  idOrKey: string,
  params: GetByIdOrKeyParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseDriveItemResult>(
    { url: `/file/v1/drive-items/${idOrKey}`, method: 'GET', params, signal },
    options,
  );
};

export const getGetByIdOrKeyQueryKey = (idOrKey: string, params: GetByIdOrKeyParams) => {
  return [`/file/v1/drive-items/${idOrKey}`, ...(params ? [params] : [])] as const;
};

export const getGetByIdOrKeyQueryOptions = <TData = Awaited<ReturnType<typeof getByIdOrKey>>, TError = unknown>(
  idOrKey: string,
  params: GetByIdOrKeyParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getByIdOrKey>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetByIdOrKeyQueryKey(idOrKey, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getByIdOrKey>>> = ({ signal }) =>
    getByIdOrKey(idOrKey, params, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!idOrKey, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getByIdOrKey>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetByIdOrKeyQueryResult = NonNullable<Awaited<ReturnType<typeof getByIdOrKey>>>;
export type GetByIdOrKeyQueryError = unknown;

export function useGetByIdOrKey<TData = Awaited<ReturnType<typeof getByIdOrKey>>, TError = unknown>(
  idOrKey: string,
  params: GetByIdOrKeyParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getByIdOrKey>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getByIdOrKey>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetByIdOrKey<TData = Awaited<ReturnType<typeof getByIdOrKey>>, TError = unknown>(
  idOrKey: string,
  params: GetByIdOrKeyParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getByIdOrKey>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getByIdOrKey>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetByIdOrKey<TData = Awaited<ReturnType<typeof getByIdOrKey>>, TError = unknown>(
  idOrKey: string,
  params: GetByIdOrKeyParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getByIdOrKey>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ìë£Œ ì •ë³´ ì¡°íšŒ
 */

export function useGetByIdOrKey<TData = Awaited<ReturnType<typeof getByIdOrKey>>, TError = unknown>(
  idOrKey: string,
  params: GetByIdOrKeyParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getByIdOrKey>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetByIdOrKeyQueryOptions(idOrKey, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ìë£Œì— ë“±ë¡ëœ ìì‹ ëŒ“ê¸€ ëª©ë¡ì„ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary í•˜ìœ„ ëŒ“ê¸€ ì¡°íšŒ
 */
export const getChildPagingReplies = (
  driveItemIdOrKey: string,
  parentId: string,
  params?: GetChildPagingRepliesParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListReplyResult>(
    { url: `/file/v1/drive-items/${driveItemIdOrKey}/replies/${parentId}`, method: 'GET', params, signal },
    options,
  );
};

export const getGetChildPagingRepliesQueryKey = (
  driveItemIdOrKey: string,
  parentId: string,
  params?: GetChildPagingRepliesParams,
) => {
  return [`/file/v1/drive-items/${driveItemIdOrKey}/replies/${parentId}`, ...(params ? [params] : [])] as const;
};

export const getGetChildPagingRepliesQueryOptions = <
  TData = Awaited<ReturnType<typeof getChildPagingReplies>>,
  TError = unknown,
>(
  driveItemIdOrKey: string,
  parentId: string,
  params?: GetChildPagingRepliesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getChildPagingReplies>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetChildPagingRepliesQueryKey(driveItemIdOrKey, parentId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getChildPagingReplies>>> = ({ signal }) =>
    getChildPagingReplies(driveItemIdOrKey, parentId, params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(driveItemIdOrKey && parentId),
    staleTime: 60000,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getChildPagingReplies>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData>;
  };
};

export type GetChildPagingRepliesQueryResult = NonNullable<Awaited<ReturnType<typeof getChildPagingReplies>>>;
export type GetChildPagingRepliesQueryError = unknown;

export function useGetChildPagingReplies<TData = Awaited<ReturnType<typeof getChildPagingReplies>>, TError = unknown>(
  driveItemIdOrKey: string,
  parentId: string,
  params: undefined | GetChildPagingRepliesParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getChildPagingReplies>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getChildPagingReplies>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetChildPagingReplies<TData = Awaited<ReturnType<typeof getChildPagingReplies>>, TError = unknown>(
  driveItemIdOrKey: string,
  parentId: string,
  params?: GetChildPagingRepliesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getChildPagingReplies>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getChildPagingReplies>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetChildPagingReplies<TData = Awaited<ReturnType<typeof getChildPagingReplies>>, TError = unknown>(
  driveItemIdOrKey: string,
  parentId: string,
  params?: GetChildPagingRepliesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getChildPagingReplies>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary í•˜ìœ„ ëŒ“ê¸€ ì¡°íšŒ
 */

export function useGetChildPagingReplies<TData = Awaited<ReturnType<typeof getChildPagingReplies>>, TError = unknown>(
  driveItemIdOrKey: string,
  parentId: string,
  params?: GetChildPagingRepliesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getChildPagingReplies>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetChildPagingRepliesQueryOptions(driveItemIdOrKey, parentId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const searchKeywordAnalize = (
  params: SearchKeywordAnalizeParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListString>(
    { url: `/file/v1/drive-items/test/keyword-analyze`, method: 'GET', params, signal },
    options,
  );
};

export const getSearchKeywordAnalizeQueryKey = (params: SearchKeywordAnalizeParams) => {
  return [`/file/v1/drive-items/test/keyword-analyze`, ...(params ? [params] : [])] as const;
};

export const getSearchKeywordAnalizeQueryOptions = <
  TData = Awaited<ReturnType<typeof searchKeywordAnalize>>,
  TError = unknown,
>(
  params: SearchKeywordAnalizeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchKeywordAnalize>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSearchKeywordAnalizeQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof searchKeywordAnalize>>> = ({ signal }) =>
    searchKeywordAnalize(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof searchKeywordAnalize>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type SearchKeywordAnalizeQueryResult = NonNullable<Awaited<ReturnType<typeof searchKeywordAnalize>>>;
export type SearchKeywordAnalizeQueryError = unknown;

export function useSearchKeywordAnalize<TData = Awaited<ReturnType<typeof searchKeywordAnalize>>, TError = unknown>(
  params: SearchKeywordAnalizeParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchKeywordAnalize>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof searchKeywordAnalize>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useSearchKeywordAnalize<TData = Awaited<ReturnType<typeof searchKeywordAnalize>>, TError = unknown>(
  params: SearchKeywordAnalizeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchKeywordAnalize>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof searchKeywordAnalize>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useSearchKeywordAnalize<TData = Awaited<ReturnType<typeof searchKeywordAnalize>>, TError = unknown>(
  params: SearchKeywordAnalizeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchKeywordAnalize>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

export function useSearchKeywordAnalize<TData = Awaited<ReturnType<typeof searchKeywordAnalize>>, TError = unknown>(
  params: SearchKeywordAnalizeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchKeywordAnalize>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getSearchKeywordAnalizeQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const checkNotIndexedItems = (options?: SecondParameter<typeof customFetcher>, signal?: AbortSignal) => {
  return customFetcher<ApiResponseListDriveItemResult>(
    { url: `/file/v1/drive-items/test/check-not-indexed-items`, method: 'GET', signal },
    options,
  );
};

export const getCheckNotIndexedItemsQueryKey = () => {
  return [`/file/v1/drive-items/test/check-not-indexed-items`] as const;
};

export const getCheckNotIndexedItemsQueryOptions = <
  TData = Awaited<ReturnType<typeof checkNotIndexedItems>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof checkNotIndexedItems>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getCheckNotIndexedItemsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof checkNotIndexedItems>>> = ({ signal }) =>
    checkNotIndexedItems(requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof checkNotIndexedItems>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type CheckNotIndexedItemsQueryResult = NonNullable<Awaited<ReturnType<typeof checkNotIndexedItems>>>;
export type CheckNotIndexedItemsQueryError = unknown;

export function useCheckNotIndexedItems<
  TData = Awaited<ReturnType<typeof checkNotIndexedItems>>,
  TError = unknown,
>(options: {
  query: Partial<UseQueryOptions<Awaited<ReturnType<typeof checkNotIndexedItems>>, TError, TData>> &
    Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof checkNotIndexedItems>>, TError, TData>, 'initialData'>;
  request?: SecondParameter<typeof customFetcher>;
}): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useCheckNotIndexedItems<
  TData = Awaited<ReturnType<typeof checkNotIndexedItems>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof checkNotIndexedItems>>, TError, TData>> &
    Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof checkNotIndexedItems>>, TError, TData>, 'initialData'>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useCheckNotIndexedItems<
  TData = Awaited<ReturnType<typeof checkNotIndexedItems>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof checkNotIndexedItems>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

export function useCheckNotIndexedItems<
  TData = Awaited<ReturnType<typeof checkNotIndexedItems>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof checkNotIndexedItems>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getCheckNotIndexedItemsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const checkNotIndexedItems2 = (
  params: CheckNotIndexedItems2Params,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderDocumentItem>(
    { url: `/file/v1/drive-items/test/check-not-indexed-items-2`, method: 'GET', params, signal },
    options,
  );
};

export const getCheckNotIndexedItems2QueryKey = (params: CheckNotIndexedItems2Params) => {
  return [`/file/v1/drive-items/test/check-not-indexed-items-2`, ...(params ? [params] : [])] as const;
};

export const getCheckNotIndexedItems2QueryOptions = <
  TData = Awaited<ReturnType<typeof checkNotIndexedItems2>>,
  TError = unknown,
>(
  params: CheckNotIndexedItems2Params,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof checkNotIndexedItems2>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getCheckNotIndexedItems2QueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof checkNotIndexedItems2>>> = ({ signal }) =>
    checkNotIndexedItems2(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof checkNotIndexedItems2>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type CheckNotIndexedItems2QueryResult = NonNullable<Awaited<ReturnType<typeof checkNotIndexedItems2>>>;
export type CheckNotIndexedItems2QueryError = unknown;

export function useCheckNotIndexedItems2<TData = Awaited<ReturnType<typeof checkNotIndexedItems2>>, TError = unknown>(
  params: CheckNotIndexedItems2Params,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof checkNotIndexedItems2>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof checkNotIndexedItems2>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useCheckNotIndexedItems2<TData = Awaited<ReturnType<typeof checkNotIndexedItems2>>, TError = unknown>(
  params: CheckNotIndexedItems2Params,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof checkNotIndexedItems2>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof checkNotIndexedItems2>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useCheckNotIndexedItems2<TData = Awaited<ReturnType<typeof checkNotIndexedItems2>>, TError = unknown>(
  params: CheckNotIndexedItems2Params,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof checkNotIndexedItems2>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

export function useCheckNotIndexedItems2<TData = Awaited<ReturnType<typeof checkNotIndexedItems2>>, TError = unknown>(
  params: CheckNotIndexedItems2Params,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof checkNotIndexedItems2>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getCheckNotIndexedItems2QueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ë‚˜ì´ë¡œ ì–´ë–¤ ê³¼ì •ì— í•´ë‹¹í•˜ëŠ” ì§€í™•ì¸í•©ë‹ˆë‹¤.
 * @summary ë‚˜ì´ë¡œ ê³¼ì •ì •ë³´ í™•ì¸
 */
export const getCourse = (
  params: GetCourseParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseCourseResult>({ url: `/file/v1/course`, method: 'GET', params, signal }, options);
};

export const getGetCourseQueryKey = (params: GetCourseParams) => {
  return [`/file/v1/course`, ...(params ? [params] : [])] as const;
};

export const getGetCourseQueryOptions = <TData = Awaited<ReturnType<typeof getCourse>>, TError = unknown>(
  params: GetCourseParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCourse>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCourseQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCourse>>> = ({ signal }) =>
    getCourse(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getCourse>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetCourseQueryResult = NonNullable<Awaited<ReturnType<typeof getCourse>>>;
export type GetCourseQueryError = unknown;

export function useGetCourse<TData = Awaited<ReturnType<typeof getCourse>>, TError = unknown>(
  params: GetCourseParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCourse>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getCourse>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetCourse<TData = Awaited<ReturnType<typeof getCourse>>, TError = unknown>(
  params: GetCourseParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCourse>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getCourse>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetCourse<TData = Awaited<ReturnType<typeof getCourse>>, TError = unknown>(
  params: GetCourseParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCourse>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ë‚˜ì´ë¡œ ê³¼ì •ì •ë³´ í™•ì¸
 */

export function useGetCourse<TData = Awaited<ReturnType<typeof getCourse>>, TError = unknown>(
  params: GetCourseParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCourse>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetCourseQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ë“±ë¡ë˜ì–´ì‡ëŠ” ê³¼ì • ë¦¬ìŠ¤íŠ¸ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤. 1ì°¨ëŠ” ì–´ë¦°ì´ì§‘, ìœ ì¹˜ì›, ì´ˆë“±í•™êµë§Œ.
 * @summary ë“±ë¡ëœ ê³¼ì • ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ
 */
export const getCourse1 = (options?: SecondParameter<typeof customFetcher>, signal?: AbortSignal) => {
  return customFetcher<ApiResponseListCourseResult>({ url: `/file/v1/course/list`, method: 'GET', signal }, options);
};

export const getGetCourse1QueryKey = () => {
  return [`/file/v1/course/list`] as const;
};

export const getGetCourse1QueryOptions = <TData = Awaited<ReturnType<typeof getCourse1>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCourse1>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCourse1QueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCourse1>>> = ({ signal }) =>
    getCourse1(requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getCourse1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetCourse1QueryResult = NonNullable<Awaited<ReturnType<typeof getCourse1>>>;
export type GetCourse1QueryError = unknown;

export function useGetCourse1<TData = Awaited<ReturnType<typeof getCourse1>>, TError = unknown>(options: {
  query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCourse1>>, TError, TData>> &
    Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getCourse1>>, TError, TData>, 'initialData'>;
  request?: SecondParameter<typeof customFetcher>;
}): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetCourse1<TData = Awaited<ReturnType<typeof getCourse1>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCourse1>>, TError, TData>> &
    Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getCourse1>>, TError, TData>, 'initialData'>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetCourse1<TData = Awaited<ReturnType<typeof getCourse1>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCourse1>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ë“±ë¡ëœ ê³¼ì • ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ
 */

export function useGetCourse1<TData = Awaited<ReturnType<typeof getCourse1>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCourse1>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetCourse1QueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * í‚¤ì›Œë“œë¡œ ìì‹ ì˜ ìë£Œë¥¼ ê²€ìƒ‰í•©ë‹ˆë‹¤.<br>í‚¤ì›Œë“œë¡œ ê²€ìƒ‰ í›„ ì‚­ì œëœ ìë£Œë‚˜ ë‹¤ë¥¸ í•„í„°ë§ì„ ê±°ì¹˜ê¸° ë•Œë¬¸ì—<br>ì—¬ê¸°ì„œëŠ” offsetSizeWithLimit ì— ë‹¤ë¥¸ ìë£Œì™€ ë‹¤ë¥´ê²Œ í˜ì´ì§€ìˆ˜ê°€ ì•„ë‹Œ ì´ì „ ì¡°íšŒì— ì™”ë˜ nextOffsetë¥¼ ë„£ì–´ì£¼ì…”ì•¼í•©ë‹ˆë‹¤.<br>ì‘ë‹µì— nextOffsetê³¼ totalì´ ê°™ìœ¼ë©´ ë”ì´ìƒ ë¡œë“œí•  ê²ƒì´ ì—†ë‹¤ëŠ” ëœ»ì…ë‹ˆë‹¤.
 * @summary ë‚´ ìë£Œ ê²€ìƒ‰
 */
export const searchMyData = (
  params: SearchMyDataParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseSearchListResultSmartFolderItemResult>(
    { url: `/file/v1/common-smart-folder/search`, method: 'GET', params, signal },
    options,
  );
};

export const getSearchMyDataQueryKey = (params: SearchMyDataParams) => {
  return [`/file/v1/common-smart-folder/search`, ...(params ? [params] : [])] as const;
};

export const getSearchMyDataQueryOptions = <TData = Awaited<ReturnType<typeof searchMyData>>, TError = unknown>(
  params: SearchMyDataParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchMyData>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSearchMyDataQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof searchMyData>>> = ({ signal }) =>
    searchMyData(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof searchMyData>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type SearchMyDataQueryResult = NonNullable<Awaited<ReturnType<typeof searchMyData>>>;
export type SearchMyDataQueryError = unknown;

export function useSearchMyData<TData = Awaited<ReturnType<typeof searchMyData>>, TError = unknown>(
  params: SearchMyDataParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchMyData>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof searchMyData>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useSearchMyData<TData = Awaited<ReturnType<typeof searchMyData>>, TError = unknown>(
  params: SearchMyDataParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchMyData>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof searchMyData>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useSearchMyData<TData = Awaited<ReturnType<typeof searchMyData>>, TError = unknown>(
  params: SearchMyDataParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchMyData>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ë‚´ ìë£Œ ê²€ìƒ‰
 */

export function useSearchMyData<TData = Awaited<ReturnType<typeof searchMyData>>, TError = unknown>(
  params: SearchMyDataParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchMyData>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getSearchMyDataQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * í•™ìƒê³¼ ê´€ë ¨ëœ ìë£Œë¥¼ ê²€ìƒ‰í•˜ëŠ” apiì…ë‹ˆë‹¤. ê¸°ë³¸ì ìœ¼ë¡œ ê´€ì°°ê¸°ë¡ ì‘ì„± í•˜ë‹¨ì— ìë£Œ ë¦¬ìŠ¤íŠ¸ì—ì„œ ì´ê±° ì‚¬ìš©í•´ì£¼ì„¸ìš”.
 * @summary í•™ìƒê³¼ ê´€ë ¨ëœ ìë£Œ ê²€ìƒ‰
 */
export const searchStudentData = (
  params: SearchStudentDataParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/file/v1/common-smart-folder/search-student-item-list`, method: 'GET', params, signal },
    options,
  );
};

export const getSearchStudentDataQueryKey = (params: SearchStudentDataParams) => {
  return [`/file/v1/common-smart-folder/search-student-item-list`, ...(params ? [params] : [])] as const;
};

export const getSearchStudentDataQueryOptions = <
  TData = Awaited<ReturnType<typeof searchStudentData>>,
  TError = unknown,
>(
  params: SearchStudentDataParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchStudentData>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSearchStudentDataQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof searchStudentData>>> = ({ signal }) =>
    searchStudentData(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof searchStudentData>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type SearchStudentDataQueryResult = NonNullable<Awaited<ReturnType<typeof searchStudentData>>>;
export type SearchStudentDataQueryError = unknown;

export function useSearchStudentData<TData = Awaited<ReturnType<typeof searchStudentData>>, TError = unknown>(
  params: SearchStudentDataParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchStudentData>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof searchStudentData>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useSearchStudentData<TData = Awaited<ReturnType<typeof searchStudentData>>, TError = unknown>(
  params: SearchStudentDataParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchStudentData>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof searchStudentData>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useSearchStudentData<TData = Awaited<ReturnType<typeof searchStudentData>>, TError = unknown>(
  params: SearchStudentDataParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchStudentData>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary í•™ìƒê³¼ ê´€ë ¨ëœ ìë£Œ ê²€ìƒ‰
 */

export function useSearchStudentData<TData = Awaited<ReturnType<typeof searchStudentData>>, TError = unknown>(
  params: SearchStudentDataParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchStudentData>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getSearchStudentDataQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ìë£Œ idë¥¼ ì´ìš©í•´ì„œ ìë£Œì˜ ê³µê°œ ìƒíƒœ ë° ê³µìœ ì½”ë“œë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary ìë£Œì˜ ê³µê°œ ìƒíƒœë¥¼ í™•ì¸í•˜ëŠ” api(ê³µê°œê´€ë¦¬ íŒì—…ì°½ ì—´ ë•Œ í˜¸ì¶œ)
 */
export const getPublicUrlItemCode = (
  params: GetPublicUrlItemCodeParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponsePublicUrlItemCodeResult>(
    { url: `/file/v1/common-smart-folder/public-url-code`, method: 'GET', params, signal },
    options,
  );
};

export const getGetPublicUrlItemCodeQueryKey = (params: GetPublicUrlItemCodeParams) => {
  return [`/file/v1/common-smart-folder/public-url-code`, ...(params ? [params] : [])] as const;
};

export const getGetPublicUrlItemCodeQueryOptions = <
  TData = Awaited<ReturnType<typeof getPublicUrlItemCode>>,
  TError = unknown,
>(
  params: GetPublicUrlItemCodeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicUrlItemCode>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPublicUrlItemCodeQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPublicUrlItemCode>>> = ({ signal }) =>
    getPublicUrlItemCode(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPublicUrlItemCode>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetPublicUrlItemCodeQueryResult = NonNullable<Awaited<ReturnType<typeof getPublicUrlItemCode>>>;
export type GetPublicUrlItemCodeQueryError = unknown;

export function useGetPublicUrlItemCode<TData = Awaited<ReturnType<typeof getPublicUrlItemCode>>, TError = unknown>(
  params: GetPublicUrlItemCodeParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicUrlItemCode>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getPublicUrlItemCode>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetPublicUrlItemCode<TData = Awaited<ReturnType<typeof getPublicUrlItemCode>>, TError = unknown>(
  params: GetPublicUrlItemCodeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicUrlItemCode>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getPublicUrlItemCode>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetPublicUrlItemCode<TData = Awaited<ReturnType<typeof getPublicUrlItemCode>>, TError = unknown>(
  params: GetPublicUrlItemCodeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicUrlItemCode>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ìë£Œì˜ ê³µê°œ ìƒíƒœë¥¼ í™•ì¸í•˜ëŠ” api(ê³µê°œê´€ë¦¬ íŒì—…ì°½ ì—´ ë•Œ í˜¸ì¶œ)
 */

export function useGetPublicUrlItemCode<TData = Awaited<ReturnType<typeof getPublicUrlItemCode>>, TError = unknown>(
  params: GetPublicUrlItemCodeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicUrlItemCode>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetPublicUrlItemCodeQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ìë£Œë³´ë“œì˜ ìë£Œ idë¥¼ ì´ìš©í•´ì„œ ìë£Œì˜ ê²½ë¡œë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.(ë¹µë¿Œì‹œë˜ê¸° í‘œì‹œìš©)
 * @summary íŒŒì¼ì˜ í´ë” ê²½ë¡œë¥¼ ì¡°íšŒí•˜ëŠ” api
 */
export const getItemPathTree = (
  params: GetItemPathTreeParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseSmartFolderTreeResult>(
    { url: `/file/v1/common-smart-folder/path-tree`, method: 'GET', params, signal },
    options,
  );
};

export const getGetItemPathTreeQueryKey = (params: GetItemPathTreeParams) => {
  return [`/file/v1/common-smart-folder/path-tree`, ...(params ? [params] : [])] as const;
};

export const getGetItemPathTreeQueryOptions = <TData = Awaited<ReturnType<typeof getItemPathTree>>, TError = unknown>(
  params: GetItemPathTreeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemPathTree>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetItemPathTreeQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemPathTree>>> = ({ signal }) =>
    getItemPathTree(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getItemPathTree>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetItemPathTreeQueryResult = NonNullable<Awaited<ReturnType<typeof getItemPathTree>>>;
export type GetItemPathTreeQueryError = unknown;

export function useGetItemPathTree<TData = Awaited<ReturnType<typeof getItemPathTree>>, TError = unknown>(
  params: GetItemPathTreeParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemPathTree>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getItemPathTree>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetItemPathTree<TData = Awaited<ReturnType<typeof getItemPathTree>>, TError = unknown>(
  params: GetItemPathTreeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemPathTree>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getItemPathTree>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetItemPathTree<TData = Awaited<ReturnType<typeof getItemPathTree>>, TError = unknown>(
  params: GetItemPathTreeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemPathTree>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary íŒŒì¼ì˜ í´ë” ê²½ë¡œë¥¼ ì¡°íšŒí•˜ëŠ” api
 */

export function useGetItemPathTree<TData = Awaited<ReturnType<typeof getItemPathTree>>, TError = unknown>(
  params: GetItemPathTreeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemPathTree>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetItemPathTreeQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ìë£Œë³´ë“œ ë©”ì¸í™”ë©´ SNBì˜ ê³µê°œìë£Œë¥¼ ì¡°íšŒí•˜ëŠ” api ì…ë‹ˆë‹¤.
 * @summary ë‚˜ì˜ ê³µê°œëœ ìë£Œ ë¦¬ìŠ¤íŠ¸ë¥¼ ì¡°íšŒí•˜ëŠ” api
 */
export const getPublicItemForMyList = (
  params?: GetPublicItemForMyListParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/file/v1/common-smart-folder/my-public-item-list`, method: 'GET', params, signal },
    options,
  );
};

export const getGetPublicItemForMyListQueryKey = (params?: GetPublicItemForMyListParams) => {
  return [`/file/v1/common-smart-folder/my-public-item-list`, ...(params ? [params] : [])] as const;
};

export const getGetPublicItemForMyListQueryOptions = <
  TData = Awaited<ReturnType<typeof getPublicItemForMyList>>,
  TError = unknown,
>(
  params?: GetPublicItemForMyListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicItemForMyList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPublicItemForMyListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPublicItemForMyList>>> = ({ signal }) =>
    getPublicItemForMyList(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPublicItemForMyList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetPublicItemForMyListQueryResult = NonNullable<Awaited<ReturnType<typeof getPublicItemForMyList>>>;
export type GetPublicItemForMyListQueryError = unknown;

export function useGetPublicItemForMyList<TData = Awaited<ReturnType<typeof getPublicItemForMyList>>, TError = unknown>(
  params: undefined | GetPublicItemForMyListParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicItemForMyList>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getPublicItemForMyList>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetPublicItemForMyList<TData = Awaited<ReturnType<typeof getPublicItemForMyList>>, TError = unknown>(
  params?: GetPublicItemForMyListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicItemForMyList>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getPublicItemForMyList>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetPublicItemForMyList<TData = Awaited<ReturnType<typeof getPublicItemForMyList>>, TError = unknown>(
  params?: GetPublicItemForMyListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicItemForMyList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ë‚˜ì˜ ê³µê°œëœ ìë£Œ ë¦¬ìŠ¤íŠ¸ë¥¼ ì¡°íšŒí•˜ëŠ” api
 */

export function useGetPublicItemForMyList<TData = Awaited<ReturnType<typeof getPublicItemForMyList>>, TError = unknown>(
  params?: GetPublicItemForMyListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicItemForMyList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetPublicItemForMyListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ì‚¬ìš©ìì˜ í”„ë¡œí•„ idì™€ íŠ¹ì •í´ë” idë¡œ í´ë” ì•„ë˜ì˜ ìë£Œ ëª©ë¡ì„ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary ìë£Œë³´ë“œì˜ í•˜ìœ„ í´ë”ì˜ ìë£Œ ëª©ë¡ ì¡°íšŒ
 */
export const getItemList = (
  params?: GetItemListParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/file/v1/common-smart-folder/item-list`, method: 'GET', params, signal },
    options,
  );
};

export const getGetItemListQueryKey = (params?: GetItemListParams) => {
  return [`/file/v1/common-smart-folder/item-list`, ...(params ? [params] : [])] as const;
};

export const getGetItemListQueryOptions = <TData = Awaited<ReturnType<typeof getItemList>>, TError = unknown>(
  params?: GetItemListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetItemListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemList>>> = ({ signal }) =>
    getItemList(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getItemList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetItemListQueryResult = NonNullable<Awaited<ReturnType<typeof getItemList>>>;
export type GetItemListQueryError = unknown;

export function useGetItemList<TData = Awaited<ReturnType<typeof getItemList>>, TError = unknown>(
  params: undefined | GetItemListParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemList>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getItemList>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetItemList<TData = Awaited<ReturnType<typeof getItemList>>, TError = unknown>(
  params?: GetItemListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemList>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getItemList>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetItemList<TData = Awaited<ReturnType<typeof getItemList>>, TError = unknown>(
  params?: GetItemListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ìë£Œë³´ë“œì˜ í•˜ìœ„ í´ë”ì˜ ìë£Œ ëª©ë¡ ì¡°íšŒ
 */

export function useGetItemList<TData = Awaited<ReturnType<typeof getItemList>>, TError = unknown>(
  params?: GetItemListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetItemListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ì‚¬ìš©ìì˜ í”„ë¡œí•„ idì™€ íŠ¹ì • í´ë”ê°€ ìˆë‹¤ë©´ íŠ¹ì •í´ë” idë¡œ í´ë” ëª©ë¡ì„ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary ìë£Œë³´ë“œì˜ í•˜ìœ„ í´ë” ëª©ë¡ ë° ì‚¬ìš©ìê°€ ë§Œë“  í´ë” ëª©ë¡ ì¡°íšŒ
 */
export const getFolders = (
  params?: GetFoldersParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderResult>(
    { url: `/file/v1/common-smart-folder/folder-list`, method: 'GET', params, signal },
    options,
  );
};

export const getGetFoldersQueryKey = (params?: GetFoldersParams) => {
  return [`/file/v1/common-smart-folder/folder-list`, ...(params ? [params] : [])] as const;
};

export const getGetFoldersQueryOptions = <TData = Awaited<ReturnType<typeof getFolders>>, TError = unknown>(
  params?: GetFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetFoldersQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFolders>>> = ({ signal }) =>
    getFolders(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getFolders>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetFoldersQueryResult = NonNullable<Awaited<ReturnType<typeof getFolders>>>;
export type GetFoldersQueryError = unknown;

export function useGetFolders<TData = Awaited<ReturnType<typeof getFolders>>, TError = unknown>(
  params: undefined | GetFoldersParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFolders>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getFolders>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetFolders<TData = Awaited<ReturnType<typeof getFolders>>, TError = unknown>(
  params?: GetFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFolders>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getFolders>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetFolders<TData = Awaited<ReturnType<typeof getFolders>>, TError = unknown>(
  params?: GetFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ìë£Œë³´ë“œì˜ í•˜ìœ„ í´ë” ëª©ë¡ ë° ì‚¬ìš©ìê°€ ë§Œë“  í´ë” ëª©ë¡ ì¡°íšŒ
 */

export function useGetFolders<TData = Awaited<ReturnType<typeof getFolders>>, TError = unknown>(
  params?: GetFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetFoldersQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ìë£Œë³´ë“œì˜ ìë£Œ idë¥¼ ì´ìš©í•´ì„œ ìë£Œì˜ ê²½ë¡œë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.(ë¹µë¿Œì‹œë˜ê¸° í‘œì‹œìš©)
 * @summary íŒŒì¼ì˜ í´ë” ê²½ë¡œë¥¼ ì¡°íšŒí•˜ëŠ” api
 */
export const getItemFlatPathTree = (
  params: GetItemFlatPathTreeParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderTreeResult>(
    { url: `/file/v1/common-smart-folder/flat-path-tree`, method: 'GET', params, signal },
    options,
  );
};

export const getGetItemFlatPathTreeQueryKey = (params: GetItemFlatPathTreeParams) => {
  return [`/file/v1/common-smart-folder/flat-path-tree`, ...(params ? [params] : [])] as const;
};

export const getGetItemFlatPathTreeQueryOptions = <
  TData = Awaited<ReturnType<typeof getItemFlatPathTree>>,
  TError = unknown,
>(
  params: GetItemFlatPathTreeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemFlatPathTree>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetItemFlatPathTreeQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemFlatPathTree>>> = ({ signal }) =>
    getItemFlatPathTree(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getItemFlatPathTree>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetItemFlatPathTreeQueryResult = NonNullable<Awaited<ReturnType<typeof getItemFlatPathTree>>>;
export type GetItemFlatPathTreeQueryError = unknown;

export function useGetItemFlatPathTree<TData = Awaited<ReturnType<typeof getItemFlatPathTree>>, TError = unknown>(
  params: GetItemFlatPathTreeParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemFlatPathTree>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getItemFlatPathTree>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetItemFlatPathTree<TData = Awaited<ReturnType<typeof getItemFlatPathTree>>, TError = unknown>(
  params: GetItemFlatPathTreeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemFlatPathTree>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getItemFlatPathTree>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetItemFlatPathTree<TData = Awaited<ReturnType<typeof getItemFlatPathTree>>, TError = unknown>(
  params: GetItemFlatPathTreeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemFlatPathTree>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary íŒŒì¼ì˜ í´ë” ê²½ë¡œë¥¼ ì¡°íšŒí•˜ëŠ” api
 */

export function useGetItemFlatPathTree<TData = Awaited<ReturnType<typeof getItemFlatPathTree>>, TError = unknown>(
  params: GetItemFlatPathTreeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemFlatPathTree>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetItemFlatPathTreeQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ë‹¤ìš´ë°›ê¸° ìš”ì²­ì„ ìœ„í•´ì„œ í´ë” í•˜ìœ„ì˜ ìë£Œí‚¤ ë¦¬ìŠ¤íŠ¸ë¥¼ ìš”ì²­í•©ë‹ˆë‹¤.
 * @summary ìš”ì²­í•œ í´ë” í•˜ìœ„ì˜ ìë£Œ í‚¤ ëª©ë¡ ì¡°íšŒ(í´ë” ë‹¤ìš´ë¡œë“œìš©)
 */
export const getItemKeyList = (
  params: GetItemKeyListParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListString>(
    { url: `/file/v1/common-smart-folder/drive-key-list`, method: 'GET', params, signal },
    options,
  );
};

export const getGetItemKeyListQueryKey = (params: GetItemKeyListParams) => {
  return [`/file/v1/common-smart-folder/drive-key-list`, ...(params ? [params] : [])] as const;
};

export const getGetItemKeyListQueryOptions = <TData = Awaited<ReturnType<typeof getItemKeyList>>, TError = unknown>(
  params: GetItemKeyListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemKeyList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetItemKeyListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemKeyList>>> = ({ signal }) =>
    getItemKeyList(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getItemKeyList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetItemKeyListQueryResult = NonNullable<Awaited<ReturnType<typeof getItemKeyList>>>;
export type GetItemKeyListQueryError = unknown;

export function useGetItemKeyList<TData = Awaited<ReturnType<typeof getItemKeyList>>, TError = unknown>(
  params: GetItemKeyListParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemKeyList>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getItemKeyList>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetItemKeyList<TData = Awaited<ReturnType<typeof getItemKeyList>>, TError = unknown>(
  params: GetItemKeyListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemKeyList>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getItemKeyList>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetItemKeyList<TData = Awaited<ReturnType<typeof getItemKeyList>>, TError = unknown>(
  params: GetItemKeyListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemKeyList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ìš”ì²­í•œ í´ë” í•˜ìœ„ì˜ ìë£Œ í‚¤ ëª©ë¡ ì¡°íšŒ(í´ë” ë‹¤ìš´ë¡œë“œìš©)
 */

export function useGetItemKeyList<TData = Awaited<ReturnType<typeof getItemKeyList>>, TError = unknown>(
  params: GetItemKeyListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemKeyList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetItemKeyListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ìë£Œë³´ë“œì˜ ìë£Œ idë¥¼ ì´ìš©í•´ì„œ ìë£Œì˜ ì„¸ë¶€ì •ë³´ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary íŒŒì¼ì˜ ìƒì„¸ë³´ê¸° êµ¬í˜„ì„ ìœ„í•´ ì¡°íšŒí•˜ëŠ” api
 */
export const getSmartFolderItem1 = (
  params: GetSmartFolderItem1Params,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseSmartFolderItemDetailedResult>(
    { url: `/file/v1/common-smart-folder/detailed-info`, method: 'GET', params, signal },
    options,
  );
};

export const getGetSmartFolderItem1QueryKey = (params: GetSmartFolderItem1Params) => {
  return [`/file/v1/common-smart-folder/detailed-info`, ...(params ? [params] : [])] as const;
};

export const getGetSmartFolderItem1QueryOptions = <
  TData = Awaited<ReturnType<typeof getSmartFolderItem1>>,
  TError = unknown,
>(
  params: GetSmartFolderItem1Params,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItem1>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSmartFolderItem1QueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSmartFolderItem1>>> = ({ signal }) =>
    getSmartFolderItem1(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSmartFolderItem1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetSmartFolderItem1QueryResult = NonNullable<Awaited<ReturnType<typeof getSmartFolderItem1>>>;
export type GetSmartFolderItem1QueryError = unknown;

export function useGetSmartFolderItem1<TData = Awaited<ReturnType<typeof getSmartFolderItem1>>, TError = unknown>(
  params: GetSmartFolderItem1Params,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItem1>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getSmartFolderItem1>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetSmartFolderItem1<TData = Awaited<ReturnType<typeof getSmartFolderItem1>>, TError = unknown>(
  params: GetSmartFolderItem1Params,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItem1>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getSmartFolderItem1>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetSmartFolderItem1<TData = Awaited<ReturnType<typeof getSmartFolderItem1>>, TError = unknown>(
  params: GetSmartFolderItem1Params,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItem1>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary íŒŒì¼ì˜ ìƒì„¸ë³´ê¸° êµ¬í˜„ì„ ìœ„í•´ ì¡°íšŒí•˜ëŠ” api
 */

export function useGetSmartFolderItem1<TData = Awaited<ReturnType<typeof getSmartFolderItem1>>, TError = unknown>(
  params: GetSmartFolderItem1Params,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItem1>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetSmartFolderItem1QueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const removeFromService = (
  trashcanRequest: TrashcanRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseString>(
    {
      url: `/file/v1/trashcan/remove-from-service`,
      method: 'DELETE',
      headers: { 'Content-Type': 'application/json' },
      data: trashcanRequest,
    },
    options,
  );
};

export const getRemoveFromServiceMutationOptions = <
  TData = Awaited<ReturnType<typeof removeFromService>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: TrashcanRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['removeFromService'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeFromService>>, { data: TrashcanRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return removeFromService(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError, { data: TrashcanRequest }, TContext>;
};

export type RemoveFromServiceMutationResult = NonNullable<Awaited<ReturnType<typeof removeFromService>>>;
export type RemoveFromServiceMutationBody = TrashcanRequest;
export type RemoveFromServiceMutationError = unknown;

export const useRemoveFromService = <
  TData = Awaited<ReturnType<typeof removeFromService>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: TrashcanRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: TrashcanRequest }, TContext> => {
  const mutationOptions = getRemoveFromServiceMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ì¶”ì²œ í‚¤ì›Œë“œ ì •ë³´ë¥¼ ì‚­ì œí•©ë‹ˆë‹¤.
 * @summary ì¶”ì²œ í‚¤ì›Œë“œ ì •ë³´ ì‚­ì œ
 */
export const deleteRecommendationKeywordInfo = (
  id: string,
  params: DeleteRecommendationKeywordInfoParams,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseString>(
    { url: `/file/v1/recommendation/common-keywords/${id}/delete`, method: 'DELETE', params },
    options,
  );
};

export const getDeleteRecommendationKeywordInfoMutationOptions = <
  TData = Awaited<ReturnType<typeof deleteRecommendationKeywordInfo>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { id: string; params: DeleteRecommendationKeywordInfoParams }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['deleteRecommendationKeywordInfo'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteRecommendationKeywordInfo>>,
    { id: string; params: DeleteRecommendationKeywordInfoParams }
  > = (props) => {
    const { id, params } = props ?? {};

    return deleteRecommendationKeywordInfo(id, params, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { id: string; params: DeleteRecommendationKeywordInfoParams },
    TContext
  >;
};

export type DeleteRecommendationKeywordInfoMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteRecommendationKeywordInfo>>
>;

export type DeleteRecommendationKeywordInfoMutationError = unknown;

/**
 * @summary ì¶”ì²œ í‚¤ì›Œë“œ ì •ë³´ ì‚­ì œ
 */
export const useDeleteRecommendationKeywordInfo = <
  TData = Awaited<ReturnType<typeof deleteRecommendationKeywordInfo>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { id: string; params: DeleteRecommendationKeywordInfoParams }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { id: string; params: DeleteRecommendationKeywordInfoParams }, TContext> => {
  const mutationOptions = getDeleteRecommendationKeywordInfoMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ìš”ì²­ ìë£Œë“¤ì„ í•´ë‹¹ í´ë”ì—ì„œ ì œì™¸ ì‹œí‚µë‹ˆë‹¤.
 * @summary ë‚´ í´ë”ì—ì„œ ìë£Œ ì œì™¸(ë‚´ í´ë”ì˜ id)
 */
export const removeItem = (
  smartFolderItemid: string,
  removeSmartFolderItemWithIdRequest: RemoveSmartFolderItemWithIdRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseString>(
    {
      url: `/file/v1/my-folder/${smartFolderItemid}/remove-items`,
      method: 'DELETE',
      headers: { 'Content-Type': 'application/json' },
      data: removeSmartFolderItemWithIdRequest,
    },
    options,
  );
};

export const getRemoveItemMutationOptions = <
  TData = Awaited<ReturnType<typeof removeItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { smartFolderItemid: string; data: RemoveSmartFolderItemWithIdRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['removeItem'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeItem>>,
    { smartFolderItemid: string; data: RemoveSmartFolderItemWithIdRequest }
  > = (props) => {
    const { smartFolderItemid, data } = props ?? {};

    return removeItem(smartFolderItemid, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { smartFolderItemid: string; data: RemoveSmartFolderItemWithIdRequest },
    TContext
  >;
};

export type RemoveItemMutationResult = NonNullable<Awaited<ReturnType<typeof removeItem>>>;
export type RemoveItemMutationBody = RemoveSmartFolderItemWithIdRequest;
export type RemoveItemMutationError = unknown;

/**
 * @summary ë‚´ í´ë”ì—ì„œ ìë£Œ ì œì™¸(ë‚´ í´ë”ì˜ id)
 */
export const useRemoveItem = <
  TData = Awaited<ReturnType<typeof removeItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { smartFolderItemid: string; data: RemoveSmartFolderItemWithIdRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<
  TData,
  TError,
  { smartFolderItemid: string; data: RemoveSmartFolderItemWithIdRequest },
  TContext
> => {
  const mutationOptions = getRemoveItemMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ìš”ì²­ ìë£Œë“¤ì„ í•´ë‹¹ í´ë”ì—ì„œ ì œì™¸ ì‹œí‚µë‹ˆë‹¤.
 * @summary ë‚´ í´ë”ì—ì„œ ìë£Œ ì œì™¸(ìë£Œ í‚¤)
 */
export const removeDriveItem = (
  smartFolderItemid: string,
  removeDriveItemFromMyFolderWithKeyRequest: RemoveDriveItemFromMyFolderWithKeyRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseString>(
    {
      url: `/file/v1/my-folder/${smartFolderItemid}/remove-drive-items`,
      method: 'DELETE',
      headers: { 'Content-Type': 'application/json' },
      data: removeDriveItemFromMyFolderWithKeyRequest,
    },
    options,
  );
};

export const getRemoveDriveItemMutationOptions = <
  TData = Awaited<ReturnType<typeof removeDriveItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { smartFolderItemid: string; data: RemoveDriveItemFromMyFolderWithKeyRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['removeDriveItem'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeDriveItem>>,
    { smartFolderItemid: string; data: RemoveDriveItemFromMyFolderWithKeyRequest }
  > = (props) => {
    const { smartFolderItemid, data } = props ?? {};

    return removeDriveItem(smartFolderItemid, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { smartFolderItemid: string; data: RemoveDriveItemFromMyFolderWithKeyRequest },
    TContext
  >;
};

export type RemoveDriveItemMutationResult = NonNullable<Awaited<ReturnType<typeof removeDriveItem>>>;
export type RemoveDriveItemMutationBody = RemoveDriveItemFromMyFolderWithKeyRequest;
export type RemoveDriveItemMutationError = unknown;

/**
 * @summary ë‚´ í´ë”ì—ì„œ ìë£Œ ì œì™¸(ìë£Œ í‚¤)
 */
export const useRemoveDriveItem = <
  TData = Awaited<ReturnType<typeof removeDriveItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { smartFolderItemid: string; data: RemoveDriveItemFromMyFolderWithKeyRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<
  TData,
  TError,
  { smartFolderItemid: string; data: RemoveDriveItemFromMyFolderWithKeyRequest },
  TContext
> => {
  const mutationOptions = getRemoveDriveItemMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ìš”ì²­ ìë£Œë¥¼ íœ´ì§€í†µìœ¼ë¡œ ì´ë™í•©ë‹ˆë‹¤. ì‹¤ì œ ë¬¼ë¦¬ì  ìë£Œë§Œ ì´ë™í•©ë‹ˆë‹¤.
 * @summary ìë£Œë¥¼ íœ´ì§€í†µìœ¼ë¡œ ì´ë™ (íœ´ì§€í†µ ê´€ë ¨ ì •ì±… ì •í•´ì§€ë©´ ê°œë°œ ì˜ˆì •)
 */
export const moveItemToTrash = (
  moveItemToTrashRequest: MoveItemToTrashRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseString>(
    {
      url: `/file/v1/my-folder/move-to-trash`,
      method: 'DELETE',
      headers: { 'Content-Type': 'application/json' },
      data: moveItemToTrashRequest,
    },
    options,
  );
};

export const getMoveItemToTrashMutationOptions = <
  TData = Awaited<ReturnType<typeof moveItemToTrash>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MoveItemToTrashRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['moveItemToTrash'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof moveItemToTrash>>, { data: MoveItemToTrashRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return moveItemToTrash(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: MoveItemToTrashRequest },
    TContext
  >;
};

export type MoveItemToTrashMutationResult = NonNullable<Awaited<ReturnType<typeof moveItemToTrash>>>;
export type MoveItemToTrashMutationBody = MoveItemToTrashRequest;
export type MoveItemToTrashMutationError = unknown;

/**
 * @summary ìë£Œë¥¼ íœ´ì§€í†µìœ¼ë¡œ ì´ë™ (íœ´ì§€í†µ ê´€ë ¨ ì •ì±… ì •í•´ì§€ë©´ ê°œë°œ ì˜ˆì •)
 */
export const useMoveItemToTrash = <
  TData = Awaited<ReturnType<typeof moveItemToTrash>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MoveItemToTrashRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: MoveItemToTrashRequest }, TContext> => {
  const mutationOptions = getMoveItemToTrashMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ë³´ì—¬ì£¼ë˜ ìë£Œë¥¼ ì œê±°í•©ë‹ˆë‹¤. ìë£Œì˜ ê³µê°œ ìƒíƒœì— ë”°ë¼ ì¹´ìš´íŠ¸í•˜ë˜ ìˆ«ìë“¤ë„ ì œì™¸ì‹œí‚µë‹ˆë‹¤.
 * @summary ë§ˆì´ë³´ë“œì—ì„œ ìë£Œë¥¼ ì œê±° í•©ë‹ˆë‹¤.
 */
export const deleteItems = (
  profileId: string,
  deleteMyBoardItemRequest: DeleteMyBoardItemRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseString>(
    {
      url: `/file/v1/my-board/${profileId}/delete`,
      method: 'DELETE',
      headers: { 'Content-Type': 'application/json' },
      data: deleteMyBoardItemRequest,
    },
    options,
  );
};

export const getDeleteItemsMutationOptions = <
  TData = Awaited<ReturnType<typeof deleteItems>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { profileId: string; data: DeleteMyBoardItemRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['deleteItems'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteItems>>,
    { profileId: string; data: DeleteMyBoardItemRequest }
  > = (props) => {
    const { profileId, data } = props ?? {};

    return deleteItems(profileId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { profileId: string; data: DeleteMyBoardItemRequest },
    TContext
  >;
};

export type DeleteItemsMutationResult = NonNullable<Awaited<ReturnType<typeof deleteItems>>>;
export type DeleteItemsMutationBody = DeleteMyBoardItemRequest;
export type DeleteItemsMutationError = unknown;

/**
 * @summary ë§ˆì´ë³´ë“œì—ì„œ ìë£Œë¥¼ ì œê±° í•©ë‹ˆë‹¤.
 */
export const useDeleteItems = <
  TData = Awaited<ReturnType<typeof deleteItems>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { profileId: string; data: DeleteMyBoardItemRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { profileId: string; data: DeleteMyBoardItemRequest }, TContext> => {
  const mutationOptions = getDeleteItemsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ìš”ì²­ ìë£Œë¥¼ íœ´ì§€í†µìœ¼ë¡œ ì´ë™í•©ë‹ˆë‹¤.
 * @summary ìë£Œë¥¼ íœ´ì§€í†µìœ¼ë¡œ ì´ë™
 */
export const moveItemToTrash1 = (trashcanRequest: TrashcanRequest, options?: SecondParameter<typeof customFetcher>) => {
  return customFetcher<ApiResponseString>(
    {
      url: `/file/v1/common-smart-folder/move-to-trash`,
      method: 'DELETE',
      headers: { 'Content-Type': 'application/json' },
      data: trashcanRequest,
    },
    options,
  );
};

export const getMoveItemToTrash1MutationOptions = <
  TData = Awaited<ReturnType<typeof moveItemToTrash1>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: TrashcanRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['moveItemToTrash1'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof moveItemToTrash1>>, { data: TrashcanRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return moveItemToTrash1(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError, { data: TrashcanRequest }, TContext>;
};

export type MoveItemToTrash1MutationResult = NonNullable<Awaited<ReturnType<typeof moveItemToTrash1>>>;
export type MoveItemToTrash1MutationBody = TrashcanRequest;
export type MoveItemToTrash1MutationError = unknown;

/**
 * @summary ìë£Œë¥¼ íœ´ì§€í†µìœ¼ë¡œ ì´ë™
 */
export const useMoveItemToTrash1 = <
  TData = Awaited<ReturnType<typeof moveItemToTrash1>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: TrashcanRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: TrashcanRequest }, TContext> => {
  const mutationOptions = getMoveItemToTrash1MutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ìš”ì²­ ìë£Œë¥¼ í•´ë‹¹ í´ë”ì—ì„œ ë³´ì´ì§€ ì•Šê²Œ í•©ë‹ˆë‹¤.(í˜¹ì€ ì œì™¸) ë‚´ í´ë”ì—ì„  ì‚­ì œí•˜ê³ , ìŠ¤ë§ˆíŠ¸í´ë”ì—ì„œëŠ” ìˆ¨ê¹€ì²˜ë¦¬ë¥¼ í•©ë‹ˆë‹¤.
 * @summary ìë£Œë¥¼ í•´ë‹¹ í´ë”ì—ì„œ ìˆ¨ê¸°ê¸°(ë” ì´ìƒ ë³´ì§€ì•Šê¸°)
 */
export const hideItems = (
  commonHideItemRequest: CommonHideItemRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseString>(
    {
      url: `/file/v1/common-smart-folder/hide`,
      method: 'DELETE',
      headers: { 'Content-Type': 'application/json' },
      data: commonHideItemRequest,
    },
    options,
  );
};

export const getHideItemsMutationOptions = <
  TData = Awaited<ReturnType<typeof hideItems>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CommonHideItemRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['hideItems'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof hideItems>>, { data: CommonHideItemRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return hideItems(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: CommonHideItemRequest },
    TContext
  >;
};

export type HideItemsMutationResult = NonNullable<Awaited<ReturnType<typeof hideItems>>>;
export type HideItemsMutationBody = CommonHideItemRequest;
export type HideItemsMutationError = unknown;

/**
 * @summary ìë£Œë¥¼ í•´ë‹¹ í´ë”ì—ì„œ ìˆ¨ê¸°ê¸°(ë” ì´ìƒ ë³´ì§€ì•Šê¸°)
 */
export const useHideItems = <
  TData = Awaited<ReturnType<typeof hideItems>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CommonHideItemRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: CommonHideItemRequest }, TContext> => {
  const mutationOptions = getHideItemsMutationOptions(options);

  return useMutation(mutationOptions);
};
