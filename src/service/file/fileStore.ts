/**
 * Generated by orval v7.4.1 üç∫
 * Do not edit manually.
 * File API
 * isd / kinder board api doc
 * OpenAPI spec version: v1.1.0
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';
import type {
  AddDriveItemToMyBoardRequest,
  AddDriveItemToMyFolderRequest,
  AddDriveItemViewCountRequest,
  AddReplyRequest,
  AddStudentPhotoRequest,
  ApiResponseBoolean,
  ApiResponseCourseResult,
  ApiResponseDriveItemLikeResult,
  ApiResponseDriveItemMemoResult,
  ApiResponseDriveItemResult,
  ApiResponseFileObjectSttTextPostResponse,
  ApiResponseImageTaskLogResult,
  ApiResponseInteger,
  ApiResponseLecturePlanResult,
  ApiResponseLecturePlanTermResult,
  ApiResponseLectureReportCardAiCreationLogResult,
  ApiResponseLectureReportResult,
  ApiResponseListCdnFileResult,
  ApiResponseListCourseResult,
  ApiResponseListDriveItemMemoResult,
  ApiResponseListDriveItemResult,
  ApiResponseListFileObjectResult,
  ApiResponseListLecturePlanResult,
  ApiResponseListRecentTaskResult,
  ApiResponseListRecommendationKeywordBundleResult,
  ApiResponseListReplyResult,
  ApiResponseListSmartFolderDocumentItem,
  ApiResponseListSmartFolderItemResult,
  ApiResponseListSmartFolderResult,
  ApiResponseListSmartFolderTreeResult,
  ApiResponseListStoryBoardResult,
  ApiResponseListString,
  ApiResponseListStudentEvaluationDomainResult,
  ApiResponseListStudentEvaluationIndicatorResult,
  ApiResponseListStudentRecordResult,
  ApiResponseMapStringString,
  ApiResponseMyBoardCountsResult,
  ApiResponsePublicUrlItemCodeResult,
  ApiResponsePublicUrlItemDetailedResult,
  ApiResponseRecommendationKeywordBundleResult,
  ApiResponseSearchListResultSmartFolderItemResult,
  ApiResponseSmartFolderItemDetailedResult,
  ApiResponseSmartFolderItemReplyResult,
  ApiResponseSmartFolderItemResult,
  ApiResponseSmartFolderResult,
  ApiResponseSmartFolderTreeResult,
  ApiResponseStorageUsageResult,
  ApiResponseStoryBoardResult,
  ApiResponseString,
  ApiResponseStudentEvaluationIndicatorResult,
  ApiResponseStudentRecordResult,
  CdnFileDownloadRequest,
  CdnFilesForDownloadRequest,
  ChangeLinkedStudentRequest,
  ChangeShareStatePublicItemRequest,
  CheckNotIndexedItems2Params,
  CommonAddDriveItemToSmartFolderRequest,
  CommonAddDriveItemToSmartFolderWithIdRequest,
  CommonChangeShareStateWithDriveItemKeyRequest,
  CommonChangeShareStateWithidRequest,
  CommonHideItemRequest,
  CommonMoveItemRequest,
  CommonRenameRequest,
  CommonUploadCompletedRequest,
  CreateCommonPhotoSmartFolderRequest,
  CreateDocumentSmartFolderRequest,
  CreateMyFolderRequest,
  CreateSmartFolderRequest,
  CreateStudentPhotoFolderRequest,
  DeleteDriveItemMemoParams,
  DeleteMyBoardItemRequest,
  DeleteRecommendationKeywordInfoParams,
  DriveItemAddTagRequest,
  DriveItemChangeThumbnailRequest,
  DriveItemMemoAddRequest,
  DriveItemMemoUpdateRequest,
  DriveItemSttUpdateRequest,
  FileObjectSttTextPostRequest,
  FileObjectThumbUrlsPostRequest,
  FileObjectUploadRequest,
  FindAllPagingReplies1Params,
  FindAllPagingRepliesParams,
  GetActivityFoldersParams,
  GetByIdOrKeyParams,
  GetChildPagingRepliesParams,
  GetCourseParams,
  GetDocsFolderTreeParams,
  GetDocsFoldersParams,
  GetDomainsParams,
  GetDriveItemMemosParams,
  GetFoldersParams,
  GetImageFlatPathParams,
  GetImageRootFolderParams,
  GetImageTaskParams,
  GetIncludedDocsItemsParams,
  GetIncludedItemsDeprecateParams,
  GetIncludedItemsParams,
  GetIncludedPhotoItemsParams,
  GetIndicatorsParams,
  GetItemFlatPathTreeParams,
  GetItemKeyListParams,
  GetItemListParams,
  GetItemPathTreeParams,
  GetLecturePlanListParams,
  GetLecturePlanListWithSearchParams,
  GetLecturePlanParams,
  GetLectureReportParams,
  GetMobileUploadedFilesParams,
  GetMyBoardItemsParams,
  GetMyFolders1Params,
  GetMyFoldersDeprecateParams,
  GetPhotoFolderTreeParams,
  GetPhotoFoldersParams,
  GetPhotoHomeFoldersParams,
  GetPhotosForReportParams,
  GetPublicItem1Params,
  GetPublicItemForMainParams,
  GetPublicItemForMyListParams,
  GetPublicItemParams,
  GetPublicUrlItemCodeParams,
  GetRecentTasksParams,
  GetRecommendItemsParams,
  GetRecommendPlansFromMyItemsParams,
  GetRecommendPlansFromPublicItemsParams,
  GetRecommendPlansParams,
  GetRecommendationKeywordInfoParams,
  GetRecommendationKeywordParams,
  GetReplyAndAttachedItemListParams,
  GetSmartFolderItem1Params,
  GetSmartFolderItemParams,
  GetSmartFolderItemsRecommendPublicItemList1Params,
  GetSmartFolderItemsRecommendPublicItemListParams,
  GetStoryBoardListParams,
  GetStoryBoardParams,
  GetStudentFoldersParams,
  GetStudentPhotoFolderWithStudentIdParams,
  GetStudentRecordHistoryParams,
  GetStudentRecordParams,
  GetTagsStartWithParams,
  GetTermParams,
  GetWidgetFoldersParams,
  ImageTaskLogAddRequest,
  LecturePlanAddRequest,
  LecturePlanUpdateRequest,
  LectureReportAddRequest,
  LectureReportCardAiCreationLogAddRequest,
  LectureReportUpdateRequest,
  MemoFileCreateRequest,
  MemoFileUpdateRequest,
  MoveItemRequest,
  MoveItemToTrashRequest,
  MyBoardChangeShareStateRequest,
  MyBoardRenameRequest,
  ProfileIdAndDriveItemKeyRequest,
  RecommendationKeywordBundleAddRequest,
  RecommendationKeywordBundleUpdateRequest,
  RejectRecommendationItemRequest,
  RemoveDriveItemFromMyFolderWithKeyRequest,
  RemoveSmartFolderItemWithIdRequest,
  RenameRequest,
  ScanMyFoldersParams,
  SearchKeywordAnalizeParams,
  SearchMyBoardDataParams,
  SearchMyDataParams,
  SearchStudentDataParams,
  StorageUsageCreateRequest,
  StoryBoardAddRequest,
  StoryBoardUpdateRequest,
  StudentRecordAddRequest,
  StudentRecordUpdateRequest,
  ToggleHiddenItemRequest,
  ToggleHiddenItemsRequest,
  TrashcanRequest,
  UpdateReplyRequest,
  UpdateTaggedStudentsRequest,
} from './schemas';
import { customFetcher } from '../custom-fetcher';

type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1];

export const restoreItems = (trashcanRequest: TrashcanRequest, options?: SecondParameter<typeof customFetcher>) => {
  return customFetcher<ApiResponseString>(
    {
      url: `/file/v1/trashcan/restore`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: trashcanRequest,
    },
    options,
  );
};

export const getRestoreItemsMutationOptions = <
  TData = Awaited<ReturnType<typeof restoreItems>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: TrashcanRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['restoreItems'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof restoreItems>>, { data: TrashcanRequest }> = (props) => {
    const { data } = props ?? {};

    return restoreItems(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError, { data: TrashcanRequest }, TContext>;
};

export type RestoreItemsMutationResult = NonNullable<Awaited<ReturnType<typeof restoreItems>>>;
export type RestoreItemsMutationBody = TrashcanRequest;
export type RestoreItemsMutationError = unknown;

export const useRestoreItems = <
  TData = Awaited<ReturnType<typeof restoreItems>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: TrashcanRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: TrashcanRequest }, TContext> => {
  const mutationOptions = getRestoreItemsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Í¥ÄÏ∞∞ Í∏∞Î°ùÏùÑ ÏàòÏ†ïÌï©ÎãàÎã§.
 * @summary Í¥ÄÏ∞∞ Í∏∞Î°ù ÏàòÏ†ï
 */
export const updateStudentRecord = (
  studentRecordUpdateRequest: StudentRecordUpdateRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseStudentRecordResult>(
    {
      url: `/file/v1/student-record`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: studentRecordUpdateRequest,
    },
    options,
  );
};

export const getUpdateStudentRecordMutationOptions = <
  TData = Awaited<ReturnType<typeof updateStudentRecord>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: StudentRecordUpdateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['updateStudentRecord'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateStudentRecord>>,
    { data: StudentRecordUpdateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return updateStudentRecord(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: StudentRecordUpdateRequest },
    TContext
  >;
};

export type UpdateStudentRecordMutationResult = NonNullable<Awaited<ReturnType<typeof updateStudentRecord>>>;
export type UpdateStudentRecordMutationBody = StudentRecordUpdateRequest;
export type UpdateStudentRecordMutationError = unknown;

/**
 * @summary Í¥ÄÏ∞∞ Í∏∞Î°ù ÏàòÏ†ï
 */
export const useUpdateStudentRecord = <
  TData = Awaited<ReturnType<typeof updateStudentRecord>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: StudentRecordUpdateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: StudentRecordUpdateRequest }, TContext> => {
  const mutationOptions = getUpdateStudentRecordMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Í¥ÄÏ∞∞ Í∏∞Î°ùÏùÑ Ïã†Í∑úÎ°ú Ï†ÄÏû•Ìï©ÎãàÎã§.
(2025.02.13)teacherAccountId,teacherProfileId -> creatorAccountId, creatorProfileId Î°ú Î≥ÄÍ≤Ω
 * @summary Í¥ÄÏ∞∞ Í∏∞Î°ù Ïã†Í∑ú Ï†ÄÏû•
 */
export const createStudentRecord = (
  studentRecordAddRequest: StudentRecordAddRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseStudentRecordResult>(
    {
      url: `/file/v1/student-record`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: studentRecordAddRequest,
      signal,
    },
    options,
  );
};

export const getCreateStudentRecordMutationOptions = <
  TData = Awaited<ReturnType<typeof createStudentRecord>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: StudentRecordAddRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['createStudentRecord'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createStudentRecord>>,
    { data: StudentRecordAddRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createStudentRecord(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: StudentRecordAddRequest },
    TContext
  >;
};

export type CreateStudentRecordMutationResult = NonNullable<Awaited<ReturnType<typeof createStudentRecord>>>;
export type CreateStudentRecordMutationBody = StudentRecordAddRequest;
export type CreateStudentRecordMutationError = unknown;

/**
 * @summary Í¥ÄÏ∞∞ Í∏∞Î°ù Ïã†Í∑ú Ï†ÄÏû•
 */
export const useCreateStudentRecord = <
  TData = Awaited<ReturnType<typeof createStudentRecord>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: StudentRecordAddRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: StudentRecordAddRequest }, TContext> => {
  const mutationOptions = getCreateStudentRecordMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Í∏∞Ï°¥ Ïä§ÌÜ†Î¶¨Î≥¥ÎìúÏùò ÎÇ¥Ïö©ÏùÑ ÏàòÏ†ïÌï©ÎãàÎã§.
 * @summary Ïä§ÌÜ†Î¶¨Î≥¥Îìú ÏàòÏ†ï
 */
export const updateStoryBoard = (
  storyBoardUpdateRequest: StoryBoardUpdateRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseStoryBoardResult>(
    {
      url: `/file/v1/story-board`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: storyBoardUpdateRequest,
    },
    options,
  );
};

export const getUpdateStoryBoardMutationOptions = <
  TData = Awaited<ReturnType<typeof updateStoryBoard>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: StoryBoardUpdateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['updateStoryBoard'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateStoryBoard>>,
    { data: StoryBoardUpdateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return updateStoryBoard(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: StoryBoardUpdateRequest },
    TContext
  >;
};

export type UpdateStoryBoardMutationResult = NonNullable<Awaited<ReturnType<typeof updateStoryBoard>>>;
export type UpdateStoryBoardMutationBody = StoryBoardUpdateRequest;
export type UpdateStoryBoardMutationError = unknown;

/**
 * @summary Ïä§ÌÜ†Î¶¨Î≥¥Îìú ÏàòÏ†ï
 */
export const useUpdateStoryBoard = <
  TData = Awaited<ReturnType<typeof updateStoryBoard>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: StoryBoardUpdateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: StoryBoardUpdateRequest }, TContext> => {
  const mutationOptions = getUpdateStoryBoardMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Ïä§ÌÜ†Î¶¨Î≥¥ÎìúÎ•º Ïã†Í∑úÎ°ú Ï†ÄÏû•Ìï©ÎãàÎã§.
 * @summary Ïä§ÌÜ†Î¶¨Î≥¥Îìú Ïã†Í∑ú Ï†ÄÏû•
 */
export const createStoryBoard = (
  storyBoardAddRequest: StoryBoardAddRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseStoryBoardResult>(
    {
      url: `/file/v1/story-board`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: storyBoardAddRequest,
      signal,
    },
    options,
  );
};

export const getCreateStoryBoardMutationOptions = <
  TData = Awaited<ReturnType<typeof createStoryBoard>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: StoryBoardAddRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['createStoryBoard'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof createStoryBoard>>, { data: StoryBoardAddRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return createStoryBoard(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: StoryBoardAddRequest },
    TContext
  >;
};

export type CreateStoryBoardMutationResult = NonNullable<Awaited<ReturnType<typeof createStoryBoard>>>;
export type CreateStoryBoardMutationBody = StoryBoardAddRequest;
export type CreateStoryBoardMutationError = unknown;

/**
 * @summary Ïä§ÌÜ†Î¶¨Î≥¥Îìú Ïã†Í∑ú Ï†ÄÏû•
 */
export const useCreateStoryBoard = <
  TData = Awaited<ReturnType<typeof createStoryBoard>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: StoryBoardAddRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: StoryBoardAddRequest }, TContext> => {
  const mutationOptions = getCreateStoryBoardMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏïÑÏù¥ Ìè¥ÎçîÎ•º ÏÇ≠Ï†úÍ∞Ä Í∞ÄÎä•ÌïòÍ≤å Î≥ÄÍ≤ΩÌï©ÎãàÎã§.
 * @summary (ÎÇ¥Î∂Ä ÌÜµÏã† api. Ìò∏Ï∂ú ÏïàÌïòÏÖîÎèÑ Îê®.)ÏïÑÏù¥ ÏÇ≠Ï†úÏãú ÏÇ≠Ï†ú Í∞ÄÎä•Ìïú Ìè¥ÎçîÎ°ú Î≥ÄÍ≤Ω
 */
export const releaseStudentPhotoFolder = (
  createStudentPhotoFolderRequest: CreateStudentPhotoFolderRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseSmartFolderResult>(
    {
      url: `/file/v1/smart-folder/photo/student/release-folder`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: createStudentPhotoFolderRequest,
    },
    options,
  );
};

export const getReleaseStudentPhotoFolderMutationOptions = <
  TData = Awaited<ReturnType<typeof releaseStudentPhotoFolder>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CreateStudentPhotoFolderRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['releaseStudentPhotoFolder'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof releaseStudentPhotoFolder>>,
    { data: CreateStudentPhotoFolderRequest }
  > = (props) => {
    const { data } = props ?? {};

    return releaseStudentPhotoFolder(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: CreateStudentPhotoFolderRequest },
    TContext
  >;
};

export type ReleaseStudentPhotoFolderMutationResult = NonNullable<
  Awaited<ReturnType<typeof releaseStudentPhotoFolder>>
>;
export type ReleaseStudentPhotoFolderMutationBody = CreateStudentPhotoFolderRequest;
export type ReleaseStudentPhotoFolderMutationError = unknown;

/**
 * @summary (ÎÇ¥Î∂Ä ÌÜµÏã† api. Ìò∏Ï∂ú ÏïàÌïòÏÖîÎèÑ Îê®.)ÏïÑÏù¥ ÏÇ≠Ï†úÏãú ÏÇ≠Ï†ú Í∞ÄÎä•Ìïú Ìè¥ÎçîÎ°ú Î≥ÄÍ≤Ω
 */
export const useReleaseStudentPhotoFolder = <
  TData = Awaited<ReturnType<typeof releaseStudentPhotoFolder>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CreateStudentPhotoFolderRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: CreateStudentPhotoFolderRequest }, TContext> => {
  const mutationOptions = getReleaseStudentPhotoFolderMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏöîÏ≤≠Ìïú ÏÇ¨ÏßÑÏùÑ Îã§Î•∏ ÏïÑÏù¥Î°ú Îì±Î°ùÌïòÍ≥† Ìè¥ÎçîÎ•º Ïù¥ÎèôÌï©ÎãàÎã§.
 * @summary Î∂ÑÎ•òÎêú ÏïÑÏù¥ ÏÇ¨ÏßÑ ÏûêÎ£åÎ•º Îã§Î•∏ ÏïÑÏù¥Î°ú Îì±Î°ù.(Ìè¥Îçî Ïù¥Îèô Î∞è ÌÉúÍπÖÎêú ÏïÑÏù¥ Ï†ïÎ≥¥ Î≥ÄÍ≤Ω)
 */
export const moveStudentPhotoItem = (
  changeLinkedStudentRequest: ChangeLinkedStudentRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    {
      url: `/file/v1/smart-folder/photo/student/move`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: changeLinkedStudentRequest,
    },
    options,
  );
};

export const getMoveStudentPhotoItemMutationOptions = <
  TData = Awaited<ReturnType<typeof moveStudentPhotoItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: ChangeLinkedStudentRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['moveStudentPhotoItem'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof moveStudentPhotoItem>>,
    { data: ChangeLinkedStudentRequest }
  > = (props) => {
    const { data } = props ?? {};

    return moveStudentPhotoItem(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: ChangeLinkedStudentRequest },
    TContext
  >;
};

export type MoveStudentPhotoItemMutationResult = NonNullable<Awaited<ReturnType<typeof moveStudentPhotoItem>>>;
export type MoveStudentPhotoItemMutationBody = ChangeLinkedStudentRequest;
export type MoveStudentPhotoItemMutationError = unknown;

/**
 * @summary Î∂ÑÎ•òÎêú ÏïÑÏù¥ ÏÇ¨ÏßÑ ÏûêÎ£åÎ•º Îã§Î•∏ ÏïÑÏù¥Î°ú Îì±Î°ù.(Ìè¥Îçî Ïù¥Îèô Î∞è ÌÉúÍπÖÎêú ÏïÑÏù¥ Ï†ïÎ≥¥ Î≥ÄÍ≤Ω)
 */
export const useMoveStudentPhotoItem = <
  TData = Awaited<ReturnType<typeof moveStudentPhotoItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: ChangeLinkedStudentRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: ChangeLinkedStudentRequest }, TContext> => {
  const mutationOptions = getMoveStudentPhotoItemMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏïÑÏù¥ Ïù¥Î¶ÑÏù¥ Î≥ÄÍ≤ΩÎêêÏùÑ Îïå Î∞òÏòÅÌï©ÎãàÎã§.
 * @summary (ÎÇ¥Î∂Ä api ÌÜµÏã†Ïö©)ÏïÑÏù¥ Ïù¥Î¶Ñ Î≥ÄÍ≤ΩÏãú Ìè¥ÎçîÎ™Ö Î≥ÄÍ≤Ω
 */
export const modifyStudentPhotoFolder = (
  createStudentPhotoFolderRequest: CreateStudentPhotoFolderRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseSmartFolderResult>(
    {
      url: `/file/v1/smart-folder/photo/student/modify-student-name`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: createStudentPhotoFolderRequest,
    },
    options,
  );
};

export const getModifyStudentPhotoFolderMutationOptions = <
  TData = Awaited<ReturnType<typeof modifyStudentPhotoFolder>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CreateStudentPhotoFolderRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['modifyStudentPhotoFolder'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof modifyStudentPhotoFolder>>,
    { data: CreateStudentPhotoFolderRequest }
  > = (props) => {
    const { data } = props ?? {};

    return modifyStudentPhotoFolder(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: CreateStudentPhotoFolderRequest },
    TContext
  >;
};

export type ModifyStudentPhotoFolderMutationResult = NonNullable<Awaited<ReturnType<typeof modifyStudentPhotoFolder>>>;
export type ModifyStudentPhotoFolderMutationBody = CreateStudentPhotoFolderRequest;
export type ModifyStudentPhotoFolderMutationError = unknown;

/**
 * @summary (ÎÇ¥Î∂Ä api ÌÜµÏã†Ïö©)ÏïÑÏù¥ Ïù¥Î¶Ñ Î≥ÄÍ≤ΩÏãú Ìè¥ÎçîÎ™Ö Î≥ÄÍ≤Ω
 */
export const useModifyStudentPhotoFolder = <
  TData = Awaited<ReturnType<typeof modifyStudentPhotoFolder>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CreateStudentPhotoFolderRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: CreateStudentPhotoFolderRequest }, TContext> => {
  const mutationOptions = getModifyStudentPhotoFolderMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏöîÏ≤≠ ÏûêÎ£åÎ•º Ïù¥ÎèôÌï©ÎãàÎã§. ÌååÏùºÎßåÏù¥ÎèôÌïòÍ≥†, Ïù¥Îèô ÏÑ±Í≥µÌïú ÏûêÎ£åÎì§Ïùò ÏµúÏÜå Ï†ïÎ≥¥Î•º Î∞òÌôòÌï©ÎãàÎã§.
 * @summary ÏÇ¨ÏßÑ ÏûêÎ£åÎ•º Ïù¥Îèô
 */
export const movePhotoItem = (moveItemRequest: MoveItemRequest, options?: SecondParameter<typeof customFetcher>) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    {
      url: `/file/v1/smart-folder/photo/move`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: moveItemRequest,
    },
    options,
  );
};

export const getMovePhotoItemMutationOptions = <
  TData = Awaited<ReturnType<typeof movePhotoItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MoveItemRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['movePhotoItem'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof movePhotoItem>>, { data: MoveItemRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return movePhotoItem(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError, { data: MoveItemRequest }, TContext>;
};

export type MovePhotoItemMutationResult = NonNullable<Awaited<ReturnType<typeof movePhotoItem>>>;
export type MovePhotoItemMutationBody = MoveItemRequest;
export type MovePhotoItemMutationError = unknown;

/**
 * @summary ÏÇ¨ÏßÑ ÏûêÎ£åÎ•º Ïù¥Îèô
 */
export const useMovePhotoItem = <
  TData = Awaited<ReturnType<typeof movePhotoItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MoveItemRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: MoveItemRequest }, TContext> => {
  const mutationOptions = getMovePhotoItemMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏúÑÏ†ØÏùÑ ÏûêÎ£åÎ≥¥Îìú Ìôà ÌôîÎ©¥ÏóêÏÑú Î≥¥Ïù¥ÏßÄ ÏïäÍ≤å Ìï©ÎãàÎã§.
 * @summary ÏúÑÏ†ØÏùÑ Ìï¥Îãπ Ìè¥ÎçîÏóêÏÑú Ïà®Í∏∞Í∏∞(Îçî Ïù¥ÏÉÅ Î≥¥ÏßÄÏïäÍ∏∞)
 */
export const showWidgets = (
  toggleHiddenItemRequest: ToggleHiddenItemRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseSmartFolderResult>(
    {
      url: `/file/v1/smart-folder/docs/show-widget`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: toggleHiddenItemRequest,
    },
    options,
  );
};

export const getShowWidgetsMutationOptions = <
  TData = Awaited<ReturnType<typeof showWidgets>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: ToggleHiddenItemRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['showWidgets'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof showWidgets>>, { data: ToggleHiddenItemRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return showWidgets(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: ToggleHiddenItemRequest },
    TContext
  >;
};

export type ShowWidgetsMutationResult = NonNullable<Awaited<ReturnType<typeof showWidgets>>>;
export type ShowWidgetsMutationBody = ToggleHiddenItemRequest;
export type ShowWidgetsMutationError = unknown;

/**
 * @summary ÏúÑÏ†ØÏùÑ Ìï¥Îãπ Ìè¥ÎçîÏóêÏÑú Ïà®Í∏∞Í∏∞(Îçî Ïù¥ÏÉÅ Î≥¥ÏßÄÏïäÍ∏∞)
 */
export const useShowWidgets = <
  TData = Awaited<ReturnType<typeof showWidgets>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: ToggleHiddenItemRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: ToggleHiddenItemRequest }, TContext> => {
  const mutationOptions = getShowWidgetsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏöîÏ≤≠ ÏûêÎ£åÎ•º Ïù¥ÎèôÌï©ÎãàÎã§. ÌååÏùºÎßåÏù¥ÎèôÌïòÍ≥†, Ïù¥Îèô ÏÑ±Í≥µÌïú ÏûêÎ£åÎì§Ïùò ÏµúÏÜå Ï†ïÎ≥¥Î•º Î∞òÌôòÌï©ÎãàÎã§.
 * @summary Î¨∏ÏÑú ÏûêÎ£åÎ•º Ïù¥Îèô
 */
export const moveDocumentItem = (moveItemRequest: MoveItemRequest, options?: SecondParameter<typeof customFetcher>) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    {
      url: `/file/v1/smart-folder/docs/move`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: moveItemRequest,
    },
    options,
  );
};

export const getMoveDocumentItemMutationOptions = <
  TData = Awaited<ReturnType<typeof moveDocumentItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MoveItemRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['moveDocumentItem'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof moveDocumentItem>>, { data: MoveItemRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return moveDocumentItem(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError, { data: MoveItemRequest }, TContext>;
};

export type MoveDocumentItemMutationResult = NonNullable<Awaited<ReturnType<typeof moveDocumentItem>>>;
export type MoveDocumentItemMutationBody = MoveItemRequest;
export type MoveDocumentItemMutationError = unknown;

/**
 * @summary Î¨∏ÏÑú ÏûêÎ£åÎ•º Ïù¥Îèô
 */
export const useMoveDocumentItem = <
  TData = Awaited<ReturnType<typeof moveDocumentItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MoveItemRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: MoveItemRequest }, TContext> => {
  const mutationOptions = getMoveDocumentItemMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏúÑÏ†ØÏùÑ ÏûêÎ£åÎ≥¥Îìú ÌôàÏóêÏÑú Î≥¥Ïù¥Í∏∞/Ïà®Í∏∞Í∏∞ Î∞è ÏàúÏÑúÎ•º Î≥ÄÍ≤ΩÌï©ÎãàÎã§. (Î≥ÄÍ≤Ω ÌïÑÏöîÌïú ÎÇ¥Ïö©Îßå Ï†ÄÏû•Ìï©ÎãàÎã§.)
 * @summary ÏúÑÏ†ØÏùÑ Î≥¥Ïù¥Í±∞ÎÇò Ïà®Í∏∞Í±∞ÎÇò ÏàúÏÑúÎ•º Î≥ÄÍ≤Ω
 */
export const manageSortAndToggleHiddenWidgets = (
  toggleHiddenItemsRequest: ToggleHiddenItemsRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseString>(
    {
      url: `/file/v1/smart-folder/docs/manage-widgets`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: toggleHiddenItemsRequest,
    },
    options,
  );
};

export const getManageSortAndToggleHiddenWidgetsMutationOptions = <
  TData = Awaited<ReturnType<typeof manageSortAndToggleHiddenWidgets>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: ToggleHiddenItemsRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['manageSortAndToggleHiddenWidgets'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof manageSortAndToggleHiddenWidgets>>,
    { data: ToggleHiddenItemsRequest }
  > = (props) => {
    const { data } = props ?? {};

    return manageSortAndToggleHiddenWidgets(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: ToggleHiddenItemsRequest },
    TContext
  >;
};

export type ManageSortAndToggleHiddenWidgetsMutationResult = NonNullable<
  Awaited<ReturnType<typeof manageSortAndToggleHiddenWidgets>>
>;
export type ManageSortAndToggleHiddenWidgetsMutationBody = ToggleHiddenItemsRequest;
export type ManageSortAndToggleHiddenWidgetsMutationError = unknown;

/**
 * @summary ÏúÑÏ†ØÏùÑ Î≥¥Ïù¥Í±∞ÎÇò Ïà®Í∏∞Í±∞ÎÇò ÏàúÏÑúÎ•º Î≥ÄÍ≤Ω
 */
export const useManageSortAndToggleHiddenWidgets = <
  TData = Awaited<ReturnType<typeof manageSortAndToggleHiddenWidgets>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: ToggleHiddenItemsRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: ToggleHiddenItemsRequest }, TContext> => {
  const mutationOptions = getManageSortAndToggleHiddenWidgetsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏúÑÏ†ØÏùÑ ÏûêÎ£åÎ≥¥Îìú Ìôà ÌôîÎ©¥ÏóêÏÑú Î≥¥Ïù¥ÏßÄ ÏïäÍ≤å Ìï©ÎãàÎã§.
 * @summary ÏúÑÏ†ØÏùÑ Ìï¥Îãπ Ìè¥ÎçîÏóêÏÑú Ïà®Í∏∞Í∏∞(Îçî Ïù¥ÏÉÅ Î≥¥ÏßÄÏïäÍ∏∞)
 */
export const hideWidgets = (
  toggleHiddenItemRequest: ToggleHiddenItemRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseSmartFolderResult>(
    {
      url: `/file/v1/smart-folder/docs/hide-widget`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: toggleHiddenItemRequest,
    },
    options,
  );
};

export const getHideWidgetsMutationOptions = <
  TData = Awaited<ReturnType<typeof hideWidgets>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: ToggleHiddenItemRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['hideWidgets'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof hideWidgets>>, { data: ToggleHiddenItemRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return hideWidgets(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: ToggleHiddenItemRequest },
    TContext
  >;
};

export type HideWidgetsMutationResult = NonNullable<Awaited<ReturnType<typeof hideWidgets>>>;
export type HideWidgetsMutationBody = ToggleHiddenItemRequest;
export type HideWidgetsMutationError = unknown;

/**
 * @summary ÏúÑÏ†ØÏùÑ Ìï¥Îãπ Ìè¥ÎçîÏóêÏÑú Ïà®Í∏∞Í∏∞(Îçî Ïù¥ÏÉÅ Î≥¥ÏßÄÏïäÍ∏∞)
 */
export const useHideWidgets = <
  TData = Awaited<ReturnType<typeof hideWidgets>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: ToggleHiddenItemRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: ToggleHiddenItemRequest }, TContext> => {
  const mutationOptions = getHideWidgetsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Ï∂îÏ≤ú ÌÇ§ÏõåÎìú Ï†ïÎ≥¥Î•º ÏàòÏ†ïÌï©ÎãàÎã§.
 * @summary Ï∂îÏ≤ú ÌÇ§ÏõåÎìú Ï†ïÎ≥¥ ÏàòÏ†ï
 */
export const updateRecommendationKeywordInfo = (
  id: string,
  recommendationKeywordBundleUpdateRequest: RecommendationKeywordBundleUpdateRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseRecommendationKeywordBundleResult>(
    {
      url: `/file/v1/recommendation/common-keywords/${id}`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: recommendationKeywordBundleUpdateRequest,
    },
    options,
  );
};

export const getUpdateRecommendationKeywordInfoMutationOptions = <
  TData = Awaited<ReturnType<typeof updateRecommendationKeywordInfo>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { id: string; data: RecommendationKeywordBundleUpdateRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['updateRecommendationKeywordInfo'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateRecommendationKeywordInfo>>,
    { id: string; data: RecommendationKeywordBundleUpdateRequest }
  > = (props) => {
    const { id, data } = props ?? {};

    return updateRecommendationKeywordInfo(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { id: string; data: RecommendationKeywordBundleUpdateRequest },
    TContext
  >;
};

export type UpdateRecommendationKeywordInfoMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateRecommendationKeywordInfo>>
>;
export type UpdateRecommendationKeywordInfoMutationBody = RecommendationKeywordBundleUpdateRequest;
export type UpdateRecommendationKeywordInfoMutationError = unknown;

/**
 * @summary Ï∂îÏ≤ú ÌÇ§ÏõåÎìú Ï†ïÎ≥¥ ÏàòÏ†ï
 */
export const useUpdateRecommendationKeywordInfo = <
  TData = Awaited<ReturnType<typeof updateRecommendationKeywordInfo>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { id: string; data: RecommendationKeywordBundleUpdateRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { id: string; data: RecommendationKeywordBundleUpdateRequest }, TContext> => {
  const mutationOptions = getUpdateRecommendationKeywordInfoMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏöîÏ≤≠Ìïú ÏûêÎ£åÏùò Í≥µÍ∞ú ÏÉÅÌÉúÎ•º Î≥ÄÍ≤ΩÌï©ÎãàÎã§. userEditableÏù¥ falseÏù∏ ÏûêÎ£åÎäî Î≥ÄÍ≤ΩÏù¥ Î∂àÍ∞ÄÎä•Ìï©ÎãàÎã§.ÏÉÅÌÉúÏöîÏ≤≠Ïóê Îî∞Îùº PRIVATE(ÎπÑÍ≥µÍ∞ú), PUBLIC(Í≥µÍ∞ú -> PUBLIC_AND_URL_SHAREÎ°ú ÎîîÌè¥Ìä∏Î°ú ÏÇ¨Ïö©), PRIVATE_AND_URL_SHARE(ÎπÑÍ≥µÍ∞ú+URLÍ≥µÏú†), PUBLIC_AND_URL_SHARE(Í≥µÍ∞ú+URLÍ≥µÏú†) Í∞Ñ Î≥ÄÍ≤ΩÎê©ÎãàÎã§.
 * @summary ÏûêÎ£åÏùò Í≥µÍ∞ú ÏÉÅÌÉú Î≥ÄÍ≤Ω
 */
export const changePublicStateOfItem = (
  changeShareStatePublicItemRequest: ChangeShareStatePublicItemRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseSmartFolderItemResult>(
    {
      url: `/file/v1/public-url-item/share`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: changeShareStatePublicItemRequest,
    },
    options,
  );
};

export const getChangePublicStateOfItemMutationOptions = <
  TData = Awaited<ReturnType<typeof changePublicStateOfItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: ChangeShareStatePublicItemRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['changePublicStateOfItem'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof changePublicStateOfItem>>,
    { data: ChangeShareStatePublicItemRequest }
  > = (props) => {
    const { data } = props ?? {};

    return changePublicStateOfItem(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: ChangeShareStatePublicItemRequest },
    TContext
  >;
};

export type ChangePublicStateOfItemMutationResult = NonNullable<Awaited<ReturnType<typeof changePublicStateOfItem>>>;
export type ChangePublicStateOfItemMutationBody = ChangeShareStatePublicItemRequest;
export type ChangePublicStateOfItemMutationError = unknown;

/**
 * @summary ÏûêÎ£åÏùò Í≥µÍ∞ú ÏÉÅÌÉú Î≥ÄÍ≤Ω
 */
export const useChangePublicStateOfItem = <
  TData = Awaited<ReturnType<typeof changePublicStateOfItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: ChangeShareStatePublicItemRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: ChangeShareStatePublicItemRequest }, TContext> => {
  const mutationOptions = getChangePublicStateOfItemMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏöîÏ≤≠ ÏûêÎ£åÏùò Ïù¥Î¶ÑÏùÑ Î≥ÄÍ≤ΩÌï©ÎãàÎã§.(ÏùëÎãµÏúºÎ°ú ÏûêÎ£åÏùò ÏµúÏÜåÏ†ïÎ≥¥Îßå ÏùëÎãµÌï©ÎãàÎã§. Ïπ¥Ïö¥Ìä∏Ï™ΩÏùÄ Ï≤¥ÌÅ¨ÌïòÏßÄÏïäÏäµÎãàÎã§.)
 * @summary ÎÇ¥ Ìè¥Îçî/ÏûêÎ£åÏùò Ïù¥Î¶Ñ Î≥ÄÍ≤Ω
 */
export const renameItem = (
  smartFolderItemid: string,
  renameRequest: RenameRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseSmartFolderItemResult>(
    {
      url: `/file/v1/my-folder/${smartFolderItemid}/rename`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: renameRequest,
    },
    options,
  );
};

export const getRenameItemMutationOptions = <
  TData = Awaited<ReturnType<typeof renameItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { smartFolderItemid: string; data: RenameRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['renameItem'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof renameItem>>,
    { smartFolderItemid: string; data: RenameRequest }
  > = (props) => {
    const { smartFolderItemid, data } = props ?? {};

    return renameItem(smartFolderItemid, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { smartFolderItemid: string; data: RenameRequest },
    TContext
  >;
};

export type RenameItemMutationResult = NonNullable<Awaited<ReturnType<typeof renameItem>>>;
export type RenameItemMutationBody = RenameRequest;
export type RenameItemMutationError = unknown;

/**
 * @summary ÎÇ¥ Ìè¥Îçî/ÏûêÎ£åÏùò Ïù¥Î¶Ñ Î≥ÄÍ≤Ω
 */
export const useRenameItem = <
  TData = Awaited<ReturnType<typeof renameItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { smartFolderItemid: string; data: RenameRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { smartFolderItemid: string; data: RenameRequest }, TContext> => {
  const mutationOptions = getRenameItemMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏöîÏ≤≠Ìïú ÏûêÎ£åÏùò Í≥µÍ∞ú ÏÉÅÌÉúÎ•º Î≥ÄÍ≤ΩÌï©ÎãàÎã§. userEditableÏù¥ falseÏù∏ ÏûêÎ£åÎäî Î≥ÄÍ≤ΩÏù¥ Î∂àÍ∞ÄÎä•Ìï©ÎãàÎã§.ÏÉÅÌÉúÏöîÏ≤≠Ïóê Îî∞Îùº PRIVATE(ÎπÑÍ≥µÍ∞ú), PUBLIC(Í≥µÍ∞ú -> PUBLIC_AND_URL_SHAREÎ°ú ÎîîÌè¥Ìä∏Î°ú ÏÇ¨Ïö©), PRIVATE_AND_URL_SHARE(ÎπÑÍ≥µÍ∞ú+URLÍ≥µÏú†), PUBLIC_AND_URL_SHARE(Í≥µÍ∞ú+URLÍ≥µÏú†) Í∞Ñ Î≥ÄÍ≤ΩÎê©ÎãàÎã§.
 * @summary ÎÇ¥ Ìè¥Îçî ÏûêÎ£åÏùò Í≥µÍ∞ú ÏÉÅÌÉú Î≥ÄÍ≤Ω
 */
export const changePublicStateOfItem1 = (
  commonChangeShareStateWithidRequest: CommonChangeShareStateWithidRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseSmartFolderItemResult>(
    {
      url: `/file/v1/my-folder/share`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: commonChangeShareStateWithidRequest,
    },
    options,
  );
};

export const getChangePublicStateOfItem1MutationOptions = <
  TData = Awaited<ReturnType<typeof changePublicStateOfItem1>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CommonChangeShareStateWithidRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['changePublicStateOfItem1'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof changePublicStateOfItem1>>,
    { data: CommonChangeShareStateWithidRequest }
  > = (props) => {
    const { data } = props ?? {};

    return changePublicStateOfItem1(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: CommonChangeShareStateWithidRequest },
    TContext
  >;
};

export type ChangePublicStateOfItem1MutationResult = NonNullable<Awaited<ReturnType<typeof changePublicStateOfItem1>>>;
export type ChangePublicStateOfItem1MutationBody = CommonChangeShareStateWithidRequest;
export type ChangePublicStateOfItem1MutationError = unknown;

/**
 * @summary ÎÇ¥ Ìè¥Îçî ÏûêÎ£åÏùò Í≥µÍ∞ú ÏÉÅÌÉú Î≥ÄÍ≤Ω
 */
export const useChangePublicStateOfItem1 = <
  TData = Awaited<ReturnType<typeof changePublicStateOfItem1>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CommonChangeShareStateWithidRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: CommonChangeShareStateWithidRequest }, TContext> => {
  const mutationOptions = getChangePublicStateOfItem1MutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏöîÏ≤≠ ÏûêÎ£åÎ•º Ïù¥ÎèôÌï©ÎãàÎã§. ÌååÏùºÎßåÏù¥ÎèôÌïòÍ≥†, Ïù¥Îèô ÏÑ±Í≥µÌïú ÏûêÎ£åÎì§Ïùò ÏµúÏÜå Ï†ïÎ≥¥Î•º Î∞òÌôòÌï©ÎãàÎã§.
 * @summary ÏûêÎ£åÎ•º Ïù¥Îèô
 */
export const moveItem = (moveItemRequest: MoveItemRequest, options?: SecondParameter<typeof customFetcher>) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    {
      url: `/file/v1/my-folder/move`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: moveItemRequest,
    },
    options,
  );
};

export const getMoveItemMutationOptions = <
  TData = Awaited<ReturnType<typeof moveItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MoveItemRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['moveItem'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof moveItem>>, { data: MoveItemRequest }> = (props) => {
    const { data } = props ?? {};

    return moveItem(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError, { data: MoveItemRequest }, TContext>;
};

export type MoveItemMutationResult = NonNullable<Awaited<ReturnType<typeof moveItem>>>;
export type MoveItemMutationBody = MoveItemRequest;
export type MoveItemMutationError = unknown;

/**
 * @summary ÏûêÎ£åÎ•º Ïù¥Îèô
 */
export const useMoveItem = <
  TData = Awaited<ReturnType<typeof moveItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MoveItemRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: MoveItemRequest }, TContext> => {
  const mutationOptions = getMoveItemMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏöîÏ≤≠Ìïú ÏûêÎ£åÏùò Í≥µÍ∞ú ÏÉÅÌÉúÎ•º Î≥ÄÍ≤ΩÌï©ÎãàÎã§. userEditableÏù¥ falseÏù∏ ÏûêÎ£åÎäî Î≥ÄÍ≤ΩÏù¥ Î∂àÍ∞ÄÎä•Ìï©ÎãàÎã§.ÏÉÅÌÉúÏöîÏ≤≠Ïóê Îî∞Îùº PRIVATE(ÎπÑÍ≥µÍ∞ú), PUBLIC(Í≥µÍ∞ú -> PUBLIC_AND_URL_SHAREÎ°ú ÎîîÌè¥Ìä∏Î°ú ÏÇ¨Ïö©), PRIVATE_AND_URL_SHARE(ÎπÑÍ≥µÍ∞ú+URLÍ≥µÏú†), PUBLIC_AND_URL_SHARE(Í≥µÍ∞ú+URLÍ≥µÏú†)
 * @summary ÎßàÏù¥Î≥¥Îìú ÏûêÎ£åÏùò Í≥µÍ∞ú ÏÉÅÌÉú Î≥ÄÍ≤Ω
 */
export const changePublicStateOfItem2 = (
  myBoardChangeShareStateRequest: MyBoardChangeShareStateRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseSmartFolderItemResult>(
    {
      url: `/file/v1/my-board/share`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: myBoardChangeShareStateRequest,
    },
    options,
  );
};

export const getChangePublicStateOfItem2MutationOptions = <
  TData = Awaited<ReturnType<typeof changePublicStateOfItem2>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MyBoardChangeShareStateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['changePublicStateOfItem2'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof changePublicStateOfItem2>>,
    { data: MyBoardChangeShareStateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return changePublicStateOfItem2(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: MyBoardChangeShareStateRequest },
    TContext
  >;
};

export type ChangePublicStateOfItem2MutationResult = NonNullable<Awaited<ReturnType<typeof changePublicStateOfItem2>>>;
export type ChangePublicStateOfItem2MutationBody = MyBoardChangeShareStateRequest;
export type ChangePublicStateOfItem2MutationError = unknown;

/**
 * @summary ÎßàÏù¥Î≥¥Îìú ÏûêÎ£åÏùò Í≥µÍ∞ú ÏÉÅÌÉú Î≥ÄÍ≤Ω
 */
export const useChangePublicStateOfItem2 = <
  TData = Awaited<ReturnType<typeof changePublicStateOfItem2>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MyBoardChangeShareStateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: MyBoardChangeShareStateRequest }, TContext> => {
  const mutationOptions = getChangePublicStateOfItem2MutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏöîÏ≤≠Ìïú ÏûêÎ£åÏùò Ïù¥Î¶ÑÏùÑ Î≥ÄÍ≤ΩÌï©ÎãàÎã§. userEditableÏù¥ falseÏù∏ ÏûêÎ£åÎäî Î≥ÄÍ≤ΩÏù¥ Î∂àÍ∞ÄÎä•Ìï©ÎãàÎã§.
 * @summary ÎßàÏù¥Î≥¥Îìú ÏûêÎ£åÏùò Ïù¥Î¶Ñ Î≥ÄÍ≤Ω
 */
export const renameItem1 = (
  myBoardRenameRequest: MyBoardRenameRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseSmartFolderItemResult>(
    {
      url: `/file/v1/my-board/rename-item`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: myBoardRenameRequest,
    },
    options,
  );
};

export const getRenameItem1MutationOptions = <
  TData = Awaited<ReturnType<typeof renameItem1>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MyBoardRenameRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['renameItem1'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof renameItem1>>, { data: MyBoardRenameRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return renameItem1(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: MyBoardRenameRequest },
    TContext
  >;
};

export type RenameItem1MutationResult = NonNullable<Awaited<ReturnType<typeof renameItem1>>>;
export type RenameItem1MutationBody = MyBoardRenameRequest;
export type RenameItem1MutationError = unknown;

/**
 * @summary ÎßàÏù¥Î≥¥Îìú ÏûêÎ£åÏùò Ïù¥Î¶Ñ Î≥ÄÍ≤Ω
 */
export const useRenameItem1 = <
  TData = Awaited<ReturnType<typeof renameItem1>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MyBoardRenameRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: MyBoardRenameRequest }, TContext> => {
  const mutationOptions = getRenameItem1MutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÎÜÄÏù¥Î≥¥Í≥†ÏÑúÎ•º ÏàòÏ†ïÌï©ÎãàÎã§.
 * @summary ÎÜÄÏù¥Î≥¥Í≥†ÏÑú ÏàòÏ†ï
 */
export const updateLectureReport = (
  lectureReportUpdateRequest: LectureReportUpdateRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseLectureReportResult>(
    {
      url: `/file/v1/lecture-report`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: lectureReportUpdateRequest,
    },
    options,
  );
};

export const getUpdateLectureReportMutationOptions = <
  TData = Awaited<ReturnType<typeof updateLectureReport>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: LectureReportUpdateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['updateLectureReport'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateLectureReport>>,
    { data: LectureReportUpdateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return updateLectureReport(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: LectureReportUpdateRequest },
    TContext
  >;
};

export type UpdateLectureReportMutationResult = NonNullable<Awaited<ReturnType<typeof updateLectureReport>>>;
export type UpdateLectureReportMutationBody = LectureReportUpdateRequest;
export type UpdateLectureReportMutationError = unknown;

/**
 * @summary ÎÜÄÏù¥Î≥¥Í≥†ÏÑú ÏàòÏ†ï
 */
export const useUpdateLectureReport = <
  TData = Awaited<ReturnType<typeof updateLectureReport>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: LectureReportUpdateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: LectureReportUpdateRequest }, TContext> => {
  const mutationOptions = getUpdateLectureReportMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÎÜÄÏù¥Î≥¥Í≥†ÏÑúÎ•º Ïã†Í∑úÎ°ú Ï†ÄÏû•Ìï©ÎãàÎã§.
 * @summary Ïã†Í∑ú ÎÜÄÏù¥Î≥¥Í≥†ÏÑú Ï†ÄÏû•
 */
export const createLectureReport = (
  lectureReportAddRequest: LectureReportAddRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseLectureReportResult>(
    {
      url: `/file/v1/lecture-report`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: lectureReportAddRequest,
      signal,
    },
    options,
  );
};

export const getCreateLectureReportMutationOptions = <
  TData = Awaited<ReturnType<typeof createLectureReport>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: LectureReportAddRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['createLectureReport'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createLectureReport>>,
    { data: LectureReportAddRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createLectureReport(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: LectureReportAddRequest },
    TContext
  >;
};

export type CreateLectureReportMutationResult = NonNullable<Awaited<ReturnType<typeof createLectureReport>>>;
export type CreateLectureReportMutationBody = LectureReportAddRequest;
export type CreateLectureReportMutationError = unknown;

/**
 * @summary Ïã†Í∑ú ÎÜÄÏù¥Î≥¥Í≥†ÏÑú Ï†ÄÏû•
 */
export const useCreateLectureReport = <
  TData = Awaited<ReturnType<typeof createLectureReport>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: LectureReportAddRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: LectureReportAddRequest }, TContext> => {
  const mutationOptions = getCreateLectureReportMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÎÜÄÏù¥Í≥ÑÌöçÏùÑ ÏàòÏ†ïÌï©ÎãàÎã§.
 * @summary Ïã†Í∑ú ÎÜÄÏù¥Í≥ÑÌöç ÏàòÏ†ï
 */
export const updateLecturePlan = (
  lecturePlanUpdateRequest: LecturePlanUpdateRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseLecturePlanResult>(
    {
      url: `/file/v1/lecture-plan`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: lecturePlanUpdateRequest,
    },
    options,
  );
};

export const getUpdateLecturePlanMutationOptions = <
  TData = Awaited<ReturnType<typeof updateLecturePlan>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: LecturePlanUpdateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['updateLecturePlan'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateLecturePlan>>,
    { data: LecturePlanUpdateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return updateLecturePlan(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: LecturePlanUpdateRequest },
    TContext
  >;
};

export type UpdateLecturePlanMutationResult = NonNullable<Awaited<ReturnType<typeof updateLecturePlan>>>;
export type UpdateLecturePlanMutationBody = LecturePlanUpdateRequest;
export type UpdateLecturePlanMutationError = unknown;

/**
 * @summary Ïã†Í∑ú ÎÜÄÏù¥Í≥ÑÌöç ÏàòÏ†ï
 */
export const useUpdateLecturePlan = <
  TData = Awaited<ReturnType<typeof updateLecturePlan>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: LecturePlanUpdateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: LecturePlanUpdateRequest }, TContext> => {
  const mutationOptions = getUpdateLecturePlanMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÎÜÄÏù¥Í≥ÑÌöçÏùÑ Ïã†Í∑úÎ°ú Ï†ÄÏû•Ìï©ÎãàÎã§.
 * @summary Ïã†Í∑ú ÎÜÄÏù¥Í≥ÑÌöç Ï†ÄÏû•
 */
export const createLecturePlan = (
  lecturePlanAddRequest: LecturePlanAddRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseLecturePlanResult>(
    {
      url: `/file/v1/lecture-plan`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: lecturePlanAddRequest,
      signal,
    },
    options,
  );
};

export const getCreateLecturePlanMutationOptions = <
  TData = Awaited<ReturnType<typeof createLecturePlan>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: LecturePlanAddRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['createLecturePlan'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof createLecturePlan>>, { data: LecturePlanAddRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return createLecturePlan(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: LecturePlanAddRequest },
    TContext
  >;
};

export type CreateLecturePlanMutationResult = NonNullable<Awaited<ReturnType<typeof createLecturePlan>>>;
export type CreateLecturePlanMutationBody = LecturePlanAddRequest;
export type CreateLecturePlanMutationError = unknown;

/**
 * @summary Ïã†Í∑ú ÎÜÄÏù¥Í≥ÑÌöç Ï†ÄÏû•
 */
export const useCreateLecturePlan = <
  TData = Awaited<ReturnType<typeof createLecturePlan>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: LecturePlanAddRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: LecturePlanAddRequest }, TContext> => {
  const mutationOptions = getCreateLecturePlanMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÌîÑÎ°úÌïÑ ÏÇ¨ÏßÑÏù¥ presigned urlÏóê ÏóÖÎ°úÎìúÌïòÍ≥†ÎÇòÎ©¥ Ìï¥Îãπ ÏÇ¨ÏßÑÌååÏùºÏùÑ ÏóÖÎ°úÎìú ÏôÑÎ£å ÏÉÅÌÉúÎ°ú Î≥ÄÍ≤ΩÌï©ÎãàÎã§.
 * @summary ÌîÑÎ°úÌïÑ ÏÇ¨ÏßÑ ÏóÖÎ°úÎìú ÏôÑÎ£å ÏΩúÎ∞±
 */
export const uploadCompleted = (fileObjectId: number, options?: SecondParameter<typeof customFetcher>) => {
  return customFetcher<ApiResponseString>(
    { url: `/file/v1/file-objects/${fileObjectId}/uploaded`, method: 'PUT' },
    options,
  );
};

export const getUploadCompletedMutationOptions = <
  TData = Awaited<ReturnType<typeof uploadCompleted>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { fileObjectId: number }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['uploadCompleted'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof uploadCompleted>>, { fileObjectId: number }> = (
    props,
  ) => {
    const { fileObjectId } = props ?? {};

    return uploadCompleted(fileObjectId, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError, { fileObjectId: number }, TContext>;
};

export type UploadCompletedMutationResult = NonNullable<Awaited<ReturnType<typeof uploadCompleted>>>;

export type UploadCompletedMutationError = unknown;

/**
 * @summary ÌîÑÎ°úÌïÑ ÏÇ¨ÏßÑ ÏóÖÎ°úÎìú ÏôÑÎ£å ÏΩúÎ∞±
 */
export const useUploadCompleted = <
  TData = Awaited<ReturnType<typeof uploadCompleted>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { fileObjectId: number }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { fileObjectId: number }, TContext> => {
  const mutationOptions = getUploadCompletedMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏûêÎ£åÏùò Ïç∏ÎÑ§ÏùºÏùÑ Î≥ÄÍ≤ΩÌï©ÎãàÎã§. (ÌïÑÏöîÏãúÏóêÎßå ÏÇ¨Ïö©Ìï©ÎãàÎã§.)
 * @summary ÏûêÎ£åÏùò Ïç∏ÎÑ§Ïùº Î≥ÄÍ≤Ω
 */
export const changeThumbnail = (
  key: string,
  driveItemChangeThumbnailRequest: DriveItemChangeThumbnailRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseString>(
    {
      url: `/file/v1/drive-items/${key}/thumbnail`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: driveItemChangeThumbnailRequest,
    },
    options,
  );
};

export const getChangeThumbnailMutationOptions = <
  TData = Awaited<ReturnType<typeof changeThumbnail>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { key: string; data: DriveItemChangeThumbnailRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['changeThumbnail'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof changeThumbnail>>,
    { key: string; data: DriveItemChangeThumbnailRequest }
  > = (props) => {
    const { key, data } = props ?? {};

    return changeThumbnail(key, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { key: string; data: DriveItemChangeThumbnailRequest },
    TContext
  >;
};

export type ChangeThumbnailMutationResult = NonNullable<Awaited<ReturnType<typeof changeThumbnail>>>;
export type ChangeThumbnailMutationBody = DriveItemChangeThumbnailRequest;
export type ChangeThumbnailMutationError = unknown;

/**
 * @summary ÏûêÎ£åÏùò Ïç∏ÎÑ§Ïùº Î≥ÄÍ≤Ω
 */
export const useChangeThumbnail = <
  TData = Awaited<ReturnType<typeof changeThumbnail>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { key: string; data: DriveItemChangeThumbnailRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { key: string; data: DriveItemChangeThumbnailRequest }, TContext> => {
  const mutationOptions = getChangeThumbnailMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏûêÎ£åÏóê ÌÉúÍπÖÎêú ÌïôÏÉù Ï†ïÎ≥¥Î•º ÏàòÏ†ïÌï©ÎãàÎã§.
 * @summary ÏûêÎ£åÏóê ÏïÑÏù¥ ÌÉúÍ∑∏ ÏàòÏ†ï
 */
export const updateTaggedStudent = (
  idOrKey: string,
  updateTaggedStudentsRequest: UpdateTaggedStudentsRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseDriveItemResult>(
    {
      url: `/file/v1/drive-items/${idOrKey}/tagged-students`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: updateTaggedStudentsRequest,
    },
    options,
  );
};

export const getUpdateTaggedStudentMutationOptions = <
  TData = Awaited<ReturnType<typeof updateTaggedStudent>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { idOrKey: string; data: UpdateTaggedStudentsRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['updateTaggedStudent'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateTaggedStudent>>,
    { idOrKey: string; data: UpdateTaggedStudentsRequest }
  > = (props) => {
    const { idOrKey, data } = props ?? {};

    return updateTaggedStudent(idOrKey, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { idOrKey: string; data: UpdateTaggedStudentsRequest },
    TContext
  >;
};

export type UpdateTaggedStudentMutationResult = NonNullable<Awaited<ReturnType<typeof updateTaggedStudent>>>;
export type UpdateTaggedStudentMutationBody = UpdateTaggedStudentsRequest;
export type UpdateTaggedStudentMutationError = unknown;

/**
 * @summary ÏûêÎ£åÏóê ÏïÑÏù¥ ÌÉúÍ∑∏ ÏàòÏ†ï
 */
export const useUpdateTaggedStudent = <
  TData = Awaited<ReturnType<typeof updateTaggedStudent>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { idOrKey: string; data: UpdateTaggedStudentsRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { idOrKey: string; data: UpdateTaggedStudentsRequest }, TContext> => {
  const mutationOptions = getUpdateTaggedStudentMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏûêÎ£åÏùò ÌÇ§ÎÇò Ïù¥Ïù¥ÎîîÏôÄ stt ÎÇ¥Ïö©ÏùÑ ÏàòÏ†ïÌï©ÎãàÎã§.
 * @summary ÏùåÏÑ± ÏûêÎ£åÏóê Îì±Î°ùÎêú stt ÏàòÏ†ï
 */
export const updateDriveItemStt = (
  idOrKey: string,
  driveItemSttUpdateRequest: DriveItemSttUpdateRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseString>(
    {
      url: `/file/v1/drive-items/${idOrKey}/modify-audio-stt`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: driveItemSttUpdateRequest,
    },
    options,
  );
};

export const getUpdateDriveItemSttMutationOptions = <
  TData = Awaited<ReturnType<typeof updateDriveItemStt>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { idOrKey: string; data: DriveItemSttUpdateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['updateDriveItemStt'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateDriveItemStt>>,
    { idOrKey: string; data: DriveItemSttUpdateRequest }
  > = (props) => {
    const { idOrKey, data } = props ?? {};

    return updateDriveItemStt(idOrKey, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { idOrKey: string; data: DriveItemSttUpdateRequest },
    TContext
  >;
};

export type UpdateDriveItemSttMutationResult = NonNullable<Awaited<ReturnType<typeof updateDriveItemStt>>>;
export type UpdateDriveItemSttMutationBody = DriveItemSttUpdateRequest;
export type UpdateDriveItemSttMutationError = unknown;

/**
 * @summary ÏùåÏÑ± ÏûêÎ£åÏóê Îì±Î°ùÎêú stt ÏàòÏ†ï
 */
export const useUpdateDriveItemStt = <
  TData = Awaited<ReturnType<typeof updateDriveItemStt>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { idOrKey: string; data: DriveItemSttUpdateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { idOrKey: string; data: DriveItemSttUpdateRequest }, TContext> => {
  const mutationOptions = getUpdateDriveItemSttMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏûêÎ£åÏùò ÌÇ§ÎÇò Ïù¥Ïù¥ÎîîÏôÄ Î©îÎ™®Ïùò ÏïÑÏù¥ÎîîÎ°ú Îì±Î°ùÎêòÏñ¥ ÏûàÎäî Î©îÎ™®Î•º ÏàòÏ†ïÌï©ÎãàÎã§
 * @summary ÏûêÎ£åÏóê Îì±Î°ùÎêú Î©îÎ™® ÏàòÏ†ï
 */
export const updateDriveItemMemo = (
  idOrKey: string,
  memoId: string,
  driveItemMemoUpdateRequest: DriveItemMemoUpdateRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseDriveItemMemoResult>(
    {
      url: `/file/v1/drive-items/${idOrKey}/memos/${memoId}`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: driveItemMemoUpdateRequest,
    },
    options,
  );
};

export const getUpdateDriveItemMemoMutationOptions = <
  TData = Awaited<ReturnType<typeof updateDriveItemMemo>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { idOrKey: string; memoId: string; data: DriveItemMemoUpdateRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['updateDriveItemMemo'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateDriveItemMemo>>,
    { idOrKey: string; memoId: string; data: DriveItemMemoUpdateRequest }
  > = (props) => {
    const { idOrKey, memoId, data } = props ?? {};

    return updateDriveItemMemo(idOrKey, memoId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { idOrKey: string; memoId: string; data: DriveItemMemoUpdateRequest },
    TContext
  >;
};

export type UpdateDriveItemMemoMutationResult = NonNullable<Awaited<ReturnType<typeof updateDriveItemMemo>>>;
export type UpdateDriveItemMemoMutationBody = DriveItemMemoUpdateRequest;
export type UpdateDriveItemMemoMutationError = unknown;

/**
 * @summary ÏûêÎ£åÏóê Îì±Î°ùÎêú Î©îÎ™® ÏàòÏ†ï
 */
export const useUpdateDriveItemMemo = <
  TData = Awaited<ReturnType<typeof updateDriveItemMemo>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { idOrKey: string; memoId: string; data: DriveItemMemoUpdateRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<
  TData,
  TError,
  { idOrKey: string; memoId: string; data: DriveItemMemoUpdateRequest },
  TContext
> => {
  const mutationOptions = getUpdateDriveItemMemoMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏûêÎ£åÏùò ÌÇ§ÎÇò Ïù¥Ïù¥ÎîîÏôÄ Î©îÎ™®Ïùò ÏïÑÏù¥ÎîîÎ°ú Îì±Î°ùÎêòÏñ¥ ÏûàÎäî Î©îÎ™®Î•º ÏÇ≠Ï†úÌï©ÎãàÎã§
 * @summary ÏûêÎ£åÏóê Îì±Î°ùÎêú Î©îÎ™® ÏÇ≠Ï†ú
 */
export const deleteDriveItemMemo = (
  idOrKey: string,
  memoId: string,
  params: DeleteDriveItemMemoParams,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseString>(
    { url: `/file/v1/drive-items/${idOrKey}/memos/${memoId}`, method: 'DELETE', params },
    options,
  );
};

export const getDeleteDriveItemMemoMutationOptions = <
  TData = Awaited<ReturnType<typeof deleteDriveItemMemo>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { idOrKey: string; memoId: string; params: DeleteDriveItemMemoParams },
    TContext
  >;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['deleteDriveItemMemo'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteDriveItemMemo>>,
    { idOrKey: string; memoId: string; params: DeleteDriveItemMemoParams }
  > = (props) => {
    const { idOrKey, memoId, params } = props ?? {};

    return deleteDriveItemMemo(idOrKey, memoId, params, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { idOrKey: string; memoId: string; params: DeleteDriveItemMemoParams },
    TContext
  >;
};

export type DeleteDriveItemMemoMutationResult = NonNullable<Awaited<ReturnType<typeof deleteDriveItemMemo>>>;

export type DeleteDriveItemMemoMutationError = unknown;

/**
 * @summary ÏûêÎ£åÏóê Îì±Î°ùÎêú Î©îÎ™® ÏÇ≠Ï†ú
 */
export const useDeleteDriveItemMemo = <
  TData = Awaited<ReturnType<typeof deleteDriveItemMemo>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { idOrKey: string; memoId: string; params: DeleteDriveItemMemoParams },
    TContext
  >;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<
  TData,
  TError,
  { idOrKey: string; memoId: string; params: DeleteDriveItemMemoParams },
  TContext
> => {
  const mutationOptions = getDeleteDriveItemMemoMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏûêÎ£åÏóê Îì±Î°ùÎêú ÎåìÍ∏ÄÏùÑ ÏàòÏ†ïÌï©ÎãàÎã§.
 * @summary ÎåìÍ∏Ä ÏàòÏ†ï
 */
export const updateReply = (
  driveItemIdOrKey: string,
  replyId: string,
  updateReplyRequest: UpdateReplyRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<unknown>(
    {
      url: `/file/v1/drive-items/${driveItemIdOrKey}/replies/${replyId}`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: updateReplyRequest,
    },
    options,
  );
};

export const getUpdateReplyMutationOptions = <
  TData = Awaited<ReturnType<typeof updateReply>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { driveItemIdOrKey: string; replyId: string; data: UpdateReplyRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['updateReply'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateReply>>,
    { driveItemIdOrKey: string; replyId: string; data: UpdateReplyRequest }
  > = (props) => {
    const { driveItemIdOrKey, replyId, data } = props ?? {};

    return updateReply(driveItemIdOrKey, replyId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { driveItemIdOrKey: string; replyId: string; data: UpdateReplyRequest },
    TContext
  >;
};

export type UpdateReplyMutationResult = NonNullable<Awaited<ReturnType<typeof updateReply>>>;
export type UpdateReplyMutationBody = UpdateReplyRequest;
export type UpdateReplyMutationError = unknown;

/**
 * @summary ÎåìÍ∏Ä ÏàòÏ†ï
 */
export const useUpdateReply = <
  TData = Awaited<ReturnType<typeof updateReply>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { driveItemIdOrKey: string; replyId: string; data: UpdateReplyRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<
  TData,
  TError,
  { driveItemIdOrKey: string; replyId: string; data: UpdateReplyRequest },
  TContext
> => {
  const mutationOptions = getUpdateReplyMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏûêÎ£åÏóê Îì±Î°ùÎêú ÎåìÍ∏ÄÍ≥º ÏûêÏãùÎåìÍ∏ÄÏùÑ ÏÇ≠Ï†úÌï©ÎãàÎã§.
 * @summary ÎåìÍ∏Ä ÏÇ≠Ï†ú
 */
export const deleteReply = (
  driveItemIdOrKey: string,
  replyId: string,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<unknown>(
    { url: `/file/v1/drive-items/${driveItemIdOrKey}/replies/${replyId}`, method: 'DELETE' },
    options,
  );
};

export const getDeleteReplyMutationOptions = <
  TData = Awaited<ReturnType<typeof deleteReply>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { driveItemIdOrKey: string; replyId: string }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['deleteReply'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteReply>>,
    { driveItemIdOrKey: string; replyId: string }
  > = (props) => {
    const { driveItemIdOrKey, replyId } = props ?? {};

    return deleteReply(driveItemIdOrKey, replyId, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { driveItemIdOrKey: string; replyId: string },
    TContext
  >;
};

export type DeleteReplyMutationResult = NonNullable<Awaited<ReturnType<typeof deleteReply>>>;

export type DeleteReplyMutationError = unknown;

/**
 * @summary ÎåìÍ∏Ä ÏÇ≠Ï†ú
 */
export const useDeleteReply = <
  TData = Awaited<ReturnType<typeof deleteReply>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { driveItemIdOrKey: string; replyId: string }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { driveItemIdOrKey: string; replyId: string }, TContext> => {
  const mutationOptions = getDeleteReplyMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Î©îÎ™® ÌååÏùºÏùÑ ÏàòÏ†ïÌï©ÎãàÎã§.
 * @summary Î©îÎ™® ÌååÏùºÏùÑ ÏàòÏ†ïÌïòÎäî api
 */
export const updateMemoFile = (
  memoFileUpdateRequest: MemoFileUpdateRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseSmartFolderItemResult>(
    {
      url: `/file/v1/common-smart-folder/update-memo-file`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: memoFileUpdateRequest,
    },
    options,
  );
};

export const getUpdateMemoFileMutationOptions = <
  TData = Awaited<ReturnType<typeof updateMemoFile>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MemoFileUpdateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['updateMemoFile'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateMemoFile>>, { data: MemoFileUpdateRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return updateMemoFile(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: MemoFileUpdateRequest },
    TContext
  >;
};

export type UpdateMemoFileMutationResult = NonNullable<Awaited<ReturnType<typeof updateMemoFile>>>;
export type UpdateMemoFileMutationBody = MemoFileUpdateRequest;
export type UpdateMemoFileMutationError = unknown;

/**
 * @summary Î©îÎ™® ÌååÏùºÏùÑ ÏàòÏ†ïÌïòÎäî api
 */
export const useUpdateMemoFile = <
  TData = Awaited<ReturnType<typeof updateMemoFile>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MemoFileUpdateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: MemoFileUpdateRequest }, TContext> => {
  const mutationOptions = getUpdateMemoFileMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏöîÏ≤≠Ìïú ÏûêÎ£åÏùò Í≥µÍ∞ú ÏÉÅÌÉúÎ•º Î≥ÄÍ≤ΩÌï©ÎãàÎã§. userEditableÏù¥ falseÏù∏ ÏûêÎ£åÎäî Î≥ÄÍ≤ΩÏù¥ Î∂àÍ∞ÄÎä•Ìï©ÎãàÎã§.ÏÉÅÌÉúÏöîÏ≤≠Ïóê Îî∞Îùº PRIVATE(ÎπÑÍ≥µÍ∞ú), PUBLIC(Í≥µÍ∞ú -> PUBLIC_AND_URL_SHAREÎ°ú ÎîîÌè¥Ìä∏Î°ú ÏÇ¨Ïö©), PRIVATE_AND_URL_SHARE(ÎπÑÍ≥µÍ∞ú+URLÍ≥µÏú†), PUBLIC_AND_URL_SHARE(Í≥µÍ∞ú+URLÍ≥µÏú†) Í∞Ñ Î≥ÄÍ≤ΩÎê©ÎãàÎã§.
 * @summary ÏûêÎ£åÏùò Í≥µÍ∞ú ÏÉÅÌÉú Î≥ÄÍ≤Ω
 */
export const changePublicStateOfItem3 = (
  commonChangeShareStateWithidRequest: CommonChangeShareStateWithidRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseSmartFolderItemResult>(
    {
      url: `/file/v1/common-smart-folder/share`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: commonChangeShareStateWithidRequest,
    },
    options,
  );
};

export const getChangePublicStateOfItem3MutationOptions = <
  TData = Awaited<ReturnType<typeof changePublicStateOfItem3>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CommonChangeShareStateWithidRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['changePublicStateOfItem3'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof changePublicStateOfItem3>>,
    { data: CommonChangeShareStateWithidRequest }
  > = (props) => {
    const { data } = props ?? {};

    return changePublicStateOfItem3(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: CommonChangeShareStateWithidRequest },
    TContext
  >;
};

export type ChangePublicStateOfItem3MutationResult = NonNullable<Awaited<ReturnType<typeof changePublicStateOfItem3>>>;
export type ChangePublicStateOfItem3MutationBody = CommonChangeShareStateWithidRequest;
export type ChangePublicStateOfItem3MutationError = unknown;

/**
 * @summary ÏûêÎ£åÏùò Í≥µÍ∞ú ÏÉÅÌÉú Î≥ÄÍ≤Ω
 */
export const useChangePublicStateOfItem3 = <
  TData = Awaited<ReturnType<typeof changePublicStateOfItem3>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CommonChangeShareStateWithidRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: CommonChangeShareStateWithidRequest }, TContext> => {
  const mutationOptions = getChangePublicStateOfItem3MutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏöîÏ≤≠Ìïú ÏûêÎ£åÏùò Í≥µÍ∞ú ÏÉÅÌÉúÎ•º Î≥ÄÍ≤ΩÌï©ÎãàÎã§. userEditableÏù¥ falseÏù∏ ÏûêÎ£åÎäî Î≥ÄÍ≤ΩÏù¥ Î∂àÍ∞ÄÎä•Ìï©ÎãàÎã§.ÏÉÅÌÉúÏöîÏ≤≠Ïóê Îî∞Îùº PRIVATE(ÎπÑÍ≥µÍ∞ú), PUBLIC(Í≥µÍ∞ú -> PUBLIC_AND_URL_SHAREÎ°ú ÎîîÌè¥Ìä∏Î°ú ÏÇ¨Ïö©), PRIVATE_AND_URL_SHARE(ÎπÑÍ≥µÍ∞ú+URLÍ≥µÏú†), PUBLIC_AND_URL_SHARE(Í≥µÍ∞ú+URLÍ≥µÏú†) Í∞Ñ Î≥ÄÍ≤ΩÎê©ÎãàÎã§.
 * @summary (driveItemKey)ÏûêÎ£åÏùò Í≥µÍ∞ú ÏÉÅÌÉú Î≥ÄÍ≤Ω
 */
export const changePublicStateOfItemWithKey = (
  commonChangeShareStateWithDriveItemKeyRequest: CommonChangeShareStateWithDriveItemKeyRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseSmartFolderItemResult>(
    {
      url: `/file/v1/common-smart-folder/share-with-drive-item-key`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: commonChangeShareStateWithDriveItemKeyRequest,
    },
    options,
  );
};

export const getChangePublicStateOfItemWithKeyMutationOptions = <
  TData = Awaited<ReturnType<typeof changePublicStateOfItemWithKey>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CommonChangeShareStateWithDriveItemKeyRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['changePublicStateOfItemWithKey'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof changePublicStateOfItemWithKey>>,
    { data: CommonChangeShareStateWithDriveItemKeyRequest }
  > = (props) => {
    const { data } = props ?? {};

    return changePublicStateOfItemWithKey(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: CommonChangeShareStateWithDriveItemKeyRequest },
    TContext
  >;
};

export type ChangePublicStateOfItemWithKeyMutationResult = NonNullable<
  Awaited<ReturnType<typeof changePublicStateOfItemWithKey>>
>;
export type ChangePublicStateOfItemWithKeyMutationBody = CommonChangeShareStateWithDriveItemKeyRequest;
export type ChangePublicStateOfItemWithKeyMutationError = unknown;

/**
 * @summary (driveItemKey)ÏûêÎ£åÏùò Í≥µÍ∞ú ÏÉÅÌÉú Î≥ÄÍ≤Ω
 */
export const useChangePublicStateOfItemWithKey = <
  TData = Awaited<ReturnType<typeof changePublicStateOfItemWithKey>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CommonChangeShareStateWithDriveItemKeyRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: CommonChangeShareStateWithDriveItemKeyRequest }, TContext> => {
  const mutationOptions = getChangePublicStateOfItemWithKeyMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏöîÏ≤≠Ìïú ÏûêÎ£åÏùò Ïù¥Î¶ÑÏùÑ Î≥ÄÍ≤ΩÌï©ÎãàÎã§. userEditableÏù¥ falseÏù∏ ÏûêÎ£åÎäî Î≥ÄÍ≤ΩÏù¥ Î∂àÍ∞ÄÎä•Ìï©ÎãàÎã§.
 * @summary ÏûêÎ£åÏùò Ïù¥Î¶Ñ Î≥ÄÍ≤Ω
 */
export const renameItem2 = (
  commonRenameRequest: CommonRenameRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseSmartFolderItemResult>(
    {
      url: `/file/v1/common-smart-folder/rename`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: commonRenameRequest,
    },
    options,
  );
};

export const getRenameItem2MutationOptions = <
  TData = Awaited<ReturnType<typeof renameItem2>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CommonRenameRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['renameItem2'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof renameItem2>>, { data: CommonRenameRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return renameItem2(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: CommonRenameRequest },
    TContext
  >;
};

export type RenameItem2MutationResult = NonNullable<Awaited<ReturnType<typeof renameItem2>>>;
export type RenameItem2MutationBody = CommonRenameRequest;
export type RenameItem2MutationError = unknown;

/**
 * @summary ÏûêÎ£åÏùò Ïù¥Î¶Ñ Î≥ÄÍ≤Ω
 */
export const useRenameItem2 = <
  TData = Awaited<ReturnType<typeof renameItem2>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CommonRenameRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: CommonRenameRequest }, TContext> => {
  const mutationOptions = getRenameItem2MutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏöîÏ≤≠ ÏûêÎ£åÎ•º Ïù¥ÎèôÌï©ÎãàÎã§. ÌååÏùºÎßåÏù¥ÎèôÌïòÍ≥†, Ïù¥Îèô ÏÑ±Í≥µÌïú ÏûêÎ£åÎì§Ïùò ÏµúÏÜå Ï†ïÎ≥¥Î•º Î∞òÌôòÌï©ÎãàÎã§.
 * @summary ÏûêÎ£åÎ•º Ïù¥Îèô
 */
export const moveItem1 = (
  commonMoveItemRequest: CommonMoveItemRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    {
      url: `/file/v1/common-smart-folder/move`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: commonMoveItemRequest,
    },
    options,
  );
};

export const getMoveItem1MutationOptions = <
  TData = Awaited<ReturnType<typeof moveItem1>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CommonMoveItemRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['moveItem1'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof moveItem1>>, { data: CommonMoveItemRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return moveItem1(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: CommonMoveItemRequest },
    TContext
  >;
};

export type MoveItem1MutationResult = NonNullable<Awaited<ReturnType<typeof moveItem1>>>;
export type MoveItem1MutationBody = CommonMoveItemRequest;
export type MoveItem1MutationError = unknown;

/**
 * @summary ÏûêÎ£åÎ•º Ïù¥Îèô
 */
export const useMoveItem1 = <
  TData = Awaited<ReturnType<typeof moveItem1>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CommonMoveItemRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: CommonMoveItemRequest }, TContext> => {
  const mutationOptions = getMoveItem1MutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏöîÏ≤≠ ÏûêÎ£åÎ•º Î≥µÏÇ¨Ìï©ÎãàÎã§. ÌååÏùºÎßå Î≥µÏÇ¨ÌïòÍ≥†, Ïù¥Îèô ÏÑ±Í≥µÌïú ÏûêÎ£åÎì§Ïùò ÏµúÏÜå Ï†ïÎ≥¥Î•º Î∞òÌôòÌï©ÎãàÎã§.
 * @summary ÏûêÎ£åÎ•º Î≥µÏÇ¨
 */
export const copyItem = (
  commonMoveItemRequest: CommonMoveItemRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    {
      url: `/file/v1/common-smart-folder/copy`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: commonMoveItemRequest,
    },
    options,
  );
};

export const getCopyItemMutationOptions = <
  TData = Awaited<ReturnType<typeof copyItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CommonMoveItemRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['copyItem'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof copyItem>>, { data: CommonMoveItemRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return copyItem(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: CommonMoveItemRequest },
    TContext
  >;
};

export type CopyItemMutationResult = NonNullable<Awaited<ReturnType<typeof copyItem>>>;
export type CopyItemMutationBody = CommonMoveItemRequest;
export type CopyItemMutationError = unknown;

/**
 * @summary ÏûêÎ£åÎ•º Î≥µÏÇ¨
 */
export const useCopyItem = <
  TData = Awaited<ReturnType<typeof copyItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CommonMoveItemRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: CommonMoveItemRequest }, TContext> => {
  const mutationOptions = getCopyItemMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏÇ¨Ïö©ÏûêÏùò Ï†ÄÏû•ÏÜåÎ•º Ï¥àÍ∏∞ÌôîÌï©ÎãàÎã§. ÎÇ¥ÎìúÎùºÏù¥Î∏å, ÏûÑÏãúÎ≥¥Í¥ÄÌï®, ÎÇ¥Ìè¥Îçî, Ïä§ÎßàÌä∏Ìè¥Îçî Ï†ÄÏû•ÏÜåÍ∞Ä ÏÉùÏÑ±Îê©ÎãàÎã§.
 * @summary ÌÇ®ÎçîÎ≥¥ÎìúÏö©) ÏÇ¨Ïö©ÏûêÏùò Ï†ÄÏû•ÏÜåÎ•º Ï¥àÍ∏∞Ìôî(Í∞ÄÏûÖÏÑ±Í≥µÏãú Ìò∏Ï∂ú ÌïÑÏöî)
 */
export const createV2 = (
  storageUsageCreateRequest: StorageUsageCreateRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseStorageUsageResult>(
    {
      url: `/file/v2/storage-usages`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: storageUsageCreateRequest,
      signal,
    },
    options,
  );
};

export const getCreateV2MutationOptions = <
  TData = Awaited<ReturnType<typeof createV2>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: StorageUsageCreateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['createV2'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof createV2>>, { data: StorageUsageCreateRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return createV2(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: StorageUsageCreateRequest },
    TContext
  >;
};

export type CreateV2MutationResult = NonNullable<Awaited<ReturnType<typeof createV2>>>;
export type CreateV2MutationBody = StorageUsageCreateRequest;
export type CreateV2MutationError = unknown;

/**
 * @summary ÌÇ®ÎçîÎ≥¥ÎìúÏö©) ÏÇ¨Ïö©ÏûêÏùò Ï†ÄÏû•ÏÜåÎ•º Ï¥àÍ∏∞Ìôî(Í∞ÄÏûÖÏÑ±Í≥µÏãú Ìò∏Ï∂ú ÌïÑÏöî)
 */
export const useCreateV2 = <
  TData = Awaited<ReturnType<typeof createV2>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: StorageUsageCreateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: StorageUsageCreateRequest }, TContext> => {
  const mutationOptions = getCreateV2MutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÎìúÎùºÏù¥Î∏å ÏÇ¨Ïö©ÏûêÏùò Ï†ÄÏû•ÏÜåÎ•º Ï∂îÍ∞ÄÎ°ú Ï¥àÍ∏∞ÌôîÌï©ÎãàÎã§. ÎÇ¥Ìè¥Îçî, Ïä§ÎßàÌä∏Ìè¥Îçî Ï†ÄÏû•ÏÜåÍ∞Ä ÏÉùÏÑ±Îê©ÎãàÎã§.
 * @summary ÎÇ¥Î∂ÄÏÇ¨Ïö©Ïö©) ÎìúÎùºÏù¥Î∏å ÏÇ¨Ïö©ÏûêÏóêÍ≤å ÌÇ®ÎçîÎ≥¥ÎìúÏö© Í∏∞Î≥∏ Ìè¥Îçî ÏÉùÏÑ±
 */
export const createForPrevDriveUser = (
  storageUsageCreateRequest: StorageUsageCreateRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseString>(
    {
      url: `/file/v2/storage-update`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: storageUsageCreateRequest,
      signal,
    },
    options,
  );
};

export const getCreateForPrevDriveUserMutationOptions = <
  TData = Awaited<ReturnType<typeof createForPrevDriveUser>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: StorageUsageCreateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['createForPrevDriveUser'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createForPrevDriveUser>>,
    { data: StorageUsageCreateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createForPrevDriveUser(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: StorageUsageCreateRequest },
    TContext
  >;
};

export type CreateForPrevDriveUserMutationResult = NonNullable<Awaited<ReturnType<typeof createForPrevDriveUser>>>;
export type CreateForPrevDriveUserMutationBody = StorageUsageCreateRequest;
export type CreateForPrevDriveUserMutationError = unknown;

/**
 * @summary ÎÇ¥Î∂ÄÏÇ¨Ïö©Ïö©) ÎìúÎùºÏù¥Î∏å ÏÇ¨Ïö©ÏûêÏóêÍ≤å ÌÇ®ÎçîÎ≥¥ÎìúÏö© Í∏∞Î≥∏ Ìè¥Îçî ÏÉùÏÑ±
 */
export const useCreateForPrevDriveUser = <
  TData = Awaited<ReturnType<typeof createForPrevDriveUser>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: StorageUsageCreateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: StorageUsageCreateRequest }, TContext> => {
  const mutationOptions = getCreateForPrevDriveUserMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏõêÎ≥∏ ÏûêÎ£åÎ•º Îã§Ïö¥ Î∞õÏùÑ Ïàò ÏûàÎäî presigned urlÎ•º ÏöîÏ≤≠ÌïòÎäî api ÏûÖÎãàÎã§.
 * @summary (Í≥µÍ∞úÏûêÎ£åÏö©)ÏûêÎ£åÏùò Îã§Ïö¥Î°úÎìú ÎßÅÌÅ¨ ÏöîÏ≤≠
 */
export const getCdnFilesForDownloadV2 = (
  cdnFileDownloadRequest: CdnFileDownloadRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListCdnFileResult>(
    {
      url: `/file/v2/drive-items/presigned-urls`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: cdnFileDownloadRequest,
      signal,
    },
    options,
  );
};

export const getGetCdnFilesForDownloadV2MutationOptions = <
  TData = Awaited<ReturnType<typeof getCdnFilesForDownloadV2>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CdnFileDownloadRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['getCdnFilesForDownloadV2'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof getCdnFilesForDownloadV2>>,
    { data: CdnFileDownloadRequest }
  > = (props) => {
    const { data } = props ?? {};

    return getCdnFilesForDownloadV2(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: CdnFileDownloadRequest },
    TContext
  >;
};

export type GetCdnFilesForDownloadV2MutationResult = NonNullable<Awaited<ReturnType<typeof getCdnFilesForDownloadV2>>>;
export type GetCdnFilesForDownloadV2MutationBody = CdnFileDownloadRequest;
export type GetCdnFilesForDownloadV2MutationError = unknown;

/**
 * @summary (Í≥µÍ∞úÏûêÎ£åÏö©)ÏûêÎ£åÏùò Îã§Ïö¥Î°úÎìú ÎßÅÌÅ¨ ÏöîÏ≤≠
 */
export const useGetCdnFilesForDownloadV2 = <
  TData = Awaited<ReturnType<typeof getCdnFilesForDownloadV2>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CdnFileDownloadRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: CdnFileDownloadRequest }, TContext> => {
  const mutationOptions = getGetCdnFilesForDownloadV2MutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏÇ¨ÏßÑÍ¥ÄÎ†® ÏûëÏóÖÏùÑ ÏµúÏ¥à Ï†ÄÏû•Ïãú ÏÇ¨Ïö©ÌïòÎäî api ÏûÖÎãàÎã§.    Ïù¥ÎØ∏ÏßÄ ÏûëÏóÖÏùò Ï¢ÖÎ•ò(taskType) => 
STUDENT_CLASSIFICATION : ÏïÑÏù¥ Î∂ÑÎ•ò. 
ACTIVITY_CLASSIFICATION : ÌôúÎèô Î∂ÑÎ•ò. 
STUDENT_AND_ACTIVITY_CLASSIFICATION : ÏïÑÏù¥+ÌôúÎèôÎ∂ÑÎ•ò. 
PHOTO_COMPOSITION : ÏÇ¨ÏßÑ Ìï©ÏÑ±. 
PRIVATE_DATA_ENCRYPTION : Ï¥àÏÉÅÍ∂å Î≥¥Ìò∏. 
SKETCH_CREATION : ÎèÑÏïàÏÉùÏÑ±. 
PHOTO_ALBUM : Ïï®Î≤î ÏÇ¨ÏßÑ Ï†ïÎ¶¨.
 * @summary ÏÇ¨ÏßÑ ÏûëÏóÖ Î°úÍ∑∏ Ï∂îÍ∞Ä
 */
export const createImageTaskLog = (
  imageTaskLogAddRequest: ImageTaskLogAddRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseImageTaskLogResult>(
    {
      url: `/file/v1/task/log/image`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: imageTaskLogAddRequest,
      signal,
    },
    options,
  );
};

export const getCreateImageTaskLogMutationOptions = <
  TData = Awaited<ReturnType<typeof createImageTaskLog>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: ImageTaskLogAddRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['createImageTaskLog'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createImageTaskLog>>,
    { data: ImageTaskLogAddRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createImageTaskLog(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: ImageTaskLogAddRequest },
    TContext
  >;
};

export type CreateImageTaskLogMutationResult = NonNullable<Awaited<ReturnType<typeof createImageTaskLog>>>;
export type CreateImageTaskLogMutationBody = ImageTaskLogAddRequest;
export type CreateImageTaskLogMutationError = unknown;

/**
 * @summary ÏÇ¨ÏßÑ ÏûëÏóÖ Î°úÍ∑∏ Ï∂îÍ∞Ä
 */
export const useCreateImageTaskLog = <
  TData = Awaited<ReturnType<typeof createImageTaskLog>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: ImageTaskLogAddRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: ImageTaskLogAddRequest }, TContext> => {
  const mutationOptions = getCreateImageTaskLogMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏÇ¨Ïö©ÏûêÍ∞Ä ÏßÄÏ†ïÌïú Ìè¥ÎçîÏóê ÏÇ¨ÏßÑÎì§ÏùÑ Ï∂îÍ∞ÄÌï©ÎãàÎã§. Ìè¥ÎçîÎäî Ï∂îÍ∞ÄÌï† Ïàò ÏóÜÏäµÎãàÎã§.ÏÉÅÏúÑ Ìè¥ÎçîÏùò Í≥µÍ∞úÎêú ÏÉÅÌÉúÎ•º Ïù¥Ïñ¥Î∞õÍ≥†, Îã§Î•∏ÏÇ¨ÎûåÏùò ÏûêÎ£åÎ©¥ ÎÇ¥ ÎìúÎùºÏù¥Î∏åÏùò ÎÇ¥ Ìè¥Îçî ÌïòÏúÑÏóê Î≥µÏÇ¨ÎèÑ ÏßÑÌñâÌï©ÎãàÎã§.
 * @summary ÏÇ¨ÏßÑ Ïä§ÎßàÌä∏ Ìè¥ÎçîÏóê ÏÇ¨ÏßÑ Ï∂îÍ∞Ä
 */
export const addPhotoItem = (
  smartFolderItemId: string,
  addDriveItemToMyFolderRequest: AddDriveItemToMyFolderRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseString>(
    {
      url: `/file/v1/smart-folder/photo/${smartFolderItemId}/add-item`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: addDriveItemToMyFolderRequest,
      signal,
    },
    options,
  );
};

export const getAddPhotoItemMutationOptions = <
  TData = Awaited<ReturnType<typeof addPhotoItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { smartFolderItemId: string; data: AddDriveItemToMyFolderRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['addPhotoItem'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addPhotoItem>>,
    { smartFolderItemId: string; data: AddDriveItemToMyFolderRequest }
  > = (props) => {
    const { smartFolderItemId, data } = props ?? {};

    return addPhotoItem(smartFolderItemId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { smartFolderItemId: string; data: AddDriveItemToMyFolderRequest },
    TContext
  >;
};

export type AddPhotoItemMutationResult = NonNullable<Awaited<ReturnType<typeof addPhotoItem>>>;
export type AddPhotoItemMutationBody = AddDriveItemToMyFolderRequest;
export type AddPhotoItemMutationError = unknown;

/**
 * @summary ÏÇ¨ÏßÑ Ïä§ÎßàÌä∏ Ìè¥ÎçîÏóê ÏÇ¨ÏßÑ Ï∂îÍ∞Ä
 */
export const useAddPhotoItem = <
  TData = Awaited<ReturnType<typeof addPhotoItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { smartFolderItemId: string; data: AddDriveItemToMyFolderRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { smartFolderItemId: string; data: AddDriveItemToMyFolderRequest }, TContext> => {
  const mutationOptions = getAddPhotoItemMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏïÑÏù¥ Ìè¥ÎçîÎ•º ÏÉùÏÑ±Ìï©ÎãàÎã§.
 * @summary (ÏïÑÏù¥ Îì±Î°ùÏãú Ìò∏Ï∂úÌïòÍ∏∞ - ÎÇ¥Î∂Ä ÌÜµÏã† apiÎ°ú Î≥ÄÍ≤Ω. Ìò∏Ï∂ú ÏïàÌïòÏÖîÎèÑ Îê®.)Ïö∞Î¶¨Î∞ò ÏÇ¨ÏßÑ Î∂ÑÎ•òÏóê ÏïÑÏù¥ Ìè¥Îçî Ï∂îÍ∞Ä
 */
export const addStudentPhotoFolder = (
  createStudentPhotoFolderRequest: CreateStudentPhotoFolderRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseSmartFolderResult>(
    {
      url: `/file/v1/smart-folder/photo/student/add-folder`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createStudentPhotoFolderRequest,
      signal,
    },
    options,
  );
};

export const getAddStudentPhotoFolderMutationOptions = <
  TData = Awaited<ReturnType<typeof addStudentPhotoFolder>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CreateStudentPhotoFolderRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['addStudentPhotoFolder'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addStudentPhotoFolder>>,
    { data: CreateStudentPhotoFolderRequest }
  > = (props) => {
    const { data } = props ?? {};

    return addStudentPhotoFolder(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: CreateStudentPhotoFolderRequest },
    TContext
  >;
};

export type AddStudentPhotoFolderMutationResult = NonNullable<Awaited<ReturnType<typeof addStudentPhotoFolder>>>;
export type AddStudentPhotoFolderMutationBody = CreateStudentPhotoFolderRequest;
export type AddStudentPhotoFolderMutationError = unknown;

/**
 * @summary (ÏïÑÏù¥ Îì±Î°ùÏãú Ìò∏Ï∂úÌïòÍ∏∞ - ÎÇ¥Î∂Ä ÌÜµÏã† apiÎ°ú Î≥ÄÍ≤Ω. Ìò∏Ï∂ú ÏïàÌïòÏÖîÎèÑ Îê®.)Ïö∞Î¶¨Î∞ò ÏÇ¨ÏßÑ Î∂ÑÎ•òÏóê ÏïÑÏù¥ Ìè¥Îçî Ï∂îÍ∞Ä
 */
export const useAddStudentPhotoFolder = <
  TData = Awaited<ReturnType<typeof addStudentPhotoFolder>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CreateStudentPhotoFolderRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: CreateStudentPhotoFolderRequest }, TContext> => {
  const mutationOptions = getAddStudentPhotoFolderMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏïÑÏù¥ idÎ•º ÏÇ¨Ïö©ÌïòÏó¨ ÏßÄÏ†ïÌïú ÏÇ¨ÏßÑÎì§ÏùÑ ÏïÑÏù¥ Î∂ÑÎ•ò ÏÇ¨ÏßÑ Ìè¥ÎçîÏóê Ï∂îÍ∞ÄÌï©ÎãàÎã§.
 * @summary ÏïÑÏù¥ Î∂ÑÎ•ò ÏÇ¨ÏßÑ Ìè¥ÎçîÏóê ÏÇ¨ÏßÑ Ï∂îÍ∞Ä
 */
export const addStudentPhotoItemWithStudentId = (
  addStudentPhotoRequest: AddStudentPhotoRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseString>(
    {
      url: `/file/v1/smart-folder/photo/add-student-photo`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: addStudentPhotoRequest,
      signal,
    },
    options,
  );
};

export const getAddStudentPhotoItemWithStudentIdMutationOptions = <
  TData = Awaited<ReturnType<typeof addStudentPhotoItemWithStudentId>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: AddStudentPhotoRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['addStudentPhotoItemWithStudentId'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addStudentPhotoItemWithStudentId>>,
    { data: AddStudentPhotoRequest }
  > = (props) => {
    const { data } = props ?? {};

    return addStudentPhotoItemWithStudentId(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: AddStudentPhotoRequest },
    TContext
  >;
};

export type AddStudentPhotoItemWithStudentIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof addStudentPhotoItemWithStudentId>>
>;
export type AddStudentPhotoItemWithStudentIdMutationBody = AddStudentPhotoRequest;
export type AddStudentPhotoItemWithStudentIdMutationError = unknown;

/**
 * @summary ÏïÑÏù¥ Î∂ÑÎ•ò ÏÇ¨ÏßÑ Ìè¥ÎçîÏóê ÏÇ¨ÏßÑ Ï∂îÍ∞Ä
 */
export const useAddStudentPhotoItemWithStudentId = <
  TData = Awaited<ReturnType<typeof addStudentPhotoItemWithStudentId>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: AddStudentPhotoRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: AddStudentPhotoRequest }, TContext> => {
  const mutationOptions = getAddStudentPhotoItemWithStudentIdMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Ìè¥ÎçîÎ•º ÏÉùÏÑ±ÌïòÍ±∞ÎÇò ÏûàÎäî Ìè¥ÎçîÎ•º Ï°∞ÌöåÌïòÎäî apiÏûÖÎãàÎã§.
 * @summary (Ï§ëÎ≥µÌôïÏù∏)ÏÇ¨ÏßÑ Ïä§ÎßàÌä∏Ìè¥ÎçîÏóêÏÑú ÏÇ¨Ïö©ÏûêÏùò Ìè¥Îçî ÏÉùÏÑ± ÌòπÏùÄ Ï°∞Ìöå(Í≥µÏö©)
 */
export const addPhotoFolder = (
  createCommonPhotoSmartFolderRequest: CreateCommonPhotoSmartFolderRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseSmartFolderItemResult>(
    {
      url: `/file/v1/smart-folder/photo/add-folder`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createCommonPhotoSmartFolderRequest,
      signal,
    },
    options,
  );
};

export const getAddPhotoFolderMutationOptions = <
  TData = Awaited<ReturnType<typeof addPhotoFolder>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CreateCommonPhotoSmartFolderRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['addPhotoFolder'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addPhotoFolder>>,
    { data: CreateCommonPhotoSmartFolderRequest }
  > = (props) => {
    const { data } = props ?? {};

    return addPhotoFolder(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: CreateCommonPhotoSmartFolderRequest },
    TContext
  >;
};

export type AddPhotoFolderMutationResult = NonNullable<Awaited<ReturnType<typeof addPhotoFolder>>>;
export type AddPhotoFolderMutationBody = CreateCommonPhotoSmartFolderRequest;
export type AddPhotoFolderMutationError = unknown;

/**
 * @summary (Ï§ëÎ≥µÌôïÏù∏)ÏÇ¨ÏßÑ Ïä§ÎßàÌä∏Ìè¥ÎçîÏóêÏÑú ÏÇ¨Ïö©ÏûêÏùò Ìè¥Îçî ÏÉùÏÑ± ÌòπÏùÄ Ï°∞Ìöå(Í≥µÏö©)
 */
export const useAddPhotoFolder = <
  TData = Awaited<ReturnType<typeof addPhotoFolder>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CreateCommonPhotoSmartFolderRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: CreateCommonPhotoSmartFolderRequest }, TContext> => {
  const mutationOptions = getAddPhotoFolderMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏÇ¨Ïö©ÏûêÍ∞Ä ÏßÄÏ†ïÌïú Î¨∏ÏÑú Ïä§ÎßàÌä∏ Ìè¥ÎçîÏóê ÏûêÎ£åÎì§ÏùÑ Ï∂îÍ∞ÄÌï©ÎãàÎã§. Ìè¥ÎçîÎäî Ï∂îÍ∞ÄÌï† Ïàò ÏóÜÏäµÎãàÎã§.ÏÉÅÏúÑ Ìè¥ÎçîÏùò Í≥µÍ∞úÎêú ÏÉÅÌÉúÎ•º Ïù¥Ïñ¥Î∞õÍ≥†, Îã§Î•∏ÏÇ¨ÎûåÏùò ÏûêÎ£åÎ©¥ ÎÇ¥ ÎìúÎùºÏù¥Î∏åÏùò ÎÇ¥ Ìè¥Îçî ÌïòÏúÑÏóê Î≥µÏÇ¨ÎèÑ ÏßÑÌñâÌï©ÎãàÎã§.
 * @summary Î¨∏ÏÑú Ïä§ÎßàÌä∏ Ìè¥ÎçîÏóê ÏûêÎ£å Ï∂îÍ∞Ä
 */
export const addDocumentItem = (
  smartFolderItemId: string,
  addDriveItemToMyFolderRequest: AddDriveItemToMyFolderRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseString>(
    {
      url: `/file/v1/smart-folder/docs/${smartFolderItemId}/add-item`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: addDriveItemToMyFolderRequest,
      signal,
    },
    options,
  );
};

export const getAddDocumentItemMutationOptions = <
  TData = Awaited<ReturnType<typeof addDocumentItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { smartFolderItemId: string; data: AddDriveItemToMyFolderRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['addDocumentItem'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addDocumentItem>>,
    { smartFolderItemId: string; data: AddDriveItemToMyFolderRequest }
  > = (props) => {
    const { smartFolderItemId, data } = props ?? {};

    return addDocumentItem(smartFolderItemId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { smartFolderItemId: string; data: AddDriveItemToMyFolderRequest },
    TContext
  >;
};

export type AddDocumentItemMutationResult = NonNullable<Awaited<ReturnType<typeof addDocumentItem>>>;
export type AddDocumentItemMutationBody = AddDriveItemToMyFolderRequest;
export type AddDocumentItemMutationError = unknown;

/**
 * @summary Î¨∏ÏÑú Ïä§ÎßàÌä∏ Ìè¥ÎçîÏóê ÏûêÎ£å Ï∂îÍ∞Ä
 */
export const useAddDocumentItem = <
  TData = Awaited<ReturnType<typeof addDocumentItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { smartFolderItemId: string; data: AddDriveItemToMyFolderRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { smartFolderItemId: string; data: AddDriveItemToMyFolderRequest }, TContext> => {
  const mutationOptions = getAddDocumentItemMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Ìè¥ÎçîÎ•º ÏÉùÏÑ±ÌïòÍ±∞ÎÇò ÏûàÎäî Ìè¥ÎçîÎ•º Ï°∞ÌöåÌïòÎäî apiÏûÖÎãàÎã§.
 * @summary (Ï§ëÎ≥µÌôïÏù∏)Î¨∏ÏÑúÏóêÏÑú ÏÇ¨Ïö©ÏûêÏùò Ìè¥Îçî ÏÉùÏÑ± ÌòπÏùÄ Ï°∞Ìöå
 */
export const addDocsFolder = (
  createDocumentSmartFolderRequest: CreateDocumentSmartFolderRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseSmartFolderItemResult>(
    {
      url: `/file/v1/smart-folder/docs/add-folder`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createDocumentSmartFolderRequest,
      signal,
    },
    options,
  );
};

export const getAddDocsFolderMutationOptions = <
  TData = Awaited<ReturnType<typeof addDocsFolder>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CreateDocumentSmartFolderRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['addDocsFolder'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addDocsFolder>>,
    { data: CreateDocumentSmartFolderRequest }
  > = (props) => {
    const { data } = props ?? {};

    return addDocsFolder(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: CreateDocumentSmartFolderRequest },
    TContext
  >;
};

export type AddDocsFolderMutationResult = NonNullable<Awaited<ReturnType<typeof addDocsFolder>>>;
export type AddDocsFolderMutationBody = CreateDocumentSmartFolderRequest;
export type AddDocsFolderMutationError = unknown;

/**
 * @summary (Ï§ëÎ≥µÌôïÏù∏)Î¨∏ÏÑúÏóêÏÑú ÏÇ¨Ïö©ÏûêÏùò Ìè¥Îçî ÏÉùÏÑ± ÌòπÏùÄ Ï°∞Ìöå
 */
export const useAddDocsFolder = <
  TData = Awaited<ReturnType<typeof addDocsFolder>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CreateDocumentSmartFolderRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: CreateDocumentSmartFolderRequest }, TContext> => {
  const mutationOptions = getAddDocsFolderMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Ï∂îÏ≤úÎêú ÏûêÎ£åÎ•º Îçî Ïù¥ÏÉÅ Ï∂îÏ≤úÎ∞õÏßÄ ÏïäÎèÑÎ°ù Ìï©ÎãàÎã§. ÏÑ±Í≥µÌïòÎ©¥ resultÏóê trueÎ•º Î∞òÌôòÌï©ÎãàÎã§.
 * @summary Ï∂îÏ≤úÎêú ÏûêÎ£åÎ•º Îã§Ïãú Ï∂îÏ≤úÎêòÏßÄ ÏïäÎèÑÎ°ù ÌïòÎäî api
 */
export const rejectRecommendationItem = (
  rejectRecommendationItemRequest: RejectRecommendationItemRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseBoolean>(
    {
      url: `/file/v1/recommendation/reject`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: rejectRecommendationItemRequest,
      signal,
    },
    options,
  );
};

export const getRejectRecommendationItemMutationOptions = <
  TData = Awaited<ReturnType<typeof rejectRecommendationItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: RejectRecommendationItemRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['rejectRecommendationItem'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof rejectRecommendationItem>>,
    { data: RejectRecommendationItemRequest }
  > = (props) => {
    const { data } = props ?? {};

    return rejectRecommendationItem(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: RejectRecommendationItemRequest },
    TContext
  >;
};

export type RejectRecommendationItemMutationResult = NonNullable<Awaited<ReturnType<typeof rejectRecommendationItem>>>;
export type RejectRecommendationItemMutationBody = RejectRecommendationItemRequest;
export type RejectRecommendationItemMutationError = unknown;

/**
 * @summary Ï∂îÏ≤úÎêú ÏûêÎ£åÎ•º Îã§Ïãú Ï∂îÏ≤úÎêòÏßÄ ÏïäÎèÑÎ°ù ÌïòÎäî api
 */
export const useRejectRecommendationItem = <
  TData = Awaited<ReturnType<typeof rejectRecommendationItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: RejectRecommendationItemRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: RejectRecommendationItemRequest }, TContext> => {
  const mutationOptions = getRejectRecommendationItemMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÎÇ†Ïßú Í∏∞Ï§ÄÏúºÎ°ú Ï∂îÏ≤ú ÌÇ§ÏõåÎìú Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary Ï∂îÏ≤ú ÌÇ§ÏõåÎìú ÏñªÍ∏∞
 */
export const getRecommendationKeyword = (
  params?: GetRecommendationKeywordParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListString>(
    { url: `/file/v1/recommendation/common-keywords`, method: 'GET', params, signal },
    options,
  );
};

export const getGetRecommendationKeywordQueryKey = (params?: GetRecommendationKeywordParams) => {
  return [`/file/v1/recommendation/common-keywords`, ...(params ? [params] : [])] as const;
};

export const getGetRecommendationKeywordQueryOptions = <
  TData = Awaited<ReturnType<typeof getRecommendationKeyword>>,
  TError = unknown,
>(
  params?: GetRecommendationKeywordParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendationKeyword>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRecommendationKeywordQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecommendationKeyword>>> = ({ signal }) =>
    getRecommendationKeyword(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRecommendationKeyword>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetRecommendationKeywordQueryResult = NonNullable<Awaited<ReturnType<typeof getRecommendationKeyword>>>;
export type GetRecommendationKeywordQueryError = unknown;

export function useGetRecommendationKeyword<
  TData = Awaited<ReturnType<typeof getRecommendationKeyword>>,
  TError = unknown,
>(
  params: undefined | GetRecommendationKeywordParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendationKeyword>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getRecommendationKeyword>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetRecommendationKeyword<
  TData = Awaited<ReturnType<typeof getRecommendationKeyword>>,
  TError = unknown,
>(
  params?: GetRecommendationKeywordParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendationKeyword>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getRecommendationKeyword>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetRecommendationKeyword<
  TData = Awaited<ReturnType<typeof getRecommendationKeyword>>,
  TError = unknown,
>(
  params?: GetRecommendationKeywordParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendationKeyword>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Ï∂îÏ≤ú ÌÇ§ÏõåÎìú ÏñªÍ∏∞
 */

export function useGetRecommendationKeyword<
  TData = Awaited<ReturnType<typeof getRecommendationKeyword>>,
  TError = unknown,
>(
  params?: GetRecommendationKeywordParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendationKeyword>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetRecommendationKeywordQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Ï∂îÏ≤úÌï† ÌÇ§ÏõåÎìúÎ•º Îì±Î°ùÌï©ÎãàÎã§.
 * @summary Ï∂îÏ≤ú ÌÇ§ÏõåÎìú Îì±Î°ù
 */
export const addRecommendationKeyword = (
  recommendationKeywordBundleAddRequest: RecommendationKeywordBundleAddRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseRecommendationKeywordBundleResult>(
    {
      url: `/file/v1/recommendation/common-keywords`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: recommendationKeywordBundleAddRequest,
      signal,
    },
    options,
  );
};

export const getAddRecommendationKeywordMutationOptions = <
  TData = Awaited<ReturnType<typeof addRecommendationKeyword>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: RecommendationKeywordBundleAddRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['addRecommendationKeyword'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addRecommendationKeyword>>,
    { data: RecommendationKeywordBundleAddRequest }
  > = (props) => {
    const { data } = props ?? {};

    return addRecommendationKeyword(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: RecommendationKeywordBundleAddRequest },
    TContext
  >;
};

export type AddRecommendationKeywordMutationResult = NonNullable<Awaited<ReturnType<typeof addRecommendationKeyword>>>;
export type AddRecommendationKeywordMutationBody = RecommendationKeywordBundleAddRequest;
export type AddRecommendationKeywordMutationError = unknown;

/**
 * @summary Ï∂îÏ≤ú ÌÇ§ÏõåÎìú Îì±Î°ù
 */
export const useAddRecommendationKeyword = <
  TData = Awaited<ReturnType<typeof addRecommendationKeyword>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: RecommendationKeywordBundleAddRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: RecommendationKeywordBundleAddRequest }, TContext> => {
  const mutationOptions = getAddRecommendationKeywordMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Ìè¥ÎçîÎ•º ÏÉùÏÑ±ÌïòÍ±∞ÎÇò ÏûàÎäî Ìè¥ÎçîÎ•º Ï°∞ÌöåÌïòÎäî apiÏûÖÎãàÎã§.parentSmartFolderId Î•º Ï†ÑÎã¨ÌïòÏßÄ ÏïäÏúºÏãúÎ©¥ ÎÇ¥Ìè¥Îçî ÌôàÏóê Ï∂îÍ∞Ä Îê©ÎãàÎã§.
 * @summary (Ï§ëÎ≥µÌôïÏù∏)Ìè¥Îçî ÏÉùÏÑ±
 */
export const addFolder = (
  createMyFolderRequest: CreateMyFolderRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseSmartFolderItemResult>(
    {
      url: `/file/v1/my-folder`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createMyFolderRequest,
      signal,
    },
    options,
  );
};

export const getAddFolderMutationOptions = <
  TData = Awaited<ReturnType<typeof addFolder>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CreateMyFolderRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['addFolder'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof addFolder>>, { data: CreateMyFolderRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return addFolder(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: CreateMyFolderRequest },
    TContext
  >;
};

export type AddFolderMutationResult = NonNullable<Awaited<ReturnType<typeof addFolder>>>;
export type AddFolderMutationBody = CreateMyFolderRequest;
export type AddFolderMutationError = unknown;

/**
 * @summary (Ï§ëÎ≥µÌôïÏù∏)Ìè¥Îçî ÏÉùÏÑ±
 */
export const useAddFolder = <
  TData = Awaited<ReturnType<typeof addFolder>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CreateMyFolderRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: CreateMyFolderRequest }, TContext> => {
  const mutationOptions = getAddFolderMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏßÄÏ†ïÌïú ÎÇ¥Ìè¥ÎçîÏùò idÎ°ú ÏûêÎ£å Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÎÇ¥ Ìè¥ÎçîÏùò ÏûêÎ£å Î¶¨Ïä§Ìä∏ Ï°∞Ìöå
 */
export const getIncludedItemsDeprecate = (
  smartFolderItemid: string,
  params?: GetIncludedItemsDeprecateParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/file/v1/my-folder/${smartFolderItemid}`, method: 'GET', params, signal },
    options,
  );
};

export const getGetIncludedItemsDeprecateQueryKey = (
  smartFolderItemid: string,
  params?: GetIncludedItemsDeprecateParams,
) => {
  return [`/file/v1/my-folder/${smartFolderItemid}`, ...(params ? [params] : [])] as const;
};

export const getGetIncludedItemsDeprecateQueryOptions = <
  TData = Awaited<ReturnType<typeof getIncludedItemsDeprecate>>,
  TError = unknown,
>(
  smartFolderItemid: string,
  params?: GetIncludedItemsDeprecateParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncludedItemsDeprecate>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetIncludedItemsDeprecateQueryKey(smartFolderItemid, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getIncludedItemsDeprecate>>> = ({ signal }) =>
    getIncludedItemsDeprecate(smartFolderItemid, params, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!smartFolderItemid, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getIncludedItemsDeprecate>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetIncludedItemsDeprecateQueryResult = NonNullable<Awaited<ReturnType<typeof getIncludedItemsDeprecate>>>;
export type GetIncludedItemsDeprecateQueryError = unknown;

export function useGetIncludedItemsDeprecate<
  TData = Awaited<ReturnType<typeof getIncludedItemsDeprecate>>,
  TError = unknown,
>(
  smartFolderItemid: string,
  params: undefined | GetIncludedItemsDeprecateParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncludedItemsDeprecate>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getIncludedItemsDeprecate>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetIncludedItemsDeprecate<
  TData = Awaited<ReturnType<typeof getIncludedItemsDeprecate>>,
  TError = unknown,
>(
  smartFolderItemid: string,
  params?: GetIncludedItemsDeprecateParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncludedItemsDeprecate>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getIncludedItemsDeprecate>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetIncludedItemsDeprecate<
  TData = Awaited<ReturnType<typeof getIncludedItemsDeprecate>>,
  TError = unknown,
>(
  smartFolderItemid: string,
  params?: GetIncludedItemsDeprecateParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncludedItemsDeprecate>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÎÇ¥ Ìè¥ÎçîÏùò ÏûêÎ£å Î¶¨Ïä§Ìä∏ Ï°∞Ìöå
 */

export function useGetIncludedItemsDeprecate<
  TData = Awaited<ReturnType<typeof getIncludedItemsDeprecate>>,
  TError = unknown,
>(
  smartFolderItemid: string,
  params?: GetIncludedItemsDeprecateParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncludedItemsDeprecate>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetIncludedItemsDeprecateQueryOptions(smartFolderItemid, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÇ¨Ïö©ÏûêÍ∞Ä ÏßÄÏ†ïÌïú ÎÇ¥ Ìè¥ÎçîÏóê ÏûêÎ£åÎì§ÏùÑ Ï∂îÍ∞ÄÌï©ÎãàÎîî. Ìè¥ÎçîÎäî Ï∂îÍ∞ÄÌï† Ïàò ÏóÜÏäµÎãàÎã§.ÏÉÅÏúÑ Ìè¥ÎçîÏùò Í≥µÍ∞úÎêú ÏÉÅÌÉúÎ•º Ïù¥Ïñ¥Î∞õÍ≥†, Îã§Î•∏ÏÇ¨ÎûåÏùò ÏûêÎ£åÎ©¥ ÎÇ¥ ÎìúÎùºÏù¥Î∏åÏùò ÎÇ¥ Ìè¥Îçî ÌïòÏúÑÏóê Î≥µÏÇ¨ÎèÑ ÏßÑÌñâÌï©ÎãàÎã§.
 * @summary ÎÇ¥ Ìè¥ÎçîÏóê ÏûêÎ£å Ï∂îÍ∞Ä
 */
export const addDriveItem = (
  smartFolderItemid: string,
  addDriveItemToMyFolderRequest: AddDriveItemToMyFolderRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseString>(
    {
      url: `/file/v1/my-folder/${smartFolderItemid}`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: addDriveItemToMyFolderRequest,
      signal,
    },
    options,
  );
};

export const getAddDriveItemMutationOptions = <
  TData = Awaited<ReturnType<typeof addDriveItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { smartFolderItemid: string; data: AddDriveItemToMyFolderRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['addDriveItem'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addDriveItem>>,
    { smartFolderItemid: string; data: AddDriveItemToMyFolderRequest }
  > = (props) => {
    const { smartFolderItemid, data } = props ?? {};

    return addDriveItem(smartFolderItemid, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { smartFolderItemid: string; data: AddDriveItemToMyFolderRequest },
    TContext
  >;
};

export type AddDriveItemMutationResult = NonNullable<Awaited<ReturnType<typeof addDriveItem>>>;
export type AddDriveItemMutationBody = AddDriveItemToMyFolderRequest;
export type AddDriveItemMutationError = unknown;

/**
 * @summary ÎÇ¥ Ìè¥ÎçîÏóê ÏûêÎ£å Ï∂îÍ∞Ä
 */
export const useAddDriveItem = <
  TData = Awaited<ReturnType<typeof addDriveItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { smartFolderItemid: string; data: AddDriveItemToMyFolderRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { smartFolderItemid: string; data: AddDriveItemToMyFolderRequest }, TContext> => {
  const mutationOptions = getAddDriveItemMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÎßàÏù¥Î≥¥ÎìúÏóêÏÑú ÌÉ≠ Î≥ÑÎ°ú Î≥¥Ïó¨Ï§Ñ ÏûêÎ£å Î¶¨Ïä§Ìä∏Ïóê ÏûêÎ£åÎ•º Ï∂îÍ∞ÄÌï©ÎãàÎã§. Ï∂îÍ∞ÄÎêú ÏûêÎ£å ÎßåÌÅº Í≤åÏãúÍ∏Ä ÏàòÍ∞Ä ÏûêÎèôÏúºÎ°ú Ïò¨ÎùºÍ∞ëÎãàÎã§.
 * @summary ÎßàÏù¥Î≥¥ÎìúÏóêÏÑú Î≥¥Ïó¨Ï§Ñ ÏûêÎ£åÎ•º Ï∂îÍ∞Ä Ìï©ÎãàÎã§.
 */
export const addItemsToMyBoard = (
  profileId: string,
  addDriveItemToMyBoardRequest: AddDriveItemToMyBoardRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseString>(
    {
      url: `/file/v1/my-board/${profileId}/add-item`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: addDriveItemToMyBoardRequest,
      signal,
    },
    options,
  );
};

export const getAddItemsToMyBoardMutationOptions = <
  TData = Awaited<ReturnType<typeof addItemsToMyBoard>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { profileId: string; data: AddDriveItemToMyBoardRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['addItemsToMyBoard'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addItemsToMyBoard>>,
    { profileId: string; data: AddDriveItemToMyBoardRequest }
  > = (props) => {
    const { profileId, data } = props ?? {};

    return addItemsToMyBoard(profileId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { profileId: string; data: AddDriveItemToMyBoardRequest },
    TContext
  >;
};

export type AddItemsToMyBoardMutationResult = NonNullable<Awaited<ReturnType<typeof addItemsToMyBoard>>>;
export type AddItemsToMyBoardMutationBody = AddDriveItemToMyBoardRequest;
export type AddItemsToMyBoardMutationError = unknown;

/**
 * @summary ÎßàÏù¥Î≥¥ÎìúÏóêÏÑú Î≥¥Ïó¨Ï§Ñ ÏûêÎ£åÎ•º Ï∂îÍ∞Ä Ìï©ÎãàÎã§.
 */
export const useAddItemsToMyBoard = <
  TData = Awaited<ReturnType<typeof addItemsToMyBoard>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { profileId: string; data: AddDriveItemToMyBoardRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { profileId: string; data: AddDriveItemToMyBoardRequest }, TContext> => {
  const mutationOptions = getAddItemsToMyBoardMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÎÜÄÏù¥Î≥¥Í≥†ÏÑú ÏÉùÏÑ±ÏöîÏ≤≠Ìïú Î°úÍ∑∏Î•º Ï†ÄÏû•Ìï©ÎãàÎã§.
 * @summary aiÏóêÍ≤å ÎÜÄÏù¥Î≥¥Í≥†ÏÑú ÏÉùÏÑ± ÏöîÏ≤≠ Î°úÍ∑∏ Ï†ÄÏû•
 */
export const createLectureReportAiLog = (
  lectureReportCardAiCreationLogAddRequest: LectureReportCardAiCreationLogAddRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseLectureReportCardAiCreationLogResult>(
    {
      url: `/file/v1/lecture-report/card-ai-creation-log`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: lectureReportCardAiCreationLogAddRequest,
      signal,
    },
    options,
  );
};

export const getCreateLectureReportAiLogMutationOptions = <
  TData = Awaited<ReturnType<typeof createLectureReportAiLog>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: LectureReportCardAiCreationLogAddRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['createLectureReportAiLog'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createLectureReportAiLog>>,
    { data: LectureReportCardAiCreationLogAddRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createLectureReportAiLog(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: LectureReportCardAiCreationLogAddRequest },
    TContext
  >;
};

export type CreateLectureReportAiLogMutationResult = NonNullable<Awaited<ReturnType<typeof createLectureReportAiLog>>>;
export type CreateLectureReportAiLogMutationBody = LectureReportCardAiCreationLogAddRequest;
export type CreateLectureReportAiLogMutationError = unknown;

/**
 * @summary aiÏóêÍ≤å ÎÜÄÏù¥Î≥¥Í≥†ÏÑú ÏÉùÏÑ± ÏöîÏ≤≠ Î°úÍ∑∏ Ï†ÄÏû•
 */
export const useCreateLectureReportAiLog = <
  TData = Awaited<ReturnType<typeof createLectureReportAiLog>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: LectureReportCardAiCreationLogAddRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: LectureReportCardAiCreationLogAddRequest }, TContext> => {
  const mutationOptions = getCreateLectureReportAiLogMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏóÖÎ°úÎìúÌï† ÏûêÎ£åÏùò Ï†ïÎ≥¥Î•º Îì±Î°ùÌïòÍ≥† ÏóÖÎ°úÎìúÌï† presigned urlÏùë ÏÉùÏÑ± ÏöîÏ≤≠Ìï©ÎãàÎã§.
ÏóÖÎ°úÎìú ÏàúÏÑú.
1. Ïù¥ apiÎ°ú ÏóÖÎ°úÎìúÌï† presigned url ÏÉùÏÑ± ÏöîÏ≤≠. Ïù¥Îïå Ï†ÑÎã¨Î∞õÏùÄ id Í∏∞Ïñµ ÌïÑÏöî
2. Ï†ÑÎã¨ Î∞õÏùÄ presigned urlÎ°ú ÌååÏùº ÏóÖÎ°úÎìú
3. ÏóÖÎ°úÎìúÍ∞Ä ÏôÑÎ£åÎêòÎ©¥ 1ÏóêÏÑú Ï†ÑÎã¨ Î∞õÏùÄ id(result Î∞∞Ïó¥ÏÜç ÏõêÎ≥∏ ÌååÏùºÏùò id = fileObject.id)ÏôÄ ÌååÏùºÏùò Ï†ïÎ≥¥Î•º Îì±Î°ùÌïòÎ©∞ ÏóÖÎ°úÎìú ÌîÑÎ°úÏÑ∏Ïä§Î•º ÏôÑÎ£å
   [ÌîÑÎ°úÌïÑÏÇ¨ÏßÑÎ•ò(presigned url ÏÉùÏÑ±Ìï†Îïå ÏÜåÏä§ PROFILE Ïùº Îïå) ÏôÑÎ£åÌñàÏùÑÎïåÎäî 2Î≤àÎåÄÏã† [PUT] /file/v1/file-objects/{id}/uploaded]
 * @summary ÌååÏùºÏùò ÏóÖÎ°úÎìúÌï† resigned urlÏùÑ ÏÉùÏÑ± ÏöîÏ≤≠
 */
export const uploadPrepare = (
  fileObjectUploadRequest: FileObjectUploadRequest[],
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListFileObjectResult>(
    {
      url: `/file/v1/file-objects`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: fileObjectUploadRequest,
      signal,
    },
    options,
  );
};

export const getUploadPrepareMutationOptions = <
  TData = Awaited<ReturnType<typeof uploadPrepare>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: FileObjectUploadRequest[] }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['uploadPrepare'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof uploadPrepare>>, { data: FileObjectUploadRequest[] }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return uploadPrepare(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: FileObjectUploadRequest[] },
    TContext
  >;
};

export type UploadPrepareMutationResult = NonNullable<Awaited<ReturnType<typeof uploadPrepare>>>;
export type UploadPrepareMutationBody = FileObjectUploadRequest[];
export type UploadPrepareMutationError = unknown;

/**
 * @summary ÌååÏùºÏùò ÏóÖÎ°úÎìúÌï† resigned urlÏùÑ ÏÉùÏÑ± ÏöîÏ≤≠
 */
export const useUploadPrepare = <
  TData = Awaited<ReturnType<typeof uploadPrepare>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: FileObjectUploadRequest[] }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: FileObjectUploadRequest[] }, TContext> => {
  const mutationOptions = getUploadPrepareMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏûêÎ£åÏùò ÌÇ§ Í∞íÎì§Î°ú Ïç∏ÎÑ§Ïùº Ï£ºÏÜåÎ•º ÏöîÏ≤≠Ìï©ÎãàÎã§.
 * @summary ÌååÏùºÏùò Ïç∏ÎÑ§Ïùº url ÎßÅÌÅ¨ ÏöîÏ≤≠
 */
export const getThumbUrls = (
  fileObjectThumbUrlsPostRequest: FileObjectThumbUrlsPostRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseMapStringString>(
    {
      url: `/file/v1/file-objects/thumb-urls`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: fileObjectThumbUrlsPostRequest,
      signal,
    },
    options,
  );
};

export const getGetThumbUrlsMutationOptions = <
  TData = Awaited<ReturnType<typeof getThumbUrls>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: FileObjectThumbUrlsPostRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['getThumbUrls'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof getThumbUrls>>,
    { data: FileObjectThumbUrlsPostRequest }
  > = (props) => {
    const { data } = props ?? {};

    return getThumbUrls(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: FileObjectThumbUrlsPostRequest },
    TContext
  >;
};

export type GetThumbUrlsMutationResult = NonNullable<Awaited<ReturnType<typeof getThumbUrls>>>;
export type GetThumbUrlsMutationBody = FileObjectThumbUrlsPostRequest;
export type GetThumbUrlsMutationError = unknown;

/**
 * @summary ÌååÏùºÏùò Ïç∏ÎÑ§Ïùº url ÎßÅÌÅ¨ ÏöîÏ≤≠
 */
export const useGetThumbUrls = <
  TData = Awaited<ReturnType<typeof getThumbUrls>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: FileObjectThumbUrlsPostRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: FileObjectThumbUrlsPostRequest }, TContext> => {
  const mutationOptions = getGetThumbUrlsMutationOptions(options);

  return useMutation(mutationOptions);
};

export const updateStt = (
  fileObjectSttTextPostRequest: FileObjectSttTextPostRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseFileObjectSttTextPostResponse>(
    {
      url: `/file/v1/file-objects/sttFullText`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: fileObjectSttTextPostRequest,
      signal,
    },
    options,
  );
};

export const getUpdateSttMutationOptions = <
  TData = Awaited<ReturnType<typeof updateStt>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: FileObjectSttTextPostRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['updateStt'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateStt>>, { data: FileObjectSttTextPostRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return updateStt(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: FileObjectSttTextPostRequest },
    TContext
  >;
};

export type UpdateSttMutationResult = NonNullable<Awaited<ReturnType<typeof updateStt>>>;
export type UpdateSttMutationBody = FileObjectSttTextPostRequest;
export type UpdateSttMutationError = unknown;

export const useUpdateStt = <
  TData = Awaited<ReturnType<typeof updateStt>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: FileObjectSttTextPostRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: FileObjectSttTextPostRequest }, TContext> => {
  const mutationOptions = getUpdateSttMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏûêÎ£åÎ•º Î¥§Îã§Í≥† ÌåêÎã® ÎêòÎäî Í≤ΩÏö∞ Ìò∏Ï∂úÌï©ÎãàÎã§. ÏùëÎãµÏóî Ìï¥Îãπ ÏûêÎ£åÏùò Î∑∞Ïπ¥Ïö¥Ìä∏Í∞Ä ÏùëÎãµÎê©ÎãàÎã§.(10Ï¥à Ïù¥ÎÇ¥Î°ú Í∞ôÏùÄ ÏÇ¨Ïö©ÏûêÍ∞Ä Í∞ôÏùÄ ÏûêÎ£åÏóê ÎåÄÌï¥ÏÑú ÏöîÏ≤≠ÌïòÎ©¥ Î¨¥ÏãúÎê©ÎãàÎã§. Î≥∏Ïù∏Ïù¥ ÏÜåÏú†Ìïú ÏûêÎ£åÎ•º Î∑∞ Ï≤òÎ¶¨Ìï¥ÎèÑ Î¨¥ÏãúÎê©ÎãàÎã§.)
 * @summary ÏûêÎ£å Î∑∞ Ï≤òÎ¶¨
 */
export const addViewCount = (
  idOrKey: string,
  addDriveItemViewCountRequest: AddDriveItemViewCountRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseInteger>(
    {
      url: `/file/v1/drive-items/${idOrKey}/view`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: addDriveItemViewCountRequest,
      signal,
    },
    options,
  );
};

export const getAddViewCountMutationOptions = <
  TData = Awaited<ReturnType<typeof addViewCount>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { idOrKey: string; data: AddDriveItemViewCountRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['addViewCount'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addViewCount>>,
    { idOrKey: string; data: AddDriveItemViewCountRequest }
  > = (props) => {
    const { idOrKey, data } = props ?? {};

    return addViewCount(idOrKey, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { idOrKey: string; data: AddDriveItemViewCountRequest },
    TContext
  >;
};

export type AddViewCountMutationResult = NonNullable<Awaited<ReturnType<typeof addViewCount>>>;
export type AddViewCountMutationBody = AddDriveItemViewCountRequest;
export type AddViewCountMutationError = unknown;

/**
 * @summary ÏûêÎ£å Î∑∞ Ï≤òÎ¶¨
 */
export const useAddViewCount = <
  TData = Awaited<ReturnType<typeof addViewCount>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { idOrKey: string; data: AddDriveItemViewCountRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { idOrKey: string; data: AddDriveItemViewCountRequest }, TContext> => {
  const mutationOptions = getAddViewCountMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏûêÎ£åÏóê Îì±Î°ùÎêòÏñ¥ ÏûàÎäî Î©îÎ™® Î¶¨Ïä§Ìä∏Î•º Ï°∞ÌöåÌï©ÎãàÎã§  (1Ï∞®ÏóêÏÑúÎäî 1Í∞úÏî©Îßå ÏÇ¨Ïö©)
 * @summary ÏûêÎ£åÏóê Îì±Î°ùÎêú Î©îÎ™® Ï°∞Ìöå
 */
export const getDriveItemMemos = (
  idOrKey: string,
  params: GetDriveItemMemosParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListDriveItemMemoResult>(
    { url: `/file/v1/drive-items/${idOrKey}/memos`, method: 'GET', params, signal },
    options,
  );
};

export const getGetDriveItemMemosQueryKey = (idOrKey: string, params: GetDriveItemMemosParams) => {
  return [`/file/v1/drive-items/${idOrKey}/memos`, ...(params ? [params] : [])] as const;
};

export const getGetDriveItemMemosQueryOptions = <
  TData = Awaited<ReturnType<typeof getDriveItemMemos>>,
  TError = unknown,
>(
  idOrKey: string,
  params: GetDriveItemMemosParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDriveItemMemos>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDriveItemMemosQueryKey(idOrKey, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDriveItemMemos>>> = ({ signal }) =>
    getDriveItemMemos(idOrKey, params, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!idOrKey, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getDriveItemMemos>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetDriveItemMemosQueryResult = NonNullable<Awaited<ReturnType<typeof getDriveItemMemos>>>;
export type GetDriveItemMemosQueryError = unknown;

export function useGetDriveItemMemos<TData = Awaited<ReturnType<typeof getDriveItemMemos>>, TError = unknown>(
  idOrKey: string,
  params: GetDriveItemMemosParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDriveItemMemos>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getDriveItemMemos>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetDriveItemMemos<TData = Awaited<ReturnType<typeof getDriveItemMemos>>, TError = unknown>(
  idOrKey: string,
  params: GetDriveItemMemosParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDriveItemMemos>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getDriveItemMemos>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetDriveItemMemos<TData = Awaited<ReturnType<typeof getDriveItemMemos>>, TError = unknown>(
  idOrKey: string,
  params: GetDriveItemMemosParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDriveItemMemos>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÏûêÎ£åÏóê Îì±Î°ùÎêú Î©îÎ™® Ï°∞Ìöå
 */

export function useGetDriveItemMemos<TData = Awaited<ReturnType<typeof getDriveItemMemos>>, TError = unknown>(
  idOrKey: string,
  params: GetDriveItemMemosParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDriveItemMemos>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetDriveItemMemosQueryOptions(idOrKey, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏûêÎ£åÏóê Î©îÎ™®Î•º Ï∂îÍ∞ÄÌï©ÎãàÎã§. (1Ï∞®ÏóêÏÑúÎäî ÏÇ¨ÏßÑ Î©îÎ™®Îßå)
 * @summary ÏûêÎ£å(ÏÇ¨ÏßÑ)Ïóê Î©îÎ™® Îì±Î°ù
 */
export const addMemoToFile = (
  idOrKey: string,
  driveItemMemoAddRequest: DriveItemMemoAddRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseDriveItemMemoResult>(
    {
      url: `/file/v1/drive-items/${idOrKey}/memos`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: driveItemMemoAddRequest,
      signal,
    },
    options,
  );
};

export const getAddMemoToFileMutationOptions = <
  TData = Awaited<ReturnType<typeof addMemoToFile>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { idOrKey: string; data: DriveItemMemoAddRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['addMemoToFile'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addMemoToFile>>,
    { idOrKey: string; data: DriveItemMemoAddRequest }
  > = (props) => {
    const { idOrKey, data } = props ?? {};

    return addMemoToFile(idOrKey, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { idOrKey: string; data: DriveItemMemoAddRequest },
    TContext
  >;
};

export type AddMemoToFileMutationResult = NonNullable<Awaited<ReturnType<typeof addMemoToFile>>>;
export type AddMemoToFileMutationBody = DriveItemMemoAddRequest;
export type AddMemoToFileMutationError = unknown;

/**
 * @summary ÏûêÎ£å(ÏÇ¨ÏßÑ)Ïóê Î©îÎ™® Îì±Î°ù
 */
export const useAddMemoToFile = <
  TData = Awaited<ReturnType<typeof addMemoToFile>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { idOrKey: string; data: DriveItemMemoAddRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { idOrKey: string; data: DriveItemMemoAddRequest }, TContext> => {
  const mutationOptions = getAddMemoToFileMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏûêÎ£åÎ•º Ï¢ãÏïÑÏöîÏ≤òÎ¶¨ÌïòÍ±∞ÎÇò, Ìï¥Ï†úÌï©ÎãàÎã§. ÏùëÎãµÏùÄ ÏÇ¨Ïö©ÏûêÏùò Ï¢ãÏïÑÏöî ÏÉÅÌÉúÏôÄ, ÏûêÎ£åÏùò Ï¢ãÏïÑÏöî ÏàòÎ•º ÏùëÎãµÌï©ÎãàÎã§.
 * @summary ÏûêÎ£å Ï¢ãÏïÑÏöî Ï≤òÎ¶¨
 */
export const likeDriveItem = (
  profileId: string,
  idOrKey: string,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseDriveItemLikeResult>(
    { url: `/file/v1/drive-items/${idOrKey}/like/${profileId}`, method: 'POST', signal },
    options,
  );
};

export const getLikeDriveItemMutationOptions = <
  TData = Awaited<ReturnType<typeof likeDriveItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { profileId: string; idOrKey: string }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['likeDriveItem'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof likeDriveItem>>,
    { profileId: string; idOrKey: string }
  > = (props) => {
    const { profileId, idOrKey } = props ?? {};

    return likeDriveItem(profileId, idOrKey, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { profileId: string; idOrKey: string },
    TContext
  >;
};

export type LikeDriveItemMutationResult = NonNullable<Awaited<ReturnType<typeof likeDriveItem>>>;

export type LikeDriveItemMutationError = unknown;

/**
 * @summary ÏûêÎ£å Ï¢ãÏïÑÏöî Ï≤òÎ¶¨
 */
export const useLikeDriveItem = <
  TData = Awaited<ReturnType<typeof likeDriveItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { profileId: string; idOrKey: string }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { profileId: string; idOrKey: string }, TContext> => {
  const mutationOptions = getLikeDriveItemMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏûêÎ£åÏóê Îì±Î°ùÎêú ÎåìÍ∏Ä Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÏûêÎ£åÏùò ÎåìÍ∏Ä Ï°∞Ìöå
 */
export const findAllPagingReplies1 = (
  driveItemIdOrKey: string,
  params?: FindAllPagingReplies1Params,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListReplyResult>(
    { url: `/file/v1/drive-items/${driveItemIdOrKey}/replies`, method: 'GET', params, signal },
    options,
  );
};

export const getFindAllPagingReplies1QueryKey = (driveItemIdOrKey: string, params?: FindAllPagingReplies1Params) => {
  return [`/file/v1/drive-items/${driveItemIdOrKey}/replies`, ...(params ? [params] : [])] as const;
};

export const getFindAllPagingReplies1QueryOptions = <
  TData = Awaited<ReturnType<typeof findAllPagingReplies1>>,
  TError = unknown,
>(
  driveItemIdOrKey: string,
  params?: FindAllPagingReplies1Params,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findAllPagingReplies1>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFindAllPagingReplies1QueryKey(driveItemIdOrKey, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findAllPagingReplies1>>> = ({ signal }) =>
    findAllPagingReplies1(driveItemIdOrKey, params, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!driveItemIdOrKey, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findAllPagingReplies1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type FindAllPagingReplies1QueryResult = NonNullable<Awaited<ReturnType<typeof findAllPagingReplies1>>>;
export type FindAllPagingReplies1QueryError = unknown;

export function useFindAllPagingReplies1<TData = Awaited<ReturnType<typeof findAllPagingReplies1>>, TError = unknown>(
  driveItemIdOrKey: string,
  params: undefined | FindAllPagingReplies1Params,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof findAllPagingReplies1>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof findAllPagingReplies1>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useFindAllPagingReplies1<TData = Awaited<ReturnType<typeof findAllPagingReplies1>>, TError = unknown>(
  driveItemIdOrKey: string,
  params?: FindAllPagingReplies1Params,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findAllPagingReplies1>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof findAllPagingReplies1>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useFindAllPagingReplies1<TData = Awaited<ReturnType<typeof findAllPagingReplies1>>, TError = unknown>(
  driveItemIdOrKey: string,
  params?: FindAllPagingReplies1Params,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findAllPagingReplies1>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÏûêÎ£åÏùò ÎåìÍ∏Ä Ï°∞Ìöå
 */

export function useFindAllPagingReplies1<TData = Awaited<ReturnType<typeof findAllPagingReplies1>>, TError = unknown>(
  driveItemIdOrKey: string,
  params?: FindAllPagingReplies1Params,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findAllPagingReplies1>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getFindAllPagingReplies1QueryOptions(driveItemIdOrKey, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏûêÎ£åÏóê ÎåìÍ∏ÄÏùÑ Îì±Î°ùÌï©ÎãàÎã§.
 * @summary ÎåìÍ∏Ä Ï∂îÍ∞Ä
 */
export const addReply = (
  driveItemIdOrKey: string,
  addReplyRequest: AddReplyRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<unknown>(
    {
      url: `/file/v1/drive-items/${driveItemIdOrKey}/replies`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: addReplyRequest,
      signal,
    },
    options,
  );
};

export const getAddReplyMutationOptions = <
  TData = Awaited<ReturnType<typeof addReply>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { driveItemIdOrKey: string; data: AddReplyRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['addReply'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addReply>>,
    { driveItemIdOrKey: string; data: AddReplyRequest }
  > = (props) => {
    const { driveItemIdOrKey, data } = props ?? {};

    return addReply(driveItemIdOrKey, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { driveItemIdOrKey: string; data: AddReplyRequest },
    TContext
  >;
};

export type AddReplyMutationResult = NonNullable<Awaited<ReturnType<typeof addReply>>>;
export type AddReplyMutationBody = AddReplyRequest;
export type AddReplyMutationError = unknown;

/**
 * @summary ÎåìÍ∏Ä Ï∂îÍ∞Ä
 */
export const useAddReply = <
  TData = Awaited<ReturnType<typeof addReply>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { driveItemIdOrKey: string; data: AddReplyRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { driveItemIdOrKey: string; data: AddReplyRequest }, TContext> => {
  const mutationOptions = getAddReplyMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * 1. Î≥∏Ïù∏ ÏûêÎ£åÏóêÎßå ÌÉúÍ∑∏Î•º Ï∂îÍ∞Ä, ÏÇ≠Ï†úÌï† Ïàò ÏûàÎã§.
2. Ìè¥ÎçîÏùò Í≤ΩÏö∞, ÌïòÏúÑ Ìï≠Î™©ÏóêÎäî ÏòÅÌñ•ÏùÑ ÎØ∏ÏπòÏßÄ ÏïäÎäîÎã§.
3. ÏûêÎ£åÏóê Ïó∞Í≤∞Îêú Í∏∞Ï°¥ ÌÉúÍ∑∏Îäî ÏÇ≠Ï†úÎêòÍ≥† ÌååÎùºÎØ∏ÌÑ∞Î°ú Ï†ÑÎã¨Ìïú ÌÉúÍ∑∏Í∞Ä ÏàúÏÑúÎ•º Ïú†ÏßÄÌïòÏó¨ Ï†ÄÏû•ÎêúÎã§.
3-1. ÌÉúÍ∑∏ Ï†ÄÏû•ÏùÄ ÌÉúÍ∑∏ Î≠âÏπò(Bundle) Îã®ÏúÑÎ°ú ÏßÑÌñâ
4. ÏµúÍ∑º ÏÇ¨Ïö©Ìïú ÌÉúÍ∑∏Îäî FIFO Î∞©ÏãùÏúºÎ°ú ÏóÖÎç∞Ïù¥Ìä∏ÌïúÎã§. Îì±Î°ùÌïú ÌÉúÍ∑∏ Î≠âÏπòÏóê ÌÉúÍ∑∏ ÏàòÍ∞Ä NÍ∞ú ÏùºÎïå,
4-1. if N == 10, Ïù¥ Ï†ïÎ≥¥Î•º Í∑∏ÎåÄÎ°ú ÏµúÍ∑º ÏÇ¨Ïö© ÌÉúÍ∑∏Î°ú ÏßÄÏ†ïÌïúÎã§.
4-2. if N < 10, Î¨∏ÏûêÏó¥ Í≤∞Ìï©(`Îì±Î°ù ÌÉúÍ∑∏ Î≠âÏπò` + `ÏµúÍ∑º ÌÉúÍ∑∏ Î≠âÏπò` ÏàúÏÑú) -> Îí§Ï™Ω Ï§ëÎ≥µ ÌÉúÍ∑∏ Ï†úÍ±∞ -> ÎÇ®ÏùÄ ÌÉúÍ∑∏ Ï§ë, ÏµúÎåÄ 10Í∞úÎ•º Ï†ÄÏû•ÌïúÎã§.
5. ÌÉúÍ∑∏Ïùò Ï∂îÍ∞Ä, ÏÇ≠Ï†ú Í∏∞Î°ùÏùÄ Î°úÍ∑∏ ÌÖåÏù¥Î∏îÏóê Ï†ÄÏû•ÎêúÎã§.
 * @summary ÏûêÎ£åÏóê ÌÉúÍ∑∏ Îì±Î°ù
 */
export const addTag = (
  driveItemAddTagRequest: DriveItemAddTagRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseString>(
    {
      url: `/file/v1/drive-items/tagging`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: driveItemAddTagRequest,
      signal,
    },
    options,
  );
};

export const getAddTagMutationOptions = <
  TData = Awaited<ReturnType<typeof addTag>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: DriveItemAddTagRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['addTag'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof addTag>>, { data: DriveItemAddTagRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return addTag(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: DriveItemAddTagRequest },
    TContext
  >;
};

export type AddTagMutationResult = NonNullable<Awaited<ReturnType<typeof addTag>>>;
export type AddTagMutationBody = DriveItemAddTagRequest;
export type AddTagMutationError = unknown;

/**
 * @summary ÏûêÎ£åÏóê ÌÉúÍ∑∏ Îì±Î°ù
 */
export const useAddTag = <TData = Awaited<ReturnType<typeof addTag>>, TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: DriveItemAddTagRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: DriveItemAddTagRequest }, TContext> => {
  const mutationOptions = getAddTagMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏõêÎ≥∏ ÏûêÎ£åÎ•º Îã§Ïö¥ Î∞õÏùÑ Ïàò ÏûàÎäî presigned urlÎ•º ÏöîÏ≤≠ÌïòÎäî api ÏûÖÎãàÎã§.(Ìè¥ÎçîÎèÑ Í∞ÄÎä•.)
 * @summary ÏûêÎ£åÏùò Îã§Ïö¥Î°úÎìú ÎßÅÌÅ¨ ÏöîÏ≤≠
 */
export const getCdnFilesForDownload = (
  cdnFilesForDownloadRequest: CdnFilesForDownloadRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListCdnFileResult>(
    {
      url: `/file/v1/drive-items/presigned-urls`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: cdnFilesForDownloadRequest,
      signal,
    },
    options,
  );
};

export const getGetCdnFilesForDownloadMutationOptions = <
  TData = Awaited<ReturnType<typeof getCdnFilesForDownload>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CdnFilesForDownloadRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['getCdnFilesForDownload'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof getCdnFilesForDownload>>,
    { data: CdnFilesForDownloadRequest }
  > = (props) => {
    const { data } = props ?? {};

    return getCdnFilesForDownload(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: CdnFilesForDownloadRequest },
    TContext
  >;
};

export type GetCdnFilesForDownloadMutationResult = NonNullable<Awaited<ReturnType<typeof getCdnFilesForDownload>>>;
export type GetCdnFilesForDownloadMutationBody = CdnFilesForDownloadRequest;
export type GetCdnFilesForDownloadMutationError = unknown;

/**
 * @summary ÏûêÎ£åÏùò Îã§Ïö¥Î°úÎìú ÎßÅÌÅ¨ ÏöîÏ≤≠
 */
export const useGetCdnFilesForDownload = <
  TData = Awaited<ReturnType<typeof getCdnFilesForDownload>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CdnFilesForDownloadRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: CdnFilesForDownloadRequest }, TContext> => {
  const mutationOptions = getGetCdnFilesForDownloadMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÎÇ¥Ìè¥ÎçîÏïàÏóê Ï¶êÍ≤®Ï∞æÍ∏∞Ïóê ÎÑ£Í±∞ÎÇò ÎπºÍ≥†, Ï¶êÍ≤®Ï∞æÍ∏∞Ïóê ÎÑ£Ïñ¥ÏûàÏùÑ Í≤ΩÏö∞ trueÎ•º Ìï¥Ï†úÌñàÏùÑ Í≤ΩÏö∞ falseÎ•º Î∞òÌôòÌï©ÎãàÎã§.
 * @summary Ï¶êÍ≤®Ï∞æÍ∏∞ ÌÜ†Í∏Ä(Î≥ÑÌëúÏãú ÏºúÍ∏∞ÎÅÑÍ∏∞)
 */
export const starred = (
  profileIdAndDriveItemKeyRequest: ProfileIdAndDriveItemKeyRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseBoolean>(
    {
      url: `/file/v1/common-smart-folder/toggle-favorite`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: profileIdAndDriveItemKeyRequest,
      signal,
    },
    options,
  );
};

export const getStarredMutationOptions = <
  TData = Awaited<ReturnType<typeof starred>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: ProfileIdAndDriveItemKeyRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['starred'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof starred>>, { data: ProfileIdAndDriveItemKeyRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return starred(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: ProfileIdAndDriveItemKeyRequest },
    TContext
  >;
};

export type StarredMutationResult = NonNullable<Awaited<ReturnType<typeof starred>>>;
export type StarredMutationBody = ProfileIdAndDriveItemKeyRequest;
export type StarredMutationError = unknown;

/**
 * @summary Ï¶êÍ≤®Ï∞æÍ∏∞ ÌÜ†Í∏Ä(Î≥ÑÌëúÏãú ÏºúÍ∏∞ÎÅÑÍ∏∞)
 */
export const useStarred = <
  TData = Awaited<ReturnType<typeof starred>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: ProfileIdAndDriveItemKeyRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: ProfileIdAndDriveItemKeyRequest }, TContext> => {
  const mutationOptions = getStarredMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * presigned urlÎ°ú ÏóÖÎ°úÎìúÎ•º ÏôÑÎ£åÌïú Í≤ΩÏö∞ Ï†ïÎ≥¥Î•º Ï†ÑÎã¨ Î∞õÏïÑ Ïã§Ï†úÎ°ú ÏÑúÎπÑÏä§Ïóê ÎÇòÏò¨ Ïàò ÏûàÎèÑÎ°ù Ï†ïÎ≥¥Î•º ÏûÖÎ†•Ìï©ÎãàÎã§.Ïç∏ÎÑ§ÏùºÏùÄ Ï†ÑÏÜ°ÌïòÏßÄÏïäÍ≥†, ÌîÑÎ°úÌïÑÏÇ¨ÏßÑ/ÏïÑÏù¥ÏÇ¨ÏßÑÏùº Í≤ΩÏö∞ /file/v1/file-objects/{fileObjectId}/uploaded 
ÏóÖÎ°úÎìú ÏàúÏÑú.
1. [POST]/file/v1/file-objectsÎ°ú ÏóÖÎ°úÎìúÌï† presigned url ÏÉùÏÑ± ÏöîÏ≤≠. Ïù¥Îïå Ï†ÑÎã¨Î∞õÏùÄ id Í∏∞Ïñµ ÌïÑÏöî
2. Ï†ÑÎã¨ Î∞õÏùÄ presigned urlÎ°ú ÌååÏùº ÏóÖÎ°úÎìú
3. ÏóÖÎ°úÎìúÍ∞Ä ÏôÑÎ£åÎêòÎ©¥ 1ÏóêÏÑú Ï†ÑÎã¨ Î∞õÏùÄ id(result Î∞∞Ïó¥ÏÜç ÏõêÎ≥∏ ÌååÏùºÏùò id = fileObject.id)ÏôÄ ÌååÏùºÏùò Ï†ïÎ≥¥Î•º Îì±Î°ùÌïòÎ©∞ ÏóÖÎ°úÎìú ÌîÑÎ°úÏÑ∏Ïä§Î•º ÏôÑÎ£å
   [ÌîÑÎ°úÌïÑÏÇ¨ÏßÑÎ•ò(presigned url ÏÉùÏÑ±Ìï†Îïå ÏÜåÏä§ PROFILE Ïùº Îïå) ÏôÑÎ£åÌñàÏùÑÎïåÎäî 2Î≤àÎåÄÏã† [PUT] /file/v1/file-objects/{id}/uploaded]
 * @summary ÏûêÎ£å ÏóÖÎ°úÎìú ÏôÑÎ£å Ï≤òÎ¶¨
 */
export const uploadCompleted1 = (
  fileObjectId: string,
  commonUploadCompletedRequest: CommonUploadCompletedRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseSmartFolderItemResult>(
    {
      url: `/file/v1/common-smart-folder/file-object/${fileObjectId}/upload-complete`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: commonUploadCompletedRequest,
      signal,
    },
    options,
  );
};

export const getUploadCompleted1MutationOptions = <
  TData = Awaited<ReturnType<typeof uploadCompleted1>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { fileObjectId: string; data: CommonUploadCompletedRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['uploadCompleted1'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof uploadCompleted1>>,
    { fileObjectId: string; data: CommonUploadCompletedRequest }
  > = (props) => {
    const { fileObjectId, data } = props ?? {};

    return uploadCompleted1(fileObjectId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { fileObjectId: string; data: CommonUploadCompletedRequest },
    TContext
  >;
};

export type UploadCompleted1MutationResult = NonNullable<Awaited<ReturnType<typeof uploadCompleted1>>>;
export type UploadCompleted1MutationBody = CommonUploadCompletedRequest;
export type UploadCompleted1MutationError = unknown;

/**
 * @summary ÏûêÎ£å ÏóÖÎ°úÎìú ÏôÑÎ£å Ï≤òÎ¶¨
 */
export const useUploadCompleted1 = <
  TData = Awaited<ReturnType<typeof uploadCompleted1>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { fileObjectId: string; data: CommonUploadCompletedRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { fileObjectId: string; data: CommonUploadCompletedRequest }, TContext> => {
  const mutationOptions = getUploadCompleted1MutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏÉà Î©îÎ™® ÌååÏùºÏùÑ Îì±Î°ùÌï©ÎãàÎã§.
 * @summary Î©îÎ™® ÌååÏùºÏùÑ ÏÉùÏÑ±ÌïòÎäî api
 */
export const createMemoFile = (
  memoFileCreateRequest: MemoFileCreateRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseSmartFolderItemResult>(
    {
      url: `/file/v1/common-smart-folder/create-memo-file`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: memoFileCreateRequest,
      signal,
    },
    options,
  );
};

export const getCreateMemoFileMutationOptions = <
  TData = Awaited<ReturnType<typeof createMemoFile>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MemoFileCreateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['createMemoFile'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof createMemoFile>>, { data: MemoFileCreateRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return createMemoFile(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: MemoFileCreateRequest },
    TContext
  >;
};

export type CreateMemoFileMutationResult = NonNullable<Awaited<ReturnType<typeof createMemoFile>>>;
export type CreateMemoFileMutationBody = MemoFileCreateRequest;
export type CreateMemoFileMutationError = unknown;

/**
 * @summary Î©îÎ™® ÌååÏùºÏùÑ ÏÉùÏÑ±ÌïòÎäî api
 */
export const useCreateMemoFile = <
  TData = Awaited<ReturnType<typeof createMemoFile>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MemoFileCreateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: MemoFileCreateRequest }, TContext> => {
  const mutationOptions = getCreateMemoFileMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏÇ¨Ïö©ÏûêÍ∞Ä ÏßÄÏ†ïÌïú Ìè¥ÎçîÏóê ÏûêÎ£åÎì§ÏùÑ Ï∂îÍ∞ÄÌï©ÎãàÎã§. Ìè¥ÎçîÎäî Ï∂îÍ∞ÄÌï† Ïàò ÏóÜÏäµÎãàÎã§.ÏÉÅÏúÑ Ìè¥ÎçîÏùò Í≥µÍ∞úÎêú ÏÉÅÌÉúÎ•º Ïù¥Ïñ¥Î∞õÍ≥†, Îã§Î•∏ÏÇ¨ÎûåÏùò ÏûêÎ£åÎ©¥ ÎÇ¥ ÎìúÎùºÏù¥Î∏åÏóê Î≥µÏÇ¨ÎèÑ ÏßÑÌñâÌï©ÎãàÎã§.
 * @summary Ïä§ÎßàÌä∏ Ìè¥ÎçîÏóê ÏûêÎ£å Ï∂îÍ∞Ä
 */
export const addItem = (
  commonAddDriveItemToSmartFolderRequest: CommonAddDriveItemToSmartFolderRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseString>(
    {
      url: `/file/v1/common-smart-folder/add-item`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: commonAddDriveItemToSmartFolderRequest,
      signal,
    },
    options,
  );
};

export const getAddItemMutationOptions = <
  TData = Awaited<ReturnType<typeof addItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CommonAddDriveItemToSmartFolderRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['addItem'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addItem>>,
    { data: CommonAddDriveItemToSmartFolderRequest }
  > = (props) => {
    const { data } = props ?? {};

    return addItem(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: CommonAddDriveItemToSmartFolderRequest },
    TContext
  >;
};

export type AddItemMutationResult = NonNullable<Awaited<ReturnType<typeof addItem>>>;
export type AddItemMutationBody = CommonAddDriveItemToSmartFolderRequest;
export type AddItemMutationError = unknown;

/**
 * @summary Ïä§ÎßàÌä∏ Ìè¥ÎçîÏóê ÏûêÎ£å Ï∂îÍ∞Ä
 */
export const useAddItem = <
  TData = Awaited<ReturnType<typeof addItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CommonAddDriveItemToSmartFolderRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: CommonAddDriveItemToSmartFolderRequest }, TContext> => {
  const mutationOptions = getAddItemMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏÇ¨Ïö©ÏûêÍ∞Ä ÏßÄÏ†ïÌïú Ìè¥ÎçîÏóê ÏûêÎ£åÎì§ÏùÑ Ï∂îÍ∞ÄÌï©ÎãàÎã§. Ìè¥ÎçîÎäî Ï∂îÍ∞ÄÌï† Ïàò ÏóÜÏäµÎãàÎã§.ÏÉÅÏúÑ Ìè¥ÎçîÏùò Í≥µÍ∞úÎêú ÏÉÅÌÉúÎ•º Ïù¥Ïñ¥Î∞õÍ≥†, Îã§Î•∏ÏÇ¨ÎûåÏùò ÏûêÎ£åÎ©¥ ÎÇ¥ ÎìúÎùºÏù¥Î∏åÏóê Î≥µÏÇ¨ÎèÑ ÏßÑÌñâÌï©ÎãàÎã§.
 * @summary Ïä§ÎßàÌä∏ Ìè¥ÎçîÏóê ÏûêÎ£å Ï∂îÍ∞Ä
 */
export const addItemWithApiTypeAndId = (
  commonAddDriveItemToSmartFolderWithIdRequest: CommonAddDriveItemToSmartFolderWithIdRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseString>(
    {
      url: `/file/v1/common-smart-folder/add-item-with-ids`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: commonAddDriveItemToSmartFolderWithIdRequest,
      signal,
    },
    options,
  );
};

export const getAddItemWithApiTypeAndIdMutationOptions = <
  TData = Awaited<ReturnType<typeof addItemWithApiTypeAndId>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CommonAddDriveItemToSmartFolderWithIdRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['addItemWithApiTypeAndId'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addItemWithApiTypeAndId>>,
    { data: CommonAddDriveItemToSmartFolderWithIdRequest }
  > = (props) => {
    const { data } = props ?? {};

    return addItemWithApiTypeAndId(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: CommonAddDriveItemToSmartFolderWithIdRequest },
    TContext
  >;
};

export type AddItemWithApiTypeAndIdMutationResult = NonNullable<Awaited<ReturnType<typeof addItemWithApiTypeAndId>>>;
export type AddItemWithApiTypeAndIdMutationBody = CommonAddDriveItemToSmartFolderWithIdRequest;
export type AddItemWithApiTypeAndIdMutationError = unknown;

/**
 * @summary Ïä§ÎßàÌä∏ Ìè¥ÎçîÏóê ÏûêÎ£å Ï∂îÍ∞Ä
 */
export const useAddItemWithApiTypeAndId = <
  TData = Awaited<ReturnType<typeof addItemWithApiTypeAndId>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CommonAddDriveItemToSmartFolderWithIdRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: CommonAddDriveItemToSmartFolderWithIdRequest }, TContext> => {
  const mutationOptions = getAddItemWithApiTypeAndIdMutationOptions(options);

  return useMutation(mutationOptions);
};

export const addFolder1 = (
  createSmartFolderRequest: CreateSmartFolderRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseSmartFolderItemResult>(
    {
      url: `/file/v1/common-smart-folder/add-folder`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createSmartFolderRequest,
      signal,
    },
    options,
  );
};

export const getAddFolder1MutationOptions = <
  TData = Awaited<ReturnType<typeof addFolder1>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CreateSmartFolderRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['addFolder1'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof addFolder1>>, { data: CreateSmartFolderRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return addFolder1(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: CreateSmartFolderRequest },
    TContext
  >;
};

export type AddFolder1MutationResult = NonNullable<Awaited<ReturnType<typeof addFolder1>>>;
export type AddFolder1MutationBody = CreateSmartFolderRequest;
export type AddFolder1MutationError = unknown;

export const useAddFolder1 = <
  TData = Awaited<ReturnType<typeof addFolder1>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CreateSmartFolderRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: CreateSmartFolderRequest }, TContext> => {
  const mutationOptions = getAddFolder1MutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏÇ¨Ïö©ÏûêÏùò ÌòÑÏû¨ Ï†ÄÏû•ÏÜå Ï†ïÎ≥¥Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÏÇ¨Ïö©ÏûêÏùò Ï†ÄÏû•ÏÜå Ï°∞Ìöå
 */
export const getByProfileId = (
  profileId: string,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseStorageUsageResult>(
    { url: `/file/v2/storage-usages/${profileId}`, method: 'GET', signal },
    options,
  );
};

export const getGetByProfileIdQueryKey = (profileId: string) => {
  return [`/file/v2/storage-usages/${profileId}`] as const;
};

export const getGetByProfileIdQueryOptions = <TData = Awaited<ReturnType<typeof getByProfileId>>, TError = unknown>(
  profileId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getByProfileId>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetByProfileIdQueryKey(profileId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getByProfileId>>> = ({ signal }) =>
    getByProfileId(profileId, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getByProfileId>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetByProfileIdQueryResult = NonNullable<Awaited<ReturnType<typeof getByProfileId>>>;
export type GetByProfileIdQueryError = unknown;

export function useGetByProfileId<TData = Awaited<ReturnType<typeof getByProfileId>>, TError = unknown>(
  profileId: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getByProfileId>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getByProfileId>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetByProfileId<TData = Awaited<ReturnType<typeof getByProfileId>>, TError = unknown>(
  profileId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getByProfileId>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getByProfileId>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetByProfileId<TData = Awaited<ReturnType<typeof getByProfileId>>, TError = unknown>(
  profileId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getByProfileId>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÏÇ¨Ïö©ÏûêÏùò Ï†ÄÏû•ÏÜå Ï°∞Ìöå
 */

export function useGetByProfileId<TData = Awaited<ReturnType<typeof getByProfileId>>, TError = unknown>(
  profileId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getByProfileId>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetByProfileIdQueryOptions(profileId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÇ¨Ïö©Ïûê ÌîÑÎ°úÌïÑ idÎ°ú ÏµúÍ∑ºÏóê ÌÉúÍ∑∏Î°ú Îì±Î°ùÌïú ÌÇ§ÏõåÎìúÎ•º Ï°∞ÌöåÌï©ÎãàÎã§. (ÏóÜÏúºÎ©¥ Îπà Î∞∞Ïó¥ ÏùëÎãµ)
 * @summary ÏµúÍ∑º ÏÇ¨Ïö© ÌÉúÍ∑∏ ÏñªÍ∏∞v2
 */
export const getRecentTagsV2 = (
  profileId: string,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListString>(
    { url: `/file/v2/recent-tags/${profileId}`, method: 'GET', signal },
    options,
  );
};

export const getGetRecentTagsV2QueryKey = (profileId: string) => {
  return [`/file/v2/recent-tags/${profileId}`] as const;
};

export const getGetRecentTagsV2QueryOptions = <TData = Awaited<ReturnType<typeof getRecentTagsV2>>, TError = unknown>(
  profileId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentTagsV2>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRecentTagsV2QueryKey(profileId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecentTagsV2>>> = ({ signal }) =>
    getRecentTagsV2(profileId, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRecentTagsV2>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetRecentTagsV2QueryResult = NonNullable<Awaited<ReturnType<typeof getRecentTagsV2>>>;
export type GetRecentTagsV2QueryError = unknown;

export function useGetRecentTagsV2<TData = Awaited<ReturnType<typeof getRecentTagsV2>>, TError = unknown>(
  profileId: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentTagsV2>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getRecentTagsV2>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetRecentTagsV2<TData = Awaited<ReturnType<typeof getRecentTagsV2>>, TError = unknown>(
  profileId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentTagsV2>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getRecentTagsV2>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetRecentTagsV2<TData = Awaited<ReturnType<typeof getRecentTagsV2>>, TError = unknown>(
  profileId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentTagsV2>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÏµúÍ∑º ÏÇ¨Ïö© ÌÉúÍ∑∏ ÏñªÍ∏∞v2
 */

export function useGetRecentTagsV2<TData = Awaited<ReturnType<typeof getRecentTagsV2>>, TError = unknown>(
  profileId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentTagsV2>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetRecentTagsV2QueryOptions(profileId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÉÅÏÑ∏Î≥¥Í∏∞Ïö© Ï∂îÏ≤ú ÏûêÎ£åÎ•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary [ÏûêÎ£å ÏÉÅÏÑ∏Î≥¥Í∏∞] ÌååÏùºÏùò ÏÉÅÏÑ∏Î≥¥Í∏∞ÏóêÏÑú Ï∂îÏ≤ú ÏûêÎ£å Î¶¨Ïä§Ìä∏ Ï°∞Ìöå
 */
export const getSmartFolderItemsRecommendPublicItemList = (
  params: GetSmartFolderItemsRecommendPublicItemListParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/file/v2/public-url-item/recommand-items-for-detailed-info`, method: 'GET', params, signal },
    options,
  );
};

export const getGetSmartFolderItemsRecommendPublicItemListQueryKey = (
  params: GetSmartFolderItemsRecommendPublicItemListParams,
) => {
  return [`/file/v2/public-url-item/recommand-items-for-detailed-info`, ...(params ? [params] : [])] as const;
};

export const getGetSmartFolderItemsRecommendPublicItemListQueryOptions = <
  TData = Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList>>,
  TError = unknown,
>(
  params: GetSmartFolderItemsRecommendPublicItemListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSmartFolderItemsRecommendPublicItemListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList>>> = ({ signal }) =>
    getSmartFolderItemsRecommendPublicItemList(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetSmartFolderItemsRecommendPublicItemListQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList>>
>;
export type GetSmartFolderItemsRecommendPublicItemListQueryError = unknown;

export function useGetSmartFolderItemsRecommendPublicItemList<
  TData = Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList>>,
  TError = unknown,
>(
  params: GetSmartFolderItemsRecommendPublicItemListParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList>>,
          TError,
          TData
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetSmartFolderItemsRecommendPublicItemList<
  TData = Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList>>,
  TError = unknown,
>(
  params: GetSmartFolderItemsRecommendPublicItemListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList>>,
          TError,
          TData
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetSmartFolderItemsRecommendPublicItemList<
  TData = Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList>>,
  TError = unknown,
>(
  params: GetSmartFolderItemsRecommendPublicItemListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary [ÏûêÎ£å ÏÉÅÏÑ∏Î≥¥Í∏∞] ÌååÏùºÏùò ÏÉÅÏÑ∏Î≥¥Í∏∞ÏóêÏÑú Ï∂îÏ≤ú ÏûêÎ£å Î¶¨Ïä§Ìä∏ Ï°∞Ìöå
 */

export function useGetSmartFolderItemsRecommendPublicItemList<
  TData = Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList>>,
  TError = unknown,
>(
  params: GetSmartFolderItemsRecommendPublicItemListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetSmartFolderItemsRecommendPublicItemListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Í≥µÍ∞ú ÏûêÎ£å idÎ•º Ïù¥Ïö©Ìï¥ÏÑú ÏûêÎ£åÏùò ÏÑ∏Î∂ÄÏ†ïÎ≥¥Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary Í≥µÍ∞úÎêú ÌååÏùºÏùò ÏÉÅÏÑ∏Î≥¥Í∏∞ Íµ¨ÌòÑÏùÑ ÏúÑÌï¥ Ï°∞ÌöåÌïòÎäî api
 */
export const getPublicItem = (
  params: GetPublicItemParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponsePublicUrlItemDetailedResult>(
    { url: `/file/v2/public-url-item/detailed-info`, method: 'GET', params, signal },
    options,
  );
};

export const getGetPublicItemQueryKey = (params: GetPublicItemParams) => {
  return [`/file/v2/public-url-item/detailed-info`, ...(params ? [params] : [])] as const;
};

export const getGetPublicItemQueryOptions = <TData = Awaited<ReturnType<typeof getPublicItem>>, TError = unknown>(
  params: GetPublicItemParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicItem>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPublicItemQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPublicItem>>> = ({ signal }) =>
    getPublicItem(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPublicItem>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetPublicItemQueryResult = NonNullable<Awaited<ReturnType<typeof getPublicItem>>>;
export type GetPublicItemQueryError = unknown;

export function useGetPublicItem<TData = Awaited<ReturnType<typeof getPublicItem>>, TError = unknown>(
  params: GetPublicItemParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicItem>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getPublicItem>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetPublicItem<TData = Awaited<ReturnType<typeof getPublicItem>>, TError = unknown>(
  params: GetPublicItemParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicItem>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getPublicItem>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetPublicItem<TData = Awaited<ReturnType<typeof getPublicItem>>, TError = unknown>(
  params: GetPublicItemParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicItem>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Í≥µÍ∞úÎêú ÌååÏùºÏùò ÏÉÅÏÑ∏Î≥¥Í∏∞ Íµ¨ÌòÑÏùÑ ÏúÑÌï¥ Ï°∞ÌöåÌïòÎäî api
 */

export function useGetPublicItem<TData = Awaited<ReturnType<typeof getPublicItem>>, TError = unknown>(
  params: GetPublicItemParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicItem>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetPublicItemQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏûêÎ£å ÌÇ§Î•º Ïù¥Ïö©Ìï¥ÏÑú ÎåìÍ∏Ä Í¥ÄÎ†® Î¶¨Ïä§Ìä∏Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary [ÏûêÎ£å ÏÉÅÏÑ∏Î≥¥Í∏∞]ÌååÏùºÏùò ÏÉÅÏÑ∏Î≥¥Í∏∞ Íµ¨ÌòÑÏùÑ ÏúÑÌï¥ ÎåìÍ∏Ä Î¶¨Ïä§Ìä∏ÏôÄ ÎåìÍ∏Ä Ï≤®Î∂ÄÏûêÎ£å Î¶¨Ïä§Ìä∏Î•º Ï°∞ÌöåÌïòÎäî api
 */
export const getReplyAndAttachedItemList = (
  params: GetReplyAndAttachedItemListParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseSmartFolderItemReplyResult>(
    { url: `/file/v2/common-smart-folder/replies-for-detailed-info`, method: 'GET', params, signal },
    options,
  );
};

export const getGetReplyAndAttachedItemListQueryKey = (params: GetReplyAndAttachedItemListParams) => {
  return [`/file/v2/common-smart-folder/replies-for-detailed-info`, ...(params ? [params] : [])] as const;
};

export const getGetReplyAndAttachedItemListQueryOptions = <
  TData = Awaited<ReturnType<typeof getReplyAndAttachedItemList>>,
  TError = unknown,
>(
  params: GetReplyAndAttachedItemListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getReplyAndAttachedItemList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetReplyAndAttachedItemListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getReplyAndAttachedItemList>>> = ({ signal }) =>
    getReplyAndAttachedItemList(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getReplyAndAttachedItemList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetReplyAndAttachedItemListQueryResult = NonNullable<
  Awaited<ReturnType<typeof getReplyAndAttachedItemList>>
>;
export type GetReplyAndAttachedItemListQueryError = unknown;

export function useGetReplyAndAttachedItemList<
  TData = Awaited<ReturnType<typeof getReplyAndAttachedItemList>>,
  TError = unknown,
>(
  params: GetReplyAndAttachedItemListParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getReplyAndAttachedItemList>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getReplyAndAttachedItemList>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetReplyAndAttachedItemList<
  TData = Awaited<ReturnType<typeof getReplyAndAttachedItemList>>,
  TError = unknown,
>(
  params: GetReplyAndAttachedItemListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getReplyAndAttachedItemList>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getReplyAndAttachedItemList>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetReplyAndAttachedItemList<
  TData = Awaited<ReturnType<typeof getReplyAndAttachedItemList>>,
  TError = unknown,
>(
  params: GetReplyAndAttachedItemListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getReplyAndAttachedItemList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary [ÏûêÎ£å ÏÉÅÏÑ∏Î≥¥Í∏∞]ÌååÏùºÏùò ÏÉÅÏÑ∏Î≥¥Í∏∞ Íµ¨ÌòÑÏùÑ ÏúÑÌï¥ ÎåìÍ∏Ä Î¶¨Ïä§Ìä∏ÏôÄ ÎåìÍ∏Ä Ï≤®Î∂ÄÏûêÎ£å Î¶¨Ïä§Ìä∏Î•º Ï°∞ÌöåÌïòÎäî api
 */

export function useGetReplyAndAttachedItemList<
  TData = Awaited<ReturnType<typeof getReplyAndAttachedItemList>>,
  TError = unknown,
>(
  params: GetReplyAndAttachedItemListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getReplyAndAttachedItemList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetReplyAndAttachedItemListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÉÅÏÑ∏Î≥¥Í∏∞Ïö© Ï∂îÏ≤ú ÏûêÎ£åÎ•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary [ÏûêÎ£å ÏÉÅÏÑ∏Î≥¥Í∏∞]ÌååÏùºÏùò ÏÉÅÏÑ∏Î≥¥Í∏∞ÏóêÏÑú Ï∂îÏ≤ú ÏûêÎ£å Î¶¨Ïä§Ìä∏ Ï°∞Ìöå
 */
export const getSmartFolderItemsRecommendPublicItemList1 = (
  params: GetSmartFolderItemsRecommendPublicItemList1Params,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/file/v2/common-smart-folder/recommand-items-for-detailed-info`, method: 'GET', params, signal },
    options,
  );
};

export const getGetSmartFolderItemsRecommendPublicItemList1QueryKey = (
  params: GetSmartFolderItemsRecommendPublicItemList1Params,
) => {
  return [`/file/v2/common-smart-folder/recommand-items-for-detailed-info`, ...(params ? [params] : [])] as const;
};

export const getGetSmartFolderItemsRecommendPublicItemList1QueryOptions = <
  TData = Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList1>>,
  TError = unknown,
>(
  params: GetSmartFolderItemsRecommendPublicItemList1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList1>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSmartFolderItemsRecommendPublicItemList1QueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList1>>> = ({
    signal,
  }) => getSmartFolderItemsRecommendPublicItemList1(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetSmartFolderItemsRecommendPublicItemList1QueryResult = NonNullable<
  Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList1>>
>;
export type GetSmartFolderItemsRecommendPublicItemList1QueryError = unknown;

export function useGetSmartFolderItemsRecommendPublicItemList1<
  TData = Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList1>>,
  TError = unknown,
>(
  params: GetSmartFolderItemsRecommendPublicItemList1Params,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList1>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList1>>,
          TError,
          TData
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetSmartFolderItemsRecommendPublicItemList1<
  TData = Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList1>>,
  TError = unknown,
>(
  params: GetSmartFolderItemsRecommendPublicItemList1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList1>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList1>>,
          TError,
          TData
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetSmartFolderItemsRecommendPublicItemList1<
  TData = Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList1>>,
  TError = unknown,
>(
  params: GetSmartFolderItemsRecommendPublicItemList1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList1>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary [ÏûêÎ£å ÏÉÅÏÑ∏Î≥¥Í∏∞]ÌååÏùºÏùò ÏÉÅÏÑ∏Î≥¥Í∏∞ÏóêÏÑú Ï∂îÏ≤ú ÏûêÎ£å Î¶¨Ïä§Ìä∏ Ï°∞Ìöå
 */

export function useGetSmartFolderItemsRecommendPublicItemList1<
  TData = Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList1>>,
  TError = unknown,
>(
  params: GetSmartFolderItemsRecommendPublicItemList1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItemsRecommendPublicItemList1>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetSmartFolderItemsRecommendPublicItemList1QueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏûêÎ£åÎ≥¥ÎìúÏùò ÏûêÎ£å idÎ•º Ïù¥Ïö©Ìï¥ÏÑú ÏûêÎ£åÏùò ÏÑ∏Î∂ÄÏ†ïÎ≥¥Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary [ÌååÏùº ÏÉÅÏÑ∏Î≥¥Í∏∞]ÌååÏùºÏùò ÏÉÅÏÑ∏Î≥¥Í∏∞ Íµ¨ÌòÑÏùÑ ÏúÑÌï¥ Ï°∞ÌöåÌïòÎäî api
 */
export const getSmartFolderItem = (
  params: GetSmartFolderItemParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseSmartFolderItemDetailedResult>(
    { url: `/file/v2/common-smart-folder/detailed-info`, method: 'GET', params, signal },
    options,
  );
};

export const getGetSmartFolderItemQueryKey = (params: GetSmartFolderItemParams) => {
  return [`/file/v2/common-smart-folder/detailed-info`, ...(params ? [params] : [])] as const;
};

export const getGetSmartFolderItemQueryOptions = <
  TData = Awaited<ReturnType<typeof getSmartFolderItem>>,
  TError = unknown,
>(
  params: GetSmartFolderItemParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItem>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSmartFolderItemQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSmartFolderItem>>> = ({ signal }) =>
    getSmartFolderItem(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSmartFolderItem>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetSmartFolderItemQueryResult = NonNullable<Awaited<ReturnType<typeof getSmartFolderItem>>>;
export type GetSmartFolderItemQueryError = unknown;

export function useGetSmartFolderItem<TData = Awaited<ReturnType<typeof getSmartFolderItem>>, TError = unknown>(
  params: GetSmartFolderItemParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItem>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getSmartFolderItem>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetSmartFolderItem<TData = Awaited<ReturnType<typeof getSmartFolderItem>>, TError = unknown>(
  params: GetSmartFolderItemParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItem>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getSmartFolderItem>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetSmartFolderItem<TData = Awaited<ReturnType<typeof getSmartFolderItem>>, TError = unknown>(
  params: GetSmartFolderItemParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItem>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary [ÌååÏùº ÏÉÅÏÑ∏Î≥¥Í∏∞]ÌååÏùºÏùò ÏÉÅÏÑ∏Î≥¥Í∏∞ Íµ¨ÌòÑÏùÑ ÏúÑÌï¥ Ï°∞ÌöåÌïòÎäî api
 */

export function useGetSmartFolderItem<TData = Awaited<ReturnType<typeof getSmartFolderItem>>, TError = unknown>(
  params: GetSmartFolderItemParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItem>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetSmartFolderItemQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÇ¨Ïö©ÏûêÏùò Ìú¥ÏßÄÌÜµ ÏûêÎ£åÎ™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÏÇ¨Ïö©ÏûêÏùò Ìú¥ÏßÄÌÜµ Ï°∞Ìöå
 */
export const findAllPagingReplies = (
  params?: FindAllPagingRepliesParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/file/v1/trashcan/item-list`, method: 'GET', params, signal },
    options,
  );
};

export const getFindAllPagingRepliesQueryKey = (params?: FindAllPagingRepliesParams) => {
  return [`/file/v1/trashcan/item-list`, ...(params ? [params] : [])] as const;
};

export const getFindAllPagingRepliesQueryOptions = <
  TData = Awaited<ReturnType<typeof findAllPagingReplies>>,
  TError = unknown,
>(
  params?: FindAllPagingRepliesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findAllPagingReplies>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFindAllPagingRepliesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findAllPagingReplies>>> = ({ signal }) =>
    findAllPagingReplies(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findAllPagingReplies>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type FindAllPagingRepliesQueryResult = NonNullable<Awaited<ReturnType<typeof findAllPagingReplies>>>;
export type FindAllPagingRepliesQueryError = unknown;

export function useFindAllPagingReplies<TData = Awaited<ReturnType<typeof findAllPagingReplies>>, TError = unknown>(
  params: undefined | FindAllPagingRepliesParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof findAllPagingReplies>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof findAllPagingReplies>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useFindAllPagingReplies<TData = Awaited<ReturnType<typeof findAllPagingReplies>>, TError = unknown>(
  params?: FindAllPagingRepliesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findAllPagingReplies>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof findAllPagingReplies>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useFindAllPagingReplies<TData = Awaited<ReturnType<typeof findAllPagingReplies>>, TError = unknown>(
  params?: FindAllPagingRepliesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findAllPagingReplies>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÏÇ¨Ïö©ÏûêÏùò Ìú¥ÏßÄÌÜµ Ï°∞Ìöå
 */

export function useFindAllPagingReplies<TData = Awaited<ReturnType<typeof findAllPagingReplies>>, TError = unknown>(
  params?: FindAllPagingRepliesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findAllPagingReplies>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getFindAllPagingRepliesQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÇ¨Ïö©ÏûêÏùò ÌîÑÎ°úÌïÑ idÎ°ú ÏµúÍ∑º ÏûëÏóÖÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÏµúÍ∑º ÏûëÏóÖ Ï°∞Ìöå
 */
export const getRecentTasks = (
  params?: GetRecentTasksParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListRecentTaskResult>(
    { url: `/file/v1/task/recent`, method: 'GET', params, signal },
    options,
  );
};

export const getGetRecentTasksQueryKey = (params?: GetRecentTasksParams) => {
  return [`/file/v1/task/recent`, ...(params ? [params] : [])] as const;
};

export const getGetRecentTasksQueryOptions = <TData = Awaited<ReturnType<typeof getRecentTasks>>, TError = unknown>(
  params?: GetRecentTasksParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentTasks>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRecentTasksQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecentTasks>>> = ({ signal }) =>
    getRecentTasks(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRecentTasks>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetRecentTasksQueryResult = NonNullable<Awaited<ReturnType<typeof getRecentTasks>>>;
export type GetRecentTasksQueryError = unknown;

export function useGetRecentTasks<TData = Awaited<ReturnType<typeof getRecentTasks>>, TError = unknown>(
  params: undefined | GetRecentTasksParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentTasks>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getRecentTasks>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetRecentTasks<TData = Awaited<ReturnType<typeof getRecentTasks>>, TError = unknown>(
  params?: GetRecentTasksParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentTasks>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getRecentTasks>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetRecentTasks<TData = Awaited<ReturnType<typeof getRecentTasks>>, TError = unknown>(
  params?: GetRecentTasksParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentTasks>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÏµúÍ∑º ÏûëÏóÖ Ï°∞Ìöå
 */

export function useGetRecentTasks<TData = Awaited<ReturnType<typeof getRecentTasks>>, TError = unknown>(
  params?: GetRecentTasksParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentTasks>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetRecentTasksQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÇ¨ÏßÑ ÏûëÏóÖÏùò idÎ°ú ÏûëÏóÖÏóê ÏÇ¨Ïö©Îêú ÏûêÎ£åÏôÄ ÏÇ∞Ï∂úÎ¨º Ï†ïÎ≥¥Î•º Ï°∞ÌöåÌïòÎäî api ÏûÖÎãàÎã§.
 * @summary ÏÇ¨ÏßÑ ÏûëÏóÖÏùò Ï†ïÎ≥¥ Ï°∞Ìöå
 */
export const getImageTask = (
  taskItemId: string,
  params?: GetImageTaskParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseImageTaskLogResult>(
    { url: `/file/v1/task/log/image/${taskItemId}`, method: 'GET', params, signal },
    options,
  );
};

export const getGetImageTaskQueryKey = (taskItemId: string, params?: GetImageTaskParams) => {
  return [`/file/v1/task/log/image/${taskItemId}`, ...(params ? [params] : [])] as const;
};

export const getGetImageTaskQueryOptions = <TData = Awaited<ReturnType<typeof getImageTask>>, TError = unknown>(
  taskItemId: string,
  params?: GetImageTaskParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImageTask>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetImageTaskQueryKey(taskItemId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getImageTask>>> = ({ signal }) =>
    getImageTask(taskItemId, params, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!taskItemId, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getImageTask>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetImageTaskQueryResult = NonNullable<Awaited<ReturnType<typeof getImageTask>>>;
export type GetImageTaskQueryError = unknown;

export function useGetImageTask<TData = Awaited<ReturnType<typeof getImageTask>>, TError = unknown>(
  taskItemId: string,
  params: undefined | GetImageTaskParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImageTask>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getImageTask>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetImageTask<TData = Awaited<ReturnType<typeof getImageTask>>, TError = unknown>(
  taskItemId: string,
  params?: GetImageTaskParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImageTask>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getImageTask>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetImageTask<TData = Awaited<ReturnType<typeof getImageTask>>, TError = unknown>(
  taskItemId: string,
  params?: GetImageTaskParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImageTask>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÏÇ¨ÏßÑ ÏûëÏóÖÏùò Ï†ïÎ≥¥ Ï°∞Ìöå
 */

export function useGetImageTask<TData = Awaited<ReturnType<typeof getImageTask>>, TError = unknown>(
  taskItemId: string,
  params?: GetImageTaskParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImageTask>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetImageTaskQueryOptions(taskItemId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Îì±Î°ùÎêú ÌÉúÍ∑∏Ï§ëÏóê ÏãúÏûëÌïòÎäî ÏûÖÎ†•ÌïòÎäî Îã®Ïñ¥Î°úÎ∂ÄÌÑ∞ ÏãúÏûëÌïòÎäî ÌÇ§ÏõåÎìú Îì§ÏùÑ Í≤ÄÏÉâÌï©ÎãàÎã§.
 * @summary ÌÉúÍ∑∏ Í≤ÄÏÉâ(startsWith Í≤ÄÏÉâ)
 */
export const getTagsStartWith = (
  keyword: string,
  params?: GetTagsStartWithParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListString>(
    { url: `/file/v1/tags/start-with/${keyword}`, method: 'GET', params, signal },
    options,
  );
};

export const getGetTagsStartWithQueryKey = (keyword: string, params?: GetTagsStartWithParams) => {
  return [`/file/v1/tags/start-with/${keyword}`, ...(params ? [params] : [])] as const;
};

export const getGetTagsStartWithQueryOptions = <TData = Awaited<ReturnType<typeof getTagsStartWith>>, TError = unknown>(
  keyword: string,
  params?: GetTagsStartWithParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTagsStartWith>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTagsStartWithQueryKey(keyword, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTagsStartWith>>> = ({ signal }) =>
    getTagsStartWith(keyword, params, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!keyword, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getTagsStartWith>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetTagsStartWithQueryResult = NonNullable<Awaited<ReturnType<typeof getTagsStartWith>>>;
export type GetTagsStartWithQueryError = unknown;

export function useGetTagsStartWith<TData = Awaited<ReturnType<typeof getTagsStartWith>>, TError = unknown>(
  keyword: string,
  params: undefined | GetTagsStartWithParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTagsStartWith>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getTagsStartWith>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetTagsStartWith<TData = Awaited<ReturnType<typeof getTagsStartWith>>, TError = unknown>(
  keyword: string,
  params?: GetTagsStartWithParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTagsStartWith>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getTagsStartWith>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetTagsStartWith<TData = Awaited<ReturnType<typeof getTagsStartWith>>, TError = unknown>(
  keyword: string,
  params?: GetTagsStartWithParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTagsStartWith>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÌÉúÍ∑∏ Í≤ÄÏÉâ(startsWith Í≤ÄÏÉâ)
 */

export function useGetTagsStartWith<TData = Awaited<ReturnType<typeof getTagsStartWith>>, TError = unknown>(
  keyword: string,
  params?: GetTagsStartWithParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTagsStartWith>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetTagsStartWithQueryOptions(keyword, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Í¥ÄÏ∞∞ Í∏∞Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary Í¥ÄÏ∞∞ Í∏∞Î°ù Ï°∞Ìöå
 */
export const getStudentRecord = (
  studentRecordId: number,
  params?: GetStudentRecordParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseStudentRecordResult>(
    { url: `/file/v1/student-record/${studentRecordId}`, method: 'GET', params, signal },
    options,
  );
};

export const getGetStudentRecordQueryKey = (studentRecordId: number, params?: GetStudentRecordParams) => {
  return [`/file/v1/student-record/${studentRecordId}`, ...(params ? [params] : [])] as const;
};

export const getGetStudentRecordQueryOptions = <TData = Awaited<ReturnType<typeof getStudentRecord>>, TError = unknown>(
  studentRecordId: number,
  params?: GetStudentRecordParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentRecord>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStudentRecordQueryKey(studentRecordId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getStudentRecord>>> = ({ signal }) =>
    getStudentRecord(studentRecordId, params, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!studentRecordId, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getStudentRecord>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetStudentRecordQueryResult = NonNullable<Awaited<ReturnType<typeof getStudentRecord>>>;
export type GetStudentRecordQueryError = unknown;

export function useGetStudentRecord<TData = Awaited<ReturnType<typeof getStudentRecord>>, TError = unknown>(
  studentRecordId: number,
  params: undefined | GetStudentRecordParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentRecord>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getStudentRecord>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetStudentRecord<TData = Awaited<ReturnType<typeof getStudentRecord>>, TError = unknown>(
  studentRecordId: number,
  params?: GetStudentRecordParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentRecord>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getStudentRecord>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetStudentRecord<TData = Awaited<ReturnType<typeof getStudentRecord>>, TError = unknown>(
  studentRecordId: number,
  params?: GetStudentRecordParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentRecord>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Í¥ÄÏ∞∞ Í∏∞Î°ù Ï°∞Ìöå
 */

export function useGetStudentRecord<TData = Awaited<ReturnType<typeof getStudentRecord>>, TError = unknown>(
  studentRecordId: number,
  params?: GetStudentRecordParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentRecord>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetStudentRecordQueryOptions(studentRecordId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Í≥ºÏ†ïÎ≥ÑÎ°ú Ïñ¥Îñ§ ÏòÅÏó≠Ïóê Ïñ¥Îñ§ Ìï≠Î™©Îì§ÏùÑ Î≥¥Ïó¨Ï§ÑÏßÄ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary Í¥ÄÏ∞∞Í∑∏ÎûòÌîÑÏóêÏÑú Î≥¥Ïó¨Ï§Ñ Ìï≠Î™©ÏùÑ Ï°∞Ìöå
 */
export const getIndicators = (
  params: GetIndicatorsParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListStudentEvaluationIndicatorResult>(
    { url: `/file/v1/student-record/indicators`, method: 'GET', params, signal },
    options,
  );
};

export const getGetIndicatorsQueryKey = (params: GetIndicatorsParams) => {
  return [`/file/v1/student-record/indicators`, ...(params ? [params] : [])] as const;
};

export const getGetIndicatorsQueryOptions = <TData = Awaited<ReturnType<typeof getIndicators>>, TError = unknown>(
  params: GetIndicatorsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIndicators>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetIndicatorsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getIndicators>>> = ({ signal }) =>
    getIndicators(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getIndicators>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetIndicatorsQueryResult = NonNullable<Awaited<ReturnType<typeof getIndicators>>>;
export type GetIndicatorsQueryError = unknown;

export function useGetIndicators<TData = Awaited<ReturnType<typeof getIndicators>>, TError = unknown>(
  params: GetIndicatorsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIndicators>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getIndicators>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetIndicators<TData = Awaited<ReturnType<typeof getIndicators>>, TError = unknown>(
  params: GetIndicatorsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIndicators>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getIndicators>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetIndicators<TData = Awaited<ReturnType<typeof getIndicators>>, TError = unknown>(
  params: GetIndicatorsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIndicators>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Í¥ÄÏ∞∞Í∑∏ÎûòÌîÑÏóêÏÑú Î≥¥Ïó¨Ï§Ñ Ìï≠Î™©ÏùÑ Ï°∞Ìöå
 */

export function useGetIndicators<TData = Awaited<ReturnType<typeof getIndicators>>, TError = unknown>(
  params: GetIndicatorsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIndicators>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetIndicatorsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ai proxyÏóêÏÑú ÏßÄÌëúÎ•º Ï°∞ÌöåÌï† Îïå Ïì∏ apiÏûÖÎãàÎã§.
 * @summary [AI]ÏßÄÌëú Ï†ïÎ≥¥ Ï°∞Ìöå
 */
export const getIndicator = (code: string, options?: SecondParameter<typeof customFetcher>, signal?: AbortSignal) => {
  return customFetcher<ApiResponseStudentEvaluationIndicatorResult>(
    { url: `/file/v1/student-record/indicator/${code}`, method: 'GET', signal },
    options,
  );
};

export const getGetIndicatorQueryKey = (code: string) => {
  return [`/file/v1/student-record/indicator/${code}`] as const;
};

export const getGetIndicatorQueryOptions = <TData = Awaited<ReturnType<typeof getIndicator>>, TError = unknown>(
  code: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIndicator>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetIndicatorQueryKey(code);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getIndicator>>> = ({ signal }) =>
    getIndicator(code, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!code, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getIndicator>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetIndicatorQueryResult = NonNullable<Awaited<ReturnType<typeof getIndicator>>>;
export type GetIndicatorQueryError = unknown;

export function useGetIndicator<TData = Awaited<ReturnType<typeof getIndicator>>, TError = unknown>(
  code: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIndicator>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getIndicator>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetIndicator<TData = Awaited<ReturnType<typeof getIndicator>>, TError = unknown>(
  code: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIndicator>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getIndicator>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetIndicator<TData = Awaited<ReturnType<typeof getIndicator>>, TError = unknown>(
  code: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIndicator>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary [AI]ÏßÄÌëú Ï†ïÎ≥¥ Ï°∞Ìöå
 */

export function useGetIndicator<TData = Awaited<ReturnType<typeof getIndicator>>, TError = unknown>(
  code: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIndicator>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetIndicatorQueryOptions(code, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÌïôÏÉùÏùò idÎ°ú Í¥ÄÏ∞∞ Í∏∞Î°ù ÌûàÏä§ÌÜ†Î¶¨Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary Í¥ÄÏ∞∞ Í∏∞Î°ù ÌûàÏä§ÌÜ†Î¶¨ Ï°∞Ìöå
 */
export const getStudentRecordHistory = (
  studentId: number,
  params?: GetStudentRecordHistoryParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListStudentRecordResult>(
    { url: `/file/v1/student-record/history/${studentId}`, method: 'GET', params, signal },
    options,
  );
};

export const getGetStudentRecordHistoryQueryKey = (studentId: number, params?: GetStudentRecordHistoryParams) => {
  return [`/file/v1/student-record/history/${studentId}`, ...(params ? [params] : [])] as const;
};

export const getGetStudentRecordHistoryQueryOptions = <
  TData = Awaited<ReturnType<typeof getStudentRecordHistory>>,
  TError = unknown,
>(
  studentId: number,
  params?: GetStudentRecordHistoryParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentRecordHistory>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStudentRecordHistoryQueryKey(studentId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getStudentRecordHistory>>> = ({ signal }) =>
    getStudentRecordHistory(studentId, params, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!studentId, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getStudentRecordHistory>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetStudentRecordHistoryQueryResult = NonNullable<Awaited<ReturnType<typeof getStudentRecordHistory>>>;
export type GetStudentRecordHistoryQueryError = unknown;

export function useGetStudentRecordHistory<
  TData = Awaited<ReturnType<typeof getStudentRecordHistory>>,
  TError = unknown,
>(
  studentId: number,
  params: undefined | GetStudentRecordHistoryParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentRecordHistory>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getStudentRecordHistory>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetStudentRecordHistory<
  TData = Awaited<ReturnType<typeof getStudentRecordHistory>>,
  TError = unknown,
>(
  studentId: number,
  params?: GetStudentRecordHistoryParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentRecordHistory>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getStudentRecordHistory>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetStudentRecordHistory<
  TData = Awaited<ReturnType<typeof getStudentRecordHistory>>,
  TError = unknown,
>(
  studentId: number,
  params?: GetStudentRecordHistoryParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentRecordHistory>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Í¥ÄÏ∞∞ Í∏∞Î°ù ÌûàÏä§ÌÜ†Î¶¨ Ï°∞Ìöå
 */

export function useGetStudentRecordHistory<
  TData = Awaited<ReturnType<typeof getStudentRecordHistory>>,
  TError = unknown,
>(
  studentId: number,
  params?: GetStudentRecordHistoryParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentRecordHistory>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetStudentRecordHistoryQueryOptions(studentId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Í≥ºÏ†ïÎ≥ÑÎ°ú Ïñ¥Îñ§ ÏòÅÏó≠Îì§ÏùÑ Î≥¥Ïó¨Ï§ÑÏßÄ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary Í¥ÄÏ∞∞Í∑∏ÎûòÌîÑÏóêÏÑú Î≥¥Ïó¨Ï§Ñ ÏòÅÏó≠Ï†ïÎ≥¥Î•º Ï°∞Ìöå
 */
export const getDomains = (
  params: GetDomainsParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListStudentEvaluationDomainResult>(
    { url: `/file/v1/student-record/domains`, method: 'GET', params, signal },
    options,
  );
};

export const getGetDomainsQueryKey = (params: GetDomainsParams) => {
  return [`/file/v1/student-record/domains`, ...(params ? [params] : [])] as const;
};

export const getGetDomainsQueryOptions = <TData = Awaited<ReturnType<typeof getDomains>>, TError = unknown>(
  params: GetDomainsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDomains>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDomainsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDomains>>> = ({ signal }) =>
    getDomains(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getDomains>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetDomainsQueryResult = NonNullable<Awaited<ReturnType<typeof getDomains>>>;
export type GetDomainsQueryError = unknown;

export function useGetDomains<TData = Awaited<ReturnType<typeof getDomains>>, TError = unknown>(
  params: GetDomainsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDomains>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getDomains>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetDomains<TData = Awaited<ReturnType<typeof getDomains>>, TError = unknown>(
  params: GetDomainsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDomains>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getDomains>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetDomains<TData = Awaited<ReturnType<typeof getDomains>>, TError = unknown>(
  params: GetDomainsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDomains>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Í¥ÄÏ∞∞Í∑∏ÎûòÌîÑÏóêÏÑú Î≥¥Ïó¨Ï§Ñ ÏòÅÏó≠Ï†ïÎ≥¥Î•º Ï°∞Ìöå
 */

export function useGetDomains<TData = Awaited<ReturnType<typeof getDomains>>, TError = unknown>(
  params: GetDomainsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDomains>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetDomainsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Ïä§ÌÜ†Î¶¨Î≥¥ÎìúÎ•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary Ïä§ÌÜ†Î¶¨Î≥¥Îìú Ï°∞Ìöå
 */
export const getStoryBoard = (
  storyBoardId: number,
  params?: GetStoryBoardParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseStoryBoardResult>(
    { url: `/file/v1/story-board/${storyBoardId}`, method: 'GET', params, signal },
    options,
  );
};

export const getGetStoryBoardQueryKey = (storyBoardId: number, params?: GetStoryBoardParams) => {
  return [`/file/v1/story-board/${storyBoardId}`, ...(params ? [params] : [])] as const;
};

export const getGetStoryBoardQueryOptions = <TData = Awaited<ReturnType<typeof getStoryBoard>>, TError = unknown>(
  storyBoardId: number,
  params?: GetStoryBoardParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoryBoard>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStoryBoardQueryKey(storyBoardId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getStoryBoard>>> = ({ signal }) =>
    getStoryBoard(storyBoardId, params, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!storyBoardId, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getStoryBoard>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetStoryBoardQueryResult = NonNullable<Awaited<ReturnType<typeof getStoryBoard>>>;
export type GetStoryBoardQueryError = unknown;

export function useGetStoryBoard<TData = Awaited<ReturnType<typeof getStoryBoard>>, TError = unknown>(
  storyBoardId: number,
  params: undefined | GetStoryBoardParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoryBoard>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getStoryBoard>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetStoryBoard<TData = Awaited<ReturnType<typeof getStoryBoard>>, TError = unknown>(
  storyBoardId: number,
  params?: GetStoryBoardParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoryBoard>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getStoryBoard>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetStoryBoard<TData = Awaited<ReturnType<typeof getStoryBoard>>, TError = unknown>(
  storyBoardId: number,
  params?: GetStoryBoardParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoryBoard>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Ïä§ÌÜ†Î¶¨Î≥¥Îìú Ï°∞Ìöå
 */

export function useGetStoryBoard<TData = Awaited<ReturnType<typeof getStoryBoard>>, TError = unknown>(
  storyBoardId: number,
  params?: GetStoryBoardParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoryBoard>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetStoryBoardQueryOptions(storyBoardId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÇ¨Ïö©ÏûêÏùò ÌîÑÎ°úÌïÑ idÎ°ú Ïä§ÌÜ†Î¶¨Î≥¥Îìú Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary Ïä§ÌÜ†Î¶¨Î≥¥Îìú Î¶¨Ïä§Ìä∏ Ï°∞Ìöå
 */
export const getStoryBoardList = (
  params?: GetStoryBoardListParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListStoryBoardResult>(
    { url: `/file/v1/story-board/list`, method: 'GET', params, signal },
    options,
  );
};

export const getGetStoryBoardListQueryKey = (params?: GetStoryBoardListParams) => {
  return [`/file/v1/story-board/list`, ...(params ? [params] : [])] as const;
};

export const getGetStoryBoardListQueryOptions = <
  TData = Awaited<ReturnType<typeof getStoryBoardList>>,
  TError = unknown,
>(
  params?: GetStoryBoardListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoryBoardList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStoryBoardListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getStoryBoardList>>> = ({ signal }) =>
    getStoryBoardList(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getStoryBoardList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetStoryBoardListQueryResult = NonNullable<Awaited<ReturnType<typeof getStoryBoardList>>>;
export type GetStoryBoardListQueryError = unknown;

export function useGetStoryBoardList<TData = Awaited<ReturnType<typeof getStoryBoardList>>, TError = unknown>(
  params: undefined | GetStoryBoardListParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoryBoardList>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getStoryBoardList>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetStoryBoardList<TData = Awaited<ReturnType<typeof getStoryBoardList>>, TError = unknown>(
  params?: GetStoryBoardListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoryBoardList>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getStoryBoardList>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetStoryBoardList<TData = Awaited<ReturnType<typeof getStoryBoardList>>, TError = unknown>(
  params?: GetStoryBoardListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoryBoardList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Ïä§ÌÜ†Î¶¨Î≥¥Îìú Î¶¨Ïä§Ìä∏ Ï°∞Ìöå
 */

export function useGetStoryBoardList<TData = Awaited<ReturnType<typeof getStoryBoardList>>, TError = unknown>(
  params?: GetStoryBoardListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStoryBoardList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetStoryBoardListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏßÄÏ†ïÌïú ÏÇ¨ÏßÑ Ïä§ÎßàÌä∏Ìè¥ÎçîÏùò idÎ°ú ÏûêÎ£å Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÏÇ¨ÏßÑ Ïä§ÎßàÌä∏ Ìè¥ÎçîÏùò ÏûêÎ£å Î¶¨Ïä§Ìä∏ Ï°∞Ìöå
 */
export const getIncludedPhotoItems = (
  smartFolderItemId: string,
  params?: GetIncludedPhotoItemsParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/file/v1/smart-folder/photo/${smartFolderItemId}/item-list`, method: 'GET', params, signal },
    options,
  );
};

export const getGetIncludedPhotoItemsQueryKey = (smartFolderItemId: string, params?: GetIncludedPhotoItemsParams) => {
  return [`/file/v1/smart-folder/photo/${smartFolderItemId}/item-list`, ...(params ? [params] : [])] as const;
};

export const getGetIncludedPhotoItemsQueryOptions = <
  TData = Awaited<ReturnType<typeof getIncludedPhotoItems>>,
  TError = unknown,
>(
  smartFolderItemId: string,
  params?: GetIncludedPhotoItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncludedPhotoItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetIncludedPhotoItemsQueryKey(smartFolderItemId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getIncludedPhotoItems>>> = ({ signal }) =>
    getIncludedPhotoItems(smartFolderItemId, params, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!smartFolderItemId, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getIncludedPhotoItems>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetIncludedPhotoItemsQueryResult = NonNullable<Awaited<ReturnType<typeof getIncludedPhotoItems>>>;
export type GetIncludedPhotoItemsQueryError = unknown;

export function useGetIncludedPhotoItems<TData = Awaited<ReturnType<typeof getIncludedPhotoItems>>, TError = unknown>(
  smartFolderItemId: string,
  params: undefined | GetIncludedPhotoItemsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncludedPhotoItems>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getIncludedPhotoItems>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetIncludedPhotoItems<TData = Awaited<ReturnType<typeof getIncludedPhotoItems>>, TError = unknown>(
  smartFolderItemId: string,
  params?: GetIncludedPhotoItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncludedPhotoItems>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getIncludedPhotoItems>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetIncludedPhotoItems<TData = Awaited<ReturnType<typeof getIncludedPhotoItems>>, TError = unknown>(
  smartFolderItemId: string,
  params?: GetIncludedPhotoItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncludedPhotoItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÏÇ¨ÏßÑ Ïä§ÎßàÌä∏ Ìè¥ÎçîÏùò ÏûêÎ£å Î¶¨Ïä§Ìä∏ Ï°∞Ìöå
 */

export function useGetIncludedPhotoItems<TData = Awaited<ReturnType<typeof getIncludedPhotoItems>>, TError = unknown>(
  smartFolderItemId: string,
  params?: GetIncludedPhotoItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncludedPhotoItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetIncludedPhotoItemsQueryOptions(smartFolderItemId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÇ¨Ïö©ÏûêÏùò ÌîÑÎ°úÌïÑ idÏôÄ ÌäπÏ†ï Ìè¥ÎçîÍ∞Ä ÏûàÎã§Î©¥ ÌäπÏ†ïÌè¥Îçî idÎ°ú Ìè¥Îçî Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÏïÑÏù¥ ÏÇ¨ÏßÑ Î∂ÑÎ•ò Î™©Î°ù Î∞è ÏÇ¨Ïö©ÏûêÍ∞Ä ÎßåÎì† Ìè¥Îçî Ï°∞Ìöå
 */
export const getStudentFolders = (
  params?: GetStudentFoldersParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/file/v1/smart-folder/photo/student/folder-list`, method: 'GET', params, signal },
    options,
  );
};

export const getGetStudentFoldersQueryKey = (params?: GetStudentFoldersParams) => {
  return [`/file/v1/smart-folder/photo/student/folder-list`, ...(params ? [params] : [])] as const;
};

export const getGetStudentFoldersQueryOptions = <
  TData = Awaited<ReturnType<typeof getStudentFolders>>,
  TError = unknown,
>(
  params?: GetStudentFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStudentFoldersQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getStudentFolders>>> = ({ signal }) =>
    getStudentFolders(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getStudentFolders>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetStudentFoldersQueryResult = NonNullable<Awaited<ReturnType<typeof getStudentFolders>>>;
export type GetStudentFoldersQueryError = unknown;

export function useGetStudentFolders<TData = Awaited<ReturnType<typeof getStudentFolders>>, TError = unknown>(
  params: undefined | GetStudentFoldersParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentFolders>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getStudentFolders>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetStudentFolders<TData = Awaited<ReturnType<typeof getStudentFolders>>, TError = unknown>(
  params?: GetStudentFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentFolders>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getStudentFolders>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetStudentFolders<TData = Awaited<ReturnType<typeof getStudentFolders>>, TError = unknown>(
  params?: GetStudentFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÏïÑÏù¥ ÏÇ¨ÏßÑ Î∂ÑÎ•ò Î™©Î°ù Î∞è ÏÇ¨Ïö©ÏûêÍ∞Ä ÎßåÎì† Ìè¥Îçî Ï°∞Ìöå
 */

export function useGetStudentFolders<TData = Awaited<ReturnType<typeof getStudentFolders>>, TError = unknown>(
  params?: GetStudentFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetStudentFoldersQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏïÑÏù¥ idÎ•º ÏÇ¨Ïö©ÌïòÏó¨ ÏïÑÏù¥ Î∂ÑÎ•ò ÏÇ¨ÏßÑ Ìè¥ÎçîÎ•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÏïÑÏù¥ Î∂ÑÎ•ò ÏÇ¨ÏßÑ Ìè¥Îçî Ï°∞Ìöå
 */
export const getStudentPhotoFolderWithStudentId = (
  params: GetStudentPhotoFolderWithStudentIdParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseSmartFolderItemResult>(
    { url: `/file/v1/smart-folder/photo/student-photo-folder`, method: 'GET', params, signal },
    options,
  );
};

export const getGetStudentPhotoFolderWithStudentIdQueryKey = (params: GetStudentPhotoFolderWithStudentIdParams) => {
  return [`/file/v1/smart-folder/photo/student-photo-folder`, ...(params ? [params] : [])] as const;
};

export const getGetStudentPhotoFolderWithStudentIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getStudentPhotoFolderWithStudentId>>,
  TError = unknown,
>(
  params: GetStudentPhotoFolderWithStudentIdParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentPhotoFolderWithStudentId>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStudentPhotoFolderWithStudentIdQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getStudentPhotoFolderWithStudentId>>> = ({ signal }) =>
    getStudentPhotoFolderWithStudentId(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getStudentPhotoFolderWithStudentId>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetStudentPhotoFolderWithStudentIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getStudentPhotoFolderWithStudentId>>
>;
export type GetStudentPhotoFolderWithStudentIdQueryError = unknown;

export function useGetStudentPhotoFolderWithStudentId<
  TData = Awaited<ReturnType<typeof getStudentPhotoFolderWithStudentId>>,
  TError = unknown,
>(
  params: GetStudentPhotoFolderWithStudentIdParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentPhotoFolderWithStudentId>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getStudentPhotoFolderWithStudentId>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetStudentPhotoFolderWithStudentId<
  TData = Awaited<ReturnType<typeof getStudentPhotoFolderWithStudentId>>,
  TError = unknown,
>(
  params: GetStudentPhotoFolderWithStudentIdParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentPhotoFolderWithStudentId>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getStudentPhotoFolderWithStudentId>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetStudentPhotoFolderWithStudentId<
  TData = Awaited<ReturnType<typeof getStudentPhotoFolderWithStudentId>>,
  TError = unknown,
>(
  params: GetStudentPhotoFolderWithStudentIdParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentPhotoFolderWithStudentId>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÏïÑÏù¥ Î∂ÑÎ•ò ÏÇ¨ÏßÑ Ìè¥Îçî Ï°∞Ìöå
 */

export function useGetStudentPhotoFolderWithStudentId<
  TData = Awaited<ReturnType<typeof getStudentPhotoFolderWithStudentId>>,
  TError = unknown,
>(
  params: GetStudentPhotoFolderWithStudentIdParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentPhotoFolderWithStudentId>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetStudentPhotoFolderWithStudentIdQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÇ¨ÏßÑ Ïä§ÎßàÌä∏Ìè¥Îçî ÌôàÏóêÏÑú Î≥¥Ïó¨Ï§Ñ Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§. Î∂ÑÎ•òÎäî rootType Í∏∞Ï§ÄÏúºÎ°ú ÌïòÏãúÎ©¥ Îê©ÎãàÎã§.
 * @summary ÏÇ¨ÏßÑ Ïä§ÎßàÌä∏Ìè¥Îçî Ìôà Î™©Î°ùÏóêÏÑú ÌïÑÏöîÌïú Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 */
export const getPhotoHomeFolders = (
  params?: GetPhotoHomeFoldersParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderResult>(
    { url: `/file/v1/smart-folder/photo/home-folder-list`, method: 'GET', params, signal },
    options,
  );
};

export const getGetPhotoHomeFoldersQueryKey = (params?: GetPhotoHomeFoldersParams) => {
  return [`/file/v1/smart-folder/photo/home-folder-list`, ...(params ? [params] : [])] as const;
};

export const getGetPhotoHomeFoldersQueryOptions = <
  TData = Awaited<ReturnType<typeof getPhotoHomeFolders>>,
  TError = unknown,
>(
  params?: GetPhotoHomeFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotoHomeFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPhotoHomeFoldersQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPhotoHomeFolders>>> = ({ signal }) =>
    getPhotoHomeFolders(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPhotoHomeFolders>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetPhotoHomeFoldersQueryResult = NonNullable<Awaited<ReturnType<typeof getPhotoHomeFolders>>>;
export type GetPhotoHomeFoldersQueryError = unknown;

export function useGetPhotoHomeFolders<TData = Awaited<ReturnType<typeof getPhotoHomeFolders>>, TError = unknown>(
  params: undefined | GetPhotoHomeFoldersParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotoHomeFolders>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getPhotoHomeFolders>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetPhotoHomeFolders<TData = Awaited<ReturnType<typeof getPhotoHomeFolders>>, TError = unknown>(
  params?: GetPhotoHomeFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotoHomeFolders>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getPhotoHomeFolders>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetPhotoHomeFolders<TData = Awaited<ReturnType<typeof getPhotoHomeFolders>>, TError = unknown>(
  params?: GetPhotoHomeFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotoHomeFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÏÇ¨ÏßÑ Ïä§ÎßàÌä∏Ìè¥Îçî Ìôà Î™©Î°ùÏóêÏÑú ÌïÑÏöîÌïú Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetPhotoHomeFolders<TData = Awaited<ReturnType<typeof getPhotoHomeFolders>>, TError = unknown>(
  params?: GetPhotoHomeFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotoHomeFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetPhotoHomeFoldersQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÇ¨Ïö©ÏûêÏùò ÌîÑÎ°úÌïÑ idÎ°ú ÏÇ¨ÏßÑ Ïä§ÎßàÌä∏Ìè¥ÎçîÏùò Ìè¥Îçî Íµ¨Ï°∞ Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÏÇ¨ÏßÑ Ïä§ÎßàÌä∏Ìè¥ÎçîÏùò Ìè¥Îçî Î™©Î°ù Ï°∞Ìöå
 */
export const getPhotoFolderTree = (
  params?: GetPhotoFolderTreeParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderTreeResult>(
    { url: `/file/v1/smart-folder/photo/folder-tree`, method: 'GET', params, signal },
    options,
  );
};

export const getGetPhotoFolderTreeQueryKey = (params?: GetPhotoFolderTreeParams) => {
  return [`/file/v1/smart-folder/photo/folder-tree`, ...(params ? [params] : [])] as const;
};

export const getGetPhotoFolderTreeQueryOptions = <
  TData = Awaited<ReturnType<typeof getPhotoFolderTree>>,
  TError = unknown,
>(
  params?: GetPhotoFolderTreeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotoFolderTree>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPhotoFolderTreeQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPhotoFolderTree>>> = ({ signal }) =>
    getPhotoFolderTree(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPhotoFolderTree>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetPhotoFolderTreeQueryResult = NonNullable<Awaited<ReturnType<typeof getPhotoFolderTree>>>;
export type GetPhotoFolderTreeQueryError = unknown;

export function useGetPhotoFolderTree<TData = Awaited<ReturnType<typeof getPhotoFolderTree>>, TError = unknown>(
  params: undefined | GetPhotoFolderTreeParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotoFolderTree>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getPhotoFolderTree>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetPhotoFolderTree<TData = Awaited<ReturnType<typeof getPhotoFolderTree>>, TError = unknown>(
  params?: GetPhotoFolderTreeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotoFolderTree>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getPhotoFolderTree>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetPhotoFolderTree<TData = Awaited<ReturnType<typeof getPhotoFolderTree>>, TError = unknown>(
  params?: GetPhotoFolderTreeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotoFolderTree>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÏÇ¨ÏßÑ Ïä§ÎßàÌä∏Ìè¥ÎçîÏùò Ìè¥Îçî Î™©Î°ù Ï°∞Ìöå
 */

export function useGetPhotoFolderTree<TData = Awaited<ReturnType<typeof getPhotoFolderTree>>, TError = unknown>(
  params?: GetPhotoFolderTreeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotoFolderTree>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetPhotoFolderTreeQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÇ¨Ïö©ÏûêÏùò ÌîÑÎ°úÌïÑ idÏôÄ ÌäπÏ†ï Ìè¥ÎçîÍ∞Ä ÏûàÎã§Î©¥ ÌäπÏ†ïÌè¥Îçî idÎ°ú Ìè¥Îçî Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÏÇ¨ÏßÑ Ïä§ÎßàÌä∏Ìè¥Îçî Î™©Î°ù Î∞è ÏÇ¨Ïö©ÏûêÍ∞Ä ÎßåÎì† Ìè¥Îçî Î™©Î°ù Ï°∞Ìöå
 */
export const getPhotoFolders = (
  params?: GetPhotoFoldersParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderResult>(
    { url: `/file/v1/smart-folder/photo/folder-list`, method: 'GET', params, signal },
    options,
  );
};

export const getGetPhotoFoldersQueryKey = (params?: GetPhotoFoldersParams) => {
  return [`/file/v1/smart-folder/photo/folder-list`, ...(params ? [params] : [])] as const;
};

export const getGetPhotoFoldersQueryOptions = <TData = Awaited<ReturnType<typeof getPhotoFolders>>, TError = unknown>(
  params?: GetPhotoFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotoFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPhotoFoldersQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPhotoFolders>>> = ({ signal }) =>
    getPhotoFolders(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPhotoFolders>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetPhotoFoldersQueryResult = NonNullable<Awaited<ReturnType<typeof getPhotoFolders>>>;
export type GetPhotoFoldersQueryError = unknown;

export function useGetPhotoFolders<TData = Awaited<ReturnType<typeof getPhotoFolders>>, TError = unknown>(
  params: undefined | GetPhotoFoldersParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotoFolders>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getPhotoFolders>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetPhotoFolders<TData = Awaited<ReturnType<typeof getPhotoFolders>>, TError = unknown>(
  params?: GetPhotoFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotoFolders>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getPhotoFolders>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetPhotoFolders<TData = Awaited<ReturnType<typeof getPhotoFolders>>, TError = unknown>(
  params?: GetPhotoFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotoFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÏÇ¨ÏßÑ Ïä§ÎßàÌä∏Ìè¥Îçî Î™©Î°ù Î∞è ÏÇ¨Ïö©ÏûêÍ∞Ä ÎßåÎì† Ìè¥Îçî Î™©Î°ù Ï°∞Ìöå
 */

export function useGetPhotoFolders<TData = Awaited<ReturnType<typeof getPhotoFolders>>, TError = unknown>(
  params?: GetPhotoFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotoFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetPhotoFoldersQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÇ¨Ïö©ÏûêÏùò ÌîÑÎ°úÌïÑ idÏôÄ ÌäπÏ†ï Ìè¥ÎçîÍ∞Ä ÏûàÎã§Î©¥ ÌäπÏ†ïÌè¥Îçî idÎ°ú Ìè¥Îçî Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÌôúÎèô ÏÇ¨ÏßÑ Î∂ÑÎ•ò Î™©Î°ù Î∞è ÏÇ¨Ïö©ÏûêÍ∞Ä ÎßåÎì† Ìè¥Îçî Ï°∞Ìöå
 */
export const getActivityFolders = (
  params?: GetActivityFoldersParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/file/v1/smart-folder/photo/activity/folder-list`, method: 'GET', params, signal },
    options,
  );
};

export const getGetActivityFoldersQueryKey = (params?: GetActivityFoldersParams) => {
  return [`/file/v1/smart-folder/photo/activity/folder-list`, ...(params ? [params] : [])] as const;
};

export const getGetActivityFoldersQueryOptions = <
  TData = Awaited<ReturnType<typeof getActivityFolders>>,
  TError = unknown,
>(
  params?: GetActivityFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivityFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetActivityFoldersQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getActivityFolders>>> = ({ signal }) =>
    getActivityFolders(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getActivityFolders>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetActivityFoldersQueryResult = NonNullable<Awaited<ReturnType<typeof getActivityFolders>>>;
export type GetActivityFoldersQueryError = unknown;

export function useGetActivityFolders<TData = Awaited<ReturnType<typeof getActivityFolders>>, TError = unknown>(
  params: undefined | GetActivityFoldersParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivityFolders>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getActivityFolders>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetActivityFolders<TData = Awaited<ReturnType<typeof getActivityFolders>>, TError = unknown>(
  params?: GetActivityFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivityFolders>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getActivityFolders>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetActivityFolders<TData = Awaited<ReturnType<typeof getActivityFolders>>, TError = unknown>(
  params?: GetActivityFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivityFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÌôúÎèô ÏÇ¨ÏßÑ Î∂ÑÎ•ò Î™©Î°ù Î∞è ÏÇ¨Ïö©ÏûêÍ∞Ä ÎßåÎì† Ìè¥Îçî Ï°∞Ìöå
 */

export function useGetActivityFolders<TData = Awaited<ReturnType<typeof getActivityFolders>>, TError = unknown>(
  params?: GetActivityFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivityFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetActivityFoldersQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÇ¨Ïö©ÏûêÏùò ÏÇ¨ÏßÑ Ïä§ÎßàÌä∏Ìè¥ÎçîÎ•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary (ÎÇ¥Î∂Ä ÏÇ¨Ïö©Ïö©)ÏÇ¨ÏßÑ Í∏∞Îä•Î≥Ñ Î£®Ìä∏Ìè¥Îçî Ï°∞Ìöå
 */
export const getImageRootFolder = (
  params: GetImageRootFolderParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseSmartFolderItemResult>(
    { url: `/file/v1/smart-folder/photo-folder-with-type`, method: 'GET', params, signal },
    options,
  );
};

export const getGetImageRootFolderQueryKey = (params: GetImageRootFolderParams) => {
  return [`/file/v1/smart-folder/photo-folder-with-type`, ...(params ? [params] : [])] as const;
};

export const getGetImageRootFolderQueryOptions = <
  TData = Awaited<ReturnType<typeof getImageRootFolder>>,
  TError = unknown,
>(
  params: GetImageRootFolderParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImageRootFolder>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetImageRootFolderQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getImageRootFolder>>> = ({ signal }) =>
    getImageRootFolder(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getImageRootFolder>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetImageRootFolderQueryResult = NonNullable<Awaited<ReturnType<typeof getImageRootFolder>>>;
export type GetImageRootFolderQueryError = unknown;

export function useGetImageRootFolder<TData = Awaited<ReturnType<typeof getImageRootFolder>>, TError = unknown>(
  params: GetImageRootFolderParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImageRootFolder>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getImageRootFolder>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetImageRootFolder<TData = Awaited<ReturnType<typeof getImageRootFolder>>, TError = unknown>(
  params: GetImageRootFolderParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImageRootFolder>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getImageRootFolder>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetImageRootFolder<TData = Awaited<ReturnType<typeof getImageRootFolder>>, TError = unknown>(
  params: GetImageRootFolderParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImageRootFolder>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary (ÎÇ¥Î∂Ä ÏÇ¨Ïö©Ïö©)ÏÇ¨ÏßÑ Í∏∞Îä•Î≥Ñ Î£®Ìä∏Ìè¥Îçî Ï°∞Ìöå
 */

export function useGetImageRootFolder<TData = Awaited<ReturnType<typeof getImageRootFolder>>, TError = unknown>(
  params: GetImageRootFolderParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImageRootFolder>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetImageRootFolderQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getMobileUploadedFiles = (
  params?: GetMobileUploadedFilesParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/file/v1/smart-folder/mobile/item-list`, method: 'GET', params, signal },
    options,
  );
};

export const getGetMobileUploadedFilesQueryKey = (params?: GetMobileUploadedFilesParams) => {
  return [`/file/v1/smart-folder/mobile/item-list`, ...(params ? [params] : [])] as const;
};

export const getGetMobileUploadedFilesQueryOptions = <
  TData = Awaited<ReturnType<typeof getMobileUploadedFiles>>,
  TError = unknown,
>(
  params?: GetMobileUploadedFilesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMobileUploadedFiles>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMobileUploadedFilesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMobileUploadedFiles>>> = ({ signal }) =>
    getMobileUploadedFiles(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMobileUploadedFiles>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetMobileUploadedFilesQueryResult = NonNullable<Awaited<ReturnType<typeof getMobileUploadedFiles>>>;
export type GetMobileUploadedFilesQueryError = unknown;

export function useGetMobileUploadedFiles<TData = Awaited<ReturnType<typeof getMobileUploadedFiles>>, TError = unknown>(
  params: undefined | GetMobileUploadedFilesParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMobileUploadedFiles>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getMobileUploadedFiles>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetMobileUploadedFiles<TData = Awaited<ReturnType<typeof getMobileUploadedFiles>>, TError = unknown>(
  params?: GetMobileUploadedFilesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMobileUploadedFiles>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getMobileUploadedFiles>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetMobileUploadedFiles<TData = Awaited<ReturnType<typeof getMobileUploadedFiles>>, TError = unknown>(
  params?: GetMobileUploadedFilesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMobileUploadedFiles>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

export function useGetMobileUploadedFiles<TData = Awaited<ReturnType<typeof getMobileUploadedFiles>>, TError = unknown>(
  params?: GetMobileUploadedFilesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMobileUploadedFiles>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetMobileUploadedFilesQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÇ¨Ïö©ÏûêÏùò Î™®Î∞îÏùº ÏóÖÎ°úÎìú Î£®Ìä∏Ìè¥ÎçîÎ•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary (ÎÇ¥Î∂Ä ÏÇ¨Ïö©Ïö©)Î™®Î∞îÏùº ÏóÖÎ°úÎìú Î£®Ìä∏Ìè¥Îçî Ï°∞Ìöå
 */
export const getMobileUploadRootFolder = (options?: SecondParameter<typeof customFetcher>, signal?: AbortSignal) => {
  return customFetcher<ApiResponseSmartFolderItemResult>(
    { url: `/file/v1/smart-folder/mobile-upload-folder`, method: 'GET', signal },
    options,
  );
};

export const getGetMobileUploadRootFolderQueryKey = () => {
  return [`/file/v1/smart-folder/mobile-upload-folder`] as const;
};

export const getGetMobileUploadRootFolderQueryOptions = <
  TData = Awaited<ReturnType<typeof getMobileUploadRootFolder>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMobileUploadRootFolder>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMobileUploadRootFolderQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMobileUploadRootFolder>>> = ({ signal }) =>
    getMobileUploadRootFolder(requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMobileUploadRootFolder>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetMobileUploadRootFolderQueryResult = NonNullable<Awaited<ReturnType<typeof getMobileUploadRootFolder>>>;
export type GetMobileUploadRootFolderQueryError = unknown;

export function useGetMobileUploadRootFolder<
  TData = Awaited<ReturnType<typeof getMobileUploadRootFolder>>,
  TError = unknown,
>(options: {
  query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMobileUploadRootFolder>>, TError, TData>> &
    Pick<
      DefinedInitialDataOptions<Awaited<ReturnType<typeof getMobileUploadRootFolder>>, TError, TData>,
      'initialData'
    >;
  request?: SecondParameter<typeof customFetcher>;
}): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetMobileUploadRootFolder<
  TData = Awaited<ReturnType<typeof getMobileUploadRootFolder>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMobileUploadRootFolder>>, TError, TData>> &
    Pick<
      UndefinedInitialDataOptions<Awaited<ReturnType<typeof getMobileUploadRootFolder>>, TError, TData>,
      'initialData'
    >;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetMobileUploadRootFolder<
  TData = Awaited<ReturnType<typeof getMobileUploadRootFolder>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMobileUploadRootFolder>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary (ÎÇ¥Î∂Ä ÏÇ¨Ïö©Ïö©)Î™®Î∞îÏùº ÏóÖÎ°úÎìú Î£®Ìä∏Ìè¥Îçî Ï°∞Ìöå
 */

export function useGetMobileUploadRootFolder<
  TData = Awaited<ReturnType<typeof getMobileUploadRootFolder>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMobileUploadRootFolder>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetMobileUploadRootFolderQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÇ¨Ïö©ÏûêÏùò ÌîÑÎ°úÌïÑ idÎ°ú Ï†ÑÏ≤¥ Ïä§ÎßàÌä∏Ìè¥ÎçîÏùò Ìè¥Îçî Íµ¨Ï°∞ Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary Ïä§ÎßàÌä∏Ìè¥ÎçîÏùò Ï†ÑÏ≤¥ Ìè¥Îçî Î™©Î°ù Ï°∞Ìöå
 */
export const getFolderTreeFromRoot = (options?: SecondParameter<typeof customFetcher>, signal?: AbortSignal) => {
  return customFetcher<ApiResponseListSmartFolderTreeResult>(
    { url: `/file/v1/smart-folder/folder-tree`, method: 'GET', signal },
    options,
  );
};

export const getGetFolderTreeFromRootQueryKey = () => {
  return [`/file/v1/smart-folder/folder-tree`] as const;
};

export const getGetFolderTreeFromRootQueryOptions = <
  TData = Awaited<ReturnType<typeof getFolderTreeFromRoot>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFolderTreeFromRoot>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetFolderTreeFromRootQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFolderTreeFromRoot>>> = ({ signal }) =>
    getFolderTreeFromRoot(requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getFolderTreeFromRoot>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetFolderTreeFromRootQueryResult = NonNullable<Awaited<ReturnType<typeof getFolderTreeFromRoot>>>;
export type GetFolderTreeFromRootQueryError = unknown;

export function useGetFolderTreeFromRoot<
  TData = Awaited<ReturnType<typeof getFolderTreeFromRoot>>,
  TError = unknown,
>(options: {
  query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFolderTreeFromRoot>>, TError, TData>> &
    Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getFolderTreeFromRoot>>, TError, TData>, 'initialData'>;
  request?: SecondParameter<typeof customFetcher>;
}): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetFolderTreeFromRoot<
  TData = Awaited<ReturnType<typeof getFolderTreeFromRoot>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFolderTreeFromRoot>>, TError, TData>> &
    Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getFolderTreeFromRoot>>, TError, TData>, 'initialData'>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetFolderTreeFromRoot<
  TData = Awaited<ReturnType<typeof getFolderTreeFromRoot>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFolderTreeFromRoot>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Ïä§ÎßàÌä∏Ìè¥ÎçîÏùò Ï†ÑÏ≤¥ Ìè¥Îçî Î™©Î°ù Ï°∞Ìöå
 */

export function useGetFolderTreeFromRoot<
  TData = Awaited<ReturnType<typeof getFolderTreeFromRoot>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFolderTreeFromRoot>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetFolderTreeFromRootQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏßÄÏ†ïÌïú Î¨∏ÏÑú Ïä§ÎßàÌä∏Ìè¥ÎçîÏùò idÎ°ú ÏûêÎ£å Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary Î¨∏ÏÑú Ïä§ÎßàÌä∏ Ìè¥ÎçîÏùò ÏûêÎ£å Î¶¨Ïä§Ìä∏ Ï°∞Ìöå
 */
export const getIncludedDocsItems = (
  smartFolderItemId: string,
  params?: GetIncludedDocsItemsParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/file/v1/smart-folder/docs/${smartFolderItemId}/item-list`, method: 'GET', params, signal },
    options,
  );
};

export const getGetIncludedDocsItemsQueryKey = (smartFolderItemId: string, params?: GetIncludedDocsItemsParams) => {
  return [`/file/v1/smart-folder/docs/${smartFolderItemId}/item-list`, ...(params ? [params] : [])] as const;
};

export const getGetIncludedDocsItemsQueryOptions = <
  TData = Awaited<ReturnType<typeof getIncludedDocsItems>>,
  TError = unknown,
>(
  smartFolderItemId: string,
  params?: GetIncludedDocsItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncludedDocsItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetIncludedDocsItemsQueryKey(smartFolderItemId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getIncludedDocsItems>>> = ({ signal }) =>
    getIncludedDocsItems(smartFolderItemId, params, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!smartFolderItemId, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getIncludedDocsItems>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetIncludedDocsItemsQueryResult = NonNullable<Awaited<ReturnType<typeof getIncludedDocsItems>>>;
export type GetIncludedDocsItemsQueryError = unknown;

export function useGetIncludedDocsItems<TData = Awaited<ReturnType<typeof getIncludedDocsItems>>, TError = unknown>(
  smartFolderItemId: string,
  params: undefined | GetIncludedDocsItemsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncludedDocsItems>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getIncludedDocsItems>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetIncludedDocsItems<TData = Awaited<ReturnType<typeof getIncludedDocsItems>>, TError = unknown>(
  smartFolderItemId: string,
  params?: GetIncludedDocsItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncludedDocsItems>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getIncludedDocsItems>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetIncludedDocsItems<TData = Awaited<ReturnType<typeof getIncludedDocsItems>>, TError = unknown>(
  smartFolderItemId: string,
  params?: GetIncludedDocsItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncludedDocsItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Î¨∏ÏÑú Ïä§ÎßàÌä∏ Ìè¥ÎçîÏùò ÏûêÎ£å Î¶¨Ïä§Ìä∏ Ï°∞Ìöå
 */

export function useGetIncludedDocsItems<TData = Awaited<ReturnType<typeof getIncludedDocsItems>>, TError = unknown>(
  smartFolderItemId: string,
  params?: GetIncludedDocsItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncludedDocsItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetIncludedDocsItemsQueryOptions(smartFolderItemId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏûêÎ£åÎ≥¥Îìú ÌôàÏóêÏÑú ÏûêÎ£å ÏúÑÏ†ØÎì§ Î≥¥Ïó¨Ï§Ñ Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÏûêÎ£åÎ≥¥Îìú ÌôàÏóêÏÑú ÏúÑÏ†Ø ÌëúÏãúÏóê ÌïÑÏöîÌïú Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 */
export const getWidgetFolders = (
  params?: GetWidgetFoldersParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderResult>(
    { url: `/file/v1/smart-folder/docs/home-widget-list`, method: 'GET', params, signal },
    options,
  );
};

export const getGetWidgetFoldersQueryKey = (params?: GetWidgetFoldersParams) => {
  return [`/file/v1/smart-folder/docs/home-widget-list`, ...(params ? [params] : [])] as const;
};

export const getGetWidgetFoldersQueryOptions = <TData = Awaited<ReturnType<typeof getWidgetFolders>>, TError = unknown>(
  params?: GetWidgetFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWidgetFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetWidgetFoldersQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getWidgetFolders>>> = ({ signal }) =>
    getWidgetFolders(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getWidgetFolders>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetWidgetFoldersQueryResult = NonNullable<Awaited<ReturnType<typeof getWidgetFolders>>>;
export type GetWidgetFoldersQueryError = unknown;

export function useGetWidgetFolders<TData = Awaited<ReturnType<typeof getWidgetFolders>>, TError = unknown>(
  params: undefined | GetWidgetFoldersParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWidgetFolders>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getWidgetFolders>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetWidgetFolders<TData = Awaited<ReturnType<typeof getWidgetFolders>>, TError = unknown>(
  params?: GetWidgetFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWidgetFolders>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getWidgetFolders>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetWidgetFolders<TData = Awaited<ReturnType<typeof getWidgetFolders>>, TError = unknown>(
  params?: GetWidgetFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWidgetFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÏûêÎ£åÎ≥¥Îìú ÌôàÏóêÏÑú ÏúÑÏ†Ø ÌëúÏãúÏóê ÌïÑÏöîÌïú Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetWidgetFolders<TData = Awaited<ReturnType<typeof getWidgetFolders>>, TError = unknown>(
  params?: GetWidgetFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWidgetFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetWidgetFoldersQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÇ¨Ïö©ÏûêÏùò ÌîÑÎ°úÌïÑ idÎ°ú ÏûêÎ£å Ïä§ÎßàÌä∏Ìè¥ÎçîÏùò Ìè¥Îçî Íµ¨Ï°∞ Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÏûêÎ£å Ïä§ÎßàÌä∏Ìè¥ÎçîÏùò Ìè¥Îçî Î™©Î°ù Ï°∞Ìöå
 */
export const getDocsFolderTree = (
  params?: GetDocsFolderTreeParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderTreeResult>(
    { url: `/file/v1/smart-folder/docs/folder-tree`, method: 'GET', params, signal },
    options,
  );
};

export const getGetDocsFolderTreeQueryKey = (params?: GetDocsFolderTreeParams) => {
  return [`/file/v1/smart-folder/docs/folder-tree`, ...(params ? [params] : [])] as const;
};

export const getGetDocsFolderTreeQueryOptions = <
  TData = Awaited<ReturnType<typeof getDocsFolderTree>>,
  TError = unknown,
>(
  params?: GetDocsFolderTreeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocsFolderTree>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDocsFolderTreeQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDocsFolderTree>>> = ({ signal }) =>
    getDocsFolderTree(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getDocsFolderTree>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetDocsFolderTreeQueryResult = NonNullable<Awaited<ReturnType<typeof getDocsFolderTree>>>;
export type GetDocsFolderTreeQueryError = unknown;

export function useGetDocsFolderTree<TData = Awaited<ReturnType<typeof getDocsFolderTree>>, TError = unknown>(
  params: undefined | GetDocsFolderTreeParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocsFolderTree>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getDocsFolderTree>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetDocsFolderTree<TData = Awaited<ReturnType<typeof getDocsFolderTree>>, TError = unknown>(
  params?: GetDocsFolderTreeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocsFolderTree>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getDocsFolderTree>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetDocsFolderTree<TData = Awaited<ReturnType<typeof getDocsFolderTree>>, TError = unknown>(
  params?: GetDocsFolderTreeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocsFolderTree>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÏûêÎ£å Ïä§ÎßàÌä∏Ìè¥ÎçîÏùò Ìè¥Îçî Î™©Î°ù Ï°∞Ìöå
 */

export function useGetDocsFolderTree<TData = Awaited<ReturnType<typeof getDocsFolderTree>>, TError = unknown>(
  params?: GetDocsFolderTreeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocsFolderTree>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetDocsFolderTreeQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÇ¨Ïö©ÏûêÏùò ÌîÑÎ°úÌïÑ idÏôÄ ÌäπÏ†ï Ìè¥ÎçîÍ∞Ä ÏûàÎã§Î©¥ ÌäπÏ†ïÌè¥Îçî idÎ°ú Ìè¥Îçî Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.parentSmartFolderIdÎ•º ÏöîÏ≤≠ÏïàÌïòÎ©¥ ÏûêÎ£åÎ≥¥ÎìúÏùò ÏúÑÏ†Ø Î™©Î°ùÏù¥ ÎêòÎäî Ìè¥ÎçîÎì§Ïù¥ Î∞òÌôòÎê©ÎãàÎã§.
 * @summary Î¨∏ÏÑú Í¥ÄÎ†® Î™©Î°ù Î∞è ÏÇ¨Ïö©ÏûêÍ∞Ä ÎßåÎì† Ìè¥Îçî Î™©Î°ù Ï°∞Ìöå
 */
export const getDocsFolders = (
  params?: GetDocsFoldersParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderResult>(
    { url: `/file/v1/smart-folder/docs/folder-list`, method: 'GET', params, signal },
    options,
  );
};

export const getGetDocsFoldersQueryKey = (params?: GetDocsFoldersParams) => {
  return [`/file/v1/smart-folder/docs/folder-list`, ...(params ? [params] : [])] as const;
};

export const getGetDocsFoldersQueryOptions = <TData = Awaited<ReturnType<typeof getDocsFolders>>, TError = unknown>(
  params?: GetDocsFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocsFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDocsFoldersQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDocsFolders>>> = ({ signal }) =>
    getDocsFolders(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getDocsFolders>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetDocsFoldersQueryResult = NonNullable<Awaited<ReturnType<typeof getDocsFolders>>>;
export type GetDocsFoldersQueryError = unknown;

export function useGetDocsFolders<TData = Awaited<ReturnType<typeof getDocsFolders>>, TError = unknown>(
  params: undefined | GetDocsFoldersParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocsFolders>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getDocsFolders>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetDocsFolders<TData = Awaited<ReturnType<typeof getDocsFolders>>, TError = unknown>(
  params?: GetDocsFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocsFolders>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getDocsFolders>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetDocsFolders<TData = Awaited<ReturnType<typeof getDocsFolders>>, TError = unknown>(
  params?: GetDocsFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocsFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Î¨∏ÏÑú Í¥ÄÎ†® Î™©Î°ù Î∞è ÏÇ¨Ïö©ÏûêÍ∞Ä ÎßåÎì† Ìè¥Îçî Î™©Î°ù Ï°∞Ìöå
 */

export function useGetDocsFolders<TData = Awaited<ReturnType<typeof getDocsFolders>>, TError = unknown>(
  params?: GetDocsFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocsFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetDocsFoldersQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Îπ†Î•∏ ÏûëÏóÖ ai Ï™ΩÏóêÏÑú Í∏∞Îä•Î≥Ñ Î∏åÎûòÎìú ÌÅ¨Îüº ÌôïÏù∏Ïö© api ÏûÖÎãàÎã§.
 * @summary AI Ïù¥ÎØ∏ÏßÄ ÏûëÏóÖÏùò Í∏∞Î≥∏ Ìè¥Îçî Í≤ΩÎ°úÎ•º Ï°∞ÌöåÌïòÎäî api
 */
export const getImageFlatPath = (
  params: GetImageFlatPathParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderTreeResult>(
    { url: `/file/v1/smart-folder/ai-image-task-flat-path`, method: 'GET', params, signal },
    options,
  );
};

export const getGetImageFlatPathQueryKey = (params: GetImageFlatPathParams) => {
  return [`/file/v1/smart-folder/ai-image-task-flat-path`, ...(params ? [params] : [])] as const;
};

export const getGetImageFlatPathQueryOptions = <TData = Awaited<ReturnType<typeof getImageFlatPath>>, TError = unknown>(
  params: GetImageFlatPathParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImageFlatPath>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetImageFlatPathQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getImageFlatPath>>> = ({ signal }) =>
    getImageFlatPath(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getImageFlatPath>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetImageFlatPathQueryResult = NonNullable<Awaited<ReturnType<typeof getImageFlatPath>>>;
export type GetImageFlatPathQueryError = unknown;

export function useGetImageFlatPath<TData = Awaited<ReturnType<typeof getImageFlatPath>>, TError = unknown>(
  params: GetImageFlatPathParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImageFlatPath>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getImageFlatPath>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetImageFlatPath<TData = Awaited<ReturnType<typeof getImageFlatPath>>, TError = unknown>(
  params: GetImageFlatPathParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImageFlatPath>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getImageFlatPath>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetImageFlatPath<TData = Awaited<ReturnType<typeof getImageFlatPath>>, TError = unknown>(
  params: GetImageFlatPathParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImageFlatPath>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary AI Ïù¥ÎØ∏ÏßÄ ÏûëÏóÖÏùò Í∏∞Î≥∏ Ìè¥Îçî Í≤ΩÎ°úÎ•º Ï°∞ÌöåÌïòÎäî api
 */

export function useGetImageFlatPath<TData = Awaited<ReturnType<typeof getImageFlatPath>>, TError = unknown>(
  params: GetImageFlatPathParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getImageFlatPath>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetImageFlatPathQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏãúÏä§ÌÖúÏóêÏÑú ÏÑ§Ï†ïÌïú Ï∂îÏ≤úÌÇ§ÏõåÎìúÎÇò Í∏∞Í∞ÑÎ≥Ñ ÏÉÅÌÉúÏóê Îî∞ÎùºÏÑú Í≥µÍ∞úÎêú ÏûêÎ£åÏ§ëÏóêÏÑú Ï∂îÏ≤úÌï† ÏûêÎ£åÎ•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary (ÎÜÄÏù¥ Í≥ÑÌöç ÏûëÏÑ±)ÌïòÎã® ÎÇ¥ ÏûêÎ£å Ï∂îÏ≤ú Ï°∞Ìöå.
 */
export const getRecommendPlansFromMyItems = (
  params?: GetRecommendPlansFromMyItemsParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/file/v1/recommendation/task/lecure-plan/user-items`, method: 'GET', params, signal },
    options,
  );
};

export const getGetRecommendPlansFromMyItemsQueryKey = (params?: GetRecommendPlansFromMyItemsParams) => {
  return [`/file/v1/recommendation/task/lecure-plan/user-items`, ...(params ? [params] : [])] as const;
};

export const getGetRecommendPlansFromMyItemsQueryOptions = <
  TData = Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>,
  TError = unknown,
>(
  params?: GetRecommendPlansFromMyItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRecommendPlansFromMyItemsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>> = ({ signal }) =>
    getRecommendPlansFromMyItems(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetRecommendPlansFromMyItemsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>
>;
export type GetRecommendPlansFromMyItemsQueryError = unknown;

export function useGetRecommendPlansFromMyItems<
  TData = Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>,
  TError = unknown,
>(
  params: undefined | GetRecommendPlansFromMyItemsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetRecommendPlansFromMyItems<
  TData = Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>,
  TError = unknown,
>(
  params?: GetRecommendPlansFromMyItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetRecommendPlansFromMyItems<
  TData = Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>,
  TError = unknown,
>(
  params?: GetRecommendPlansFromMyItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary (ÎÜÄÏù¥ Í≥ÑÌöç ÏûëÏÑ±)ÌïòÎã® ÎÇ¥ ÏûêÎ£å Ï∂îÏ≤ú Ï°∞Ìöå.
 */

export function useGetRecommendPlansFromMyItems<
  TData = Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>,
  TError = unknown,
>(
  params?: GetRecommendPlansFromMyItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetRecommendPlansFromMyItemsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏãúÏä§ÌÖúÏóêÏÑú ÏÑ§Ï†ïÌïú Ï∂îÏ≤úÌÇ§ÏõåÎìúÎÇò Í∏∞Í∞ÑÎ≥Ñ ÏÉÅÌÉúÏóê Îî∞ÎùºÏÑú Í≥µÍ∞úÎêú ÏûêÎ£åÏ§ëÏóêÏÑú Ï∂îÏ≤úÌï† ÏûêÎ£åÎ•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary (ÎÜÄÏù¥ Í≥ÑÌöç ÏûëÏÑ±)ÌïòÎã® Í≥µÍ∞ú ÏûêÎ£å Ï∂îÏ≤ú Ï°∞Ìöå.
 */
export const getRecommendPlansFromPublicItems = (
  params?: GetRecommendPlansFromPublicItemsParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/file/v1/recommendation/task/lecure-plan/public-items`, method: 'GET', params, signal },
    options,
  );
};

export const getGetRecommendPlansFromPublicItemsQueryKey = (params?: GetRecommendPlansFromPublicItemsParams) => {
  return [`/file/v1/recommendation/task/lecure-plan/public-items`, ...(params ? [params] : [])] as const;
};

export const getGetRecommendPlansFromPublicItemsQueryOptions = <
  TData = Awaited<ReturnType<typeof getRecommendPlansFromPublicItems>>,
  TError = unknown,
>(
  params?: GetRecommendPlansFromPublicItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendPlansFromPublicItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRecommendPlansFromPublicItemsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecommendPlansFromPublicItems>>> = ({ signal }) =>
    getRecommendPlansFromPublicItems(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRecommendPlansFromPublicItems>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetRecommendPlansFromPublicItemsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRecommendPlansFromPublicItems>>
>;
export type GetRecommendPlansFromPublicItemsQueryError = unknown;

export function useGetRecommendPlansFromPublicItems<
  TData = Awaited<ReturnType<typeof getRecommendPlansFromPublicItems>>,
  TError = unknown,
>(
  params: undefined | GetRecommendPlansFromPublicItemsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendPlansFromPublicItems>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getRecommendPlansFromPublicItems>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetRecommendPlansFromPublicItems<
  TData = Awaited<ReturnType<typeof getRecommendPlansFromPublicItems>>,
  TError = unknown,
>(
  params?: GetRecommendPlansFromPublicItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendPlansFromPublicItems>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getRecommendPlansFromPublicItems>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetRecommendPlansFromPublicItems<
  TData = Awaited<ReturnType<typeof getRecommendPlansFromPublicItems>>,
  TError = unknown,
>(
  params?: GetRecommendPlansFromPublicItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendPlansFromPublicItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary (ÎÜÄÏù¥ Í≥ÑÌöç ÏûëÏÑ±)ÌïòÎã® Í≥µÍ∞ú ÏûêÎ£å Ï∂îÏ≤ú Ï°∞Ìöå.
 */

export function useGetRecommendPlansFromPublicItems<
  TData = Awaited<ReturnType<typeof getRecommendPlansFromPublicItems>>,
  TError = unknown,
>(
  params?: GetRecommendPlansFromPublicItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendPlansFromPublicItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetRecommendPlansFromPublicItemsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏãúÏä§ÌÖúÏóêÏÑú ÏÑ§Ï†ïÌïú Ï∂îÏ≤úÌÇ§ÏõåÎìúÎÇò Í∏∞Í∞ÑÎ≥Ñ ÏÉÅÌÉúÏóê Îî∞ÎùºÏÑú Í≥µÍ∞úÎêú ÏûêÎ£åÏ§ëÏóêÏÑú Ï∂îÏ≤úÌï† ÎÜÄÏù¥Ïπ¥ÎìúÎ•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary (ÎÜÄÏù¥ Í≥ÑÌöç ÏûëÏÑ±)Ï∂îÏ≤ú ÎÜÄÏù¥ Ïπ¥Îìú Ï°∞Ìöå.
 */
export const getRecommendPlans = (
  params?: GetRecommendPlansParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/file/v1/recommendation/task/lecure-plan/plans`, method: 'GET', params, signal },
    options,
  );
};

export const getGetRecommendPlansQueryKey = (params?: GetRecommendPlansParams) => {
  return [`/file/v1/recommendation/task/lecure-plan/plans`, ...(params ? [params] : [])] as const;
};

export const getGetRecommendPlansQueryOptions = <
  TData = Awaited<ReturnType<typeof getRecommendPlans>>,
  TError = unknown,
>(
  params?: GetRecommendPlansParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendPlans>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRecommendPlansQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecommendPlans>>> = ({ signal }) =>
    getRecommendPlans(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRecommendPlans>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetRecommendPlansQueryResult = NonNullable<Awaited<ReturnType<typeof getRecommendPlans>>>;
export type GetRecommendPlansQueryError = unknown;

export function useGetRecommendPlans<TData = Awaited<ReturnType<typeof getRecommendPlans>>, TError = unknown>(
  params: undefined | GetRecommendPlansParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendPlans>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getRecommendPlans>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetRecommendPlans<TData = Awaited<ReturnType<typeof getRecommendPlans>>, TError = unknown>(
  params?: GetRecommendPlansParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendPlans>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getRecommendPlans>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetRecommendPlans<TData = Awaited<ReturnType<typeof getRecommendPlans>>, TError = unknown>(
  params?: GetRecommendPlansParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendPlans>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary (ÎÜÄÏù¥ Í≥ÑÌöç ÏûëÏÑ±)Ï∂îÏ≤ú ÎÜÄÏù¥ Ïπ¥Îìú Ï°∞Ìöå.
 */

export function useGetRecommendPlans<TData = Awaited<ReturnType<typeof getRecommendPlans>>, TError = unknown>(
  params?: GetRecommendPlansParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendPlans>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetRecommendPlansQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Í∏∞Îä•Î≥ÑÎ°ú Ï∂îÏ≤ú ÏûêÎ£åÎ•º Ï°∞Ìöå Ìï©ÎãàÎã§.(Î≥∏Ïù∏ ÏûêÎ£å Í∏∞Ï§Ä)
 * @summary [TEST] Í≥µÏö© Ï∂îÏ≤úÏûêÎ£å Î™©Î°ù Ï°∞Ìöå. (LNB)
 */
export const getRecommendItems = (
  params?: GetRecommendItemsParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/file/v1/recommendation/task/common-list`, method: 'GET', params, signal },
    options,
  );
};

export const getGetRecommendItemsQueryKey = (params?: GetRecommendItemsParams) => {
  return [`/file/v1/recommendation/task/common-list`, ...(params ? [params] : [])] as const;
};

export const getGetRecommendItemsQueryOptions = <
  TData = Awaited<ReturnType<typeof getRecommendItems>>,
  TError = unknown,
>(
  params?: GetRecommendItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRecommendItemsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecommendItems>>> = ({ signal }) =>
    getRecommendItems(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRecommendItems>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetRecommendItemsQueryResult = NonNullable<Awaited<ReturnType<typeof getRecommendItems>>>;
export type GetRecommendItemsQueryError = unknown;

export function useGetRecommendItems<TData = Awaited<ReturnType<typeof getRecommendItems>>, TError = unknown>(
  params: undefined | GetRecommendItemsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendItems>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getRecommendItems>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetRecommendItems<TData = Awaited<ReturnType<typeof getRecommendItems>>, TError = unknown>(
  params?: GetRecommendItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendItems>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getRecommendItems>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetRecommendItems<TData = Awaited<ReturnType<typeof getRecommendItems>>, TError = unknown>(
  params?: GetRecommendItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary [TEST] Í≥µÏö© Ï∂îÏ≤úÏûêÎ£å Î™©Î°ù Ï°∞Ìöå. (LNB)
 */

export function useGetRecommendItems<TData = Awaited<ReturnType<typeof getRecommendItems>>, TError = unknown>(
  params?: GetRecommendItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetRecommendItemsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏûêÎ£åÎ≥¥Îìú Î©îÏù∏ÌôîÎ©¥ ÌïòÎã®Ïùò Í≥µÍ∞úÏûêÎ£åÎ•º Ï°∞ÌöåÌïòÎäî api ÏûÖÎãàÎã§.
 * @summary Îã§Î•∏ÏÇ¨ÎûåÏùò Í≥µÍ∞úÎêú ÏûêÎ£å Î¶¨Ïä§Ìä∏Î•º Ï°∞ÌöåÌïòÎäî api
 */
export const getPublicItemForMain = (
  params?: GetPublicItemForMainParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/file/v1/recommendation/public-item-list`, method: 'GET', params, signal },
    options,
  );
};

export const getGetPublicItemForMainQueryKey = (params?: GetPublicItemForMainParams) => {
  return [`/file/v1/recommendation/public-item-list`, ...(params ? [params] : [])] as const;
};

export const getGetPublicItemForMainQueryOptions = <
  TData = Awaited<ReturnType<typeof getPublicItemForMain>>,
  TError = unknown,
>(
  params?: GetPublicItemForMainParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicItemForMain>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPublicItemForMainQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPublicItemForMain>>> = ({ signal }) =>
    getPublicItemForMain(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPublicItemForMain>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetPublicItemForMainQueryResult = NonNullable<Awaited<ReturnType<typeof getPublicItemForMain>>>;
export type GetPublicItemForMainQueryError = unknown;

export function useGetPublicItemForMain<TData = Awaited<ReturnType<typeof getPublicItemForMain>>, TError = unknown>(
  params: undefined | GetPublicItemForMainParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicItemForMain>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getPublicItemForMain>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetPublicItemForMain<TData = Awaited<ReturnType<typeof getPublicItemForMain>>, TError = unknown>(
  params?: GetPublicItemForMainParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicItemForMain>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getPublicItemForMain>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetPublicItemForMain<TData = Awaited<ReturnType<typeof getPublicItemForMain>>, TError = unknown>(
  params?: GetPublicItemForMainParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicItemForMain>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Îã§Î•∏ÏÇ¨ÎûåÏùò Í≥µÍ∞úÎêú ÏûêÎ£å Î¶¨Ïä§Ìä∏Î•º Ï°∞ÌöåÌïòÎäî api
 */

export function useGetPublicItemForMain<TData = Awaited<ReturnType<typeof getPublicItemForMain>>, TError = unknown>(
  params?: GetPublicItemForMainParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicItemForMain>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetPublicItemForMainQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÎÇ†Ïßú Í∏∞Ï§ÄÏúºÎ°ú Ï∂îÏ≤ú ÌÇ§ÏõåÎìúÍ∞Ä ÏÑ§Ï†ïÎêú Ï†ïÎ≥¥ Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary Ï∂îÏ≤ú ÌÇ§ÏõåÎìú Í¥ÄÎ†® ÏñªÍ∏∞
 */
export const getRecommendationKeywordInfo = (
  params?: GetRecommendationKeywordInfoParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListRecommendationKeywordBundleResult>(
    { url: `/file/v1/recommendation/common-keywords/info`, method: 'GET', params, signal },
    options,
  );
};

export const getGetRecommendationKeywordInfoQueryKey = (params?: GetRecommendationKeywordInfoParams) => {
  return [`/file/v1/recommendation/common-keywords/info`, ...(params ? [params] : [])] as const;
};

export const getGetRecommendationKeywordInfoQueryOptions = <
  TData = Awaited<ReturnType<typeof getRecommendationKeywordInfo>>,
  TError = unknown,
>(
  params?: GetRecommendationKeywordInfoParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendationKeywordInfo>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRecommendationKeywordInfoQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecommendationKeywordInfo>>> = ({ signal }) =>
    getRecommendationKeywordInfo(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRecommendationKeywordInfo>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetRecommendationKeywordInfoQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRecommendationKeywordInfo>>
>;
export type GetRecommendationKeywordInfoQueryError = unknown;

export function useGetRecommendationKeywordInfo<
  TData = Awaited<ReturnType<typeof getRecommendationKeywordInfo>>,
  TError = unknown,
>(
  params: undefined | GetRecommendationKeywordInfoParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendationKeywordInfo>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getRecommendationKeywordInfo>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetRecommendationKeywordInfo<
  TData = Awaited<ReturnType<typeof getRecommendationKeywordInfo>>,
  TError = unknown,
>(
  params?: GetRecommendationKeywordInfoParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendationKeywordInfo>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getRecommendationKeywordInfo>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetRecommendationKeywordInfo<
  TData = Awaited<ReturnType<typeof getRecommendationKeywordInfo>>,
  TError = unknown,
>(
  params?: GetRecommendationKeywordInfoParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendationKeywordInfo>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Ï∂îÏ≤ú ÌÇ§ÏõåÎìú Í¥ÄÎ†® ÏñªÍ∏∞
 */

export function useGetRecommendationKeywordInfo<
  TData = Awaited<ReturnType<typeof getRecommendationKeywordInfo>>,
  TError = unknown,
>(
  params?: GetRecommendationKeywordInfoParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendationKeywordInfo>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetRecommendationKeywordInfoQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÇ¨Ïö©Ïûê ÌîÑÎ°úÌïÑ idÎ°ú ÏµúÍ∑ºÏóê ÌÉúÍ∑∏Î°ú Îì±Î°ùÌïú ÌÇ§ÏõåÎìúÎ•º Ï°∞ÌöåÌï©ÎãàÎã§. (ÏóÜÏúºÎ©¥ 404 ÏùëÎãµ)
 * @summary ÏµúÍ∑º ÏÇ¨Ïö© ÌÉúÍ∑∏ ÏñªÍ∏∞
 */
export const getRecentTags = (
  profileId: string,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListString>(
    { url: `/file/v1/recent-tags/${profileId}`, method: 'GET', signal },
    options,
  );
};

export const getGetRecentTagsQueryKey = (profileId: string) => {
  return [`/file/v1/recent-tags/${profileId}`] as const;
};

export const getGetRecentTagsQueryOptions = <TData = Awaited<ReturnType<typeof getRecentTags>>, TError = unknown>(
  profileId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentTags>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRecentTagsQueryKey(profileId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecentTags>>> = ({ signal }) =>
    getRecentTags(profileId, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRecentTags>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetRecentTagsQueryResult = NonNullable<Awaited<ReturnType<typeof getRecentTags>>>;
export type GetRecentTagsQueryError = unknown;

export function useGetRecentTags<TData = Awaited<ReturnType<typeof getRecentTags>>, TError = unknown>(
  profileId: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentTags>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getRecentTags>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetRecentTags<TData = Awaited<ReturnType<typeof getRecentTags>>, TError = unknown>(
  profileId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentTags>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getRecentTags>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetRecentTags<TData = Awaited<ReturnType<typeof getRecentTags>>, TError = unknown>(
  profileId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentTags>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÏµúÍ∑º ÏÇ¨Ïö© ÌÉúÍ∑∏ ÏñªÍ∏∞
 */

export function useGetRecentTags<TData = Awaited<ReturnType<typeof getRecentTags>>, TError = unknown>(
  profileId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecentTags>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetRecentTagsQueryOptions(profileId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Í≥µÍ∞ú ÏûêÎ£å idÎ•º Ïù¥Ïö©Ìï¥ÏÑú ÏûêÎ£åÏùò ÏÑ∏Î∂ÄÏ†ïÎ≥¥Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary Í≥µÍ∞úÎêú ÌååÏùºÏùò ÏÉÅÏÑ∏Î≥¥Í∏∞ Íµ¨ÌòÑÏùÑ ÏúÑÌï¥ Ï°∞ÌöåÌïòÎäî api
 */
export const getPublicItem1 = (
  params: GetPublicItem1Params,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponsePublicUrlItemDetailedResult>(
    { url: `/file/v1/public-url-item/detailed-info`, method: 'GET', params, signal },
    options,
  );
};

export const getGetPublicItem1QueryKey = (params: GetPublicItem1Params) => {
  return [`/file/v1/public-url-item/detailed-info`, ...(params ? [params] : [])] as const;
};

export const getGetPublicItem1QueryOptions = <TData = Awaited<ReturnType<typeof getPublicItem1>>, TError = unknown>(
  params: GetPublicItem1Params,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicItem1>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPublicItem1QueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPublicItem1>>> = ({ signal }) =>
    getPublicItem1(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPublicItem1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetPublicItem1QueryResult = NonNullable<Awaited<ReturnType<typeof getPublicItem1>>>;
export type GetPublicItem1QueryError = unknown;

export function useGetPublicItem1<TData = Awaited<ReturnType<typeof getPublicItem1>>, TError = unknown>(
  params: GetPublicItem1Params,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicItem1>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getPublicItem1>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetPublicItem1<TData = Awaited<ReturnType<typeof getPublicItem1>>, TError = unknown>(
  params: GetPublicItem1Params,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicItem1>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getPublicItem1>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetPublicItem1<TData = Awaited<ReturnType<typeof getPublicItem1>>, TError = unknown>(
  params: GetPublicItem1Params,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicItem1>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Í≥µÍ∞úÎêú ÌååÏùºÏùò ÏÉÅÏÑ∏Î≥¥Í∏∞ Íµ¨ÌòÑÏùÑ ÏúÑÌï¥ Ï°∞ÌöåÌïòÎäî api
 */

export function useGetPublicItem1<TData = Awaited<ReturnType<typeof getPublicItem1>>, TError = unknown>(
  params: GetPublicItem1Params,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicItem1>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetPublicItem1QueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏßÄÏ†ïÌïú ÎÇ¥Ìè¥ÎçîÏùò idÎ°ú ÏûêÎ£å Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÎÇ¥ Ìè¥ÎçîÏùò ÏûêÎ£å Î¶¨Ïä§Ìä∏ Ï°∞Ìöå
 */
export const getIncludedItems = (
  smartFolderItemid: string,
  params?: GetIncludedItemsParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/file/v1/my-folder/${smartFolderItemid}/item-list`, method: 'GET', params, signal },
    options,
  );
};

export const getGetIncludedItemsQueryKey = (smartFolderItemid: string, params?: GetIncludedItemsParams) => {
  return [`/file/v1/my-folder/${smartFolderItemid}/item-list`, ...(params ? [params] : [])] as const;
};

export const getGetIncludedItemsQueryOptions = <TData = Awaited<ReturnType<typeof getIncludedItems>>, TError = unknown>(
  smartFolderItemid: string,
  params?: GetIncludedItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncludedItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetIncludedItemsQueryKey(smartFolderItemid, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getIncludedItems>>> = ({ signal }) =>
    getIncludedItems(smartFolderItemid, params, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!smartFolderItemid, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getIncludedItems>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetIncludedItemsQueryResult = NonNullable<Awaited<ReturnType<typeof getIncludedItems>>>;
export type GetIncludedItemsQueryError = unknown;

export function useGetIncludedItems<TData = Awaited<ReturnType<typeof getIncludedItems>>, TError = unknown>(
  smartFolderItemid: string,
  params: undefined | GetIncludedItemsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncludedItems>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getIncludedItems>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetIncludedItems<TData = Awaited<ReturnType<typeof getIncludedItems>>, TError = unknown>(
  smartFolderItemid: string,
  params?: GetIncludedItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncludedItems>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getIncludedItems>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetIncludedItems<TData = Awaited<ReturnType<typeof getIncludedItems>>, TError = unknown>(
  smartFolderItemid: string,
  params?: GetIncludedItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncludedItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÎÇ¥ Ìè¥ÎçîÏùò ÏûêÎ£å Î¶¨Ïä§Ìä∏ Ï°∞Ìöå
 */

export function useGetIncludedItems<TData = Awaited<ReturnType<typeof getIncludedItems>>, TError = unknown>(
  smartFolderItemid: string,
  params?: GetIncludedItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncludedItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetIncludedItemsQueryOptions(smartFolderItemid, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÇ¨Ïö©ÏûêÏùò ÌîÑÎ°úÌïÑ idÎ°ú ÎÇ¥ Ìè¥Îçî Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÏÇ¨Ïö©ÏûêÏùò ÎÇ¥ Ìè¥Îçî Î¶¨Ïä§Ìä∏ Ï°∞Ìöå
 */
export const getMyFoldersDeprecate = (
  params?: GetMyFoldersDeprecateParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderResult>(
    { url: `/file/v1/my-folder/list`, method: 'GET', params, signal },
    options,
  );
};

export const getGetMyFoldersDeprecateQueryKey = (params?: GetMyFoldersDeprecateParams) => {
  return [`/file/v1/my-folder/list`, ...(params ? [params] : [])] as const;
};

export const getGetMyFoldersDeprecateQueryOptions = <
  TData = Awaited<ReturnType<typeof getMyFoldersDeprecate>>,
  TError = unknown,
>(
  params?: GetMyFoldersDeprecateParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyFoldersDeprecate>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMyFoldersDeprecateQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyFoldersDeprecate>>> = ({ signal }) =>
    getMyFoldersDeprecate(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMyFoldersDeprecate>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetMyFoldersDeprecateQueryResult = NonNullable<Awaited<ReturnType<typeof getMyFoldersDeprecate>>>;
export type GetMyFoldersDeprecateQueryError = unknown;

export function useGetMyFoldersDeprecate<TData = Awaited<ReturnType<typeof getMyFoldersDeprecate>>, TError = unknown>(
  params: undefined | GetMyFoldersDeprecateParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyFoldersDeprecate>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getMyFoldersDeprecate>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetMyFoldersDeprecate<TData = Awaited<ReturnType<typeof getMyFoldersDeprecate>>, TError = unknown>(
  params?: GetMyFoldersDeprecateParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyFoldersDeprecate>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getMyFoldersDeprecate>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetMyFoldersDeprecate<TData = Awaited<ReturnType<typeof getMyFoldersDeprecate>>, TError = unknown>(
  params?: GetMyFoldersDeprecateParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyFoldersDeprecate>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÏÇ¨Ïö©ÏûêÏùò ÎÇ¥ Ìè¥Îçî Î¶¨Ïä§Ìä∏ Ï°∞Ìöå
 */

export function useGetMyFoldersDeprecate<TData = Awaited<ReturnType<typeof getMyFoldersDeprecate>>, TError = unknown>(
  params?: GetMyFoldersDeprecateParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyFoldersDeprecate>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetMyFoldersDeprecateQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÇ¨Ïö©ÏûêÏùò ÌîÑÎ°úÌïÑ idÎ°ú Î™®Î∞îÏùº ÏóÖÎ°úÎìú Ìè¥ÎçîÎ•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary (ÎÇ¥Î∂ÄÏö©)ÎÇ¥ Ìè¥ÎçîÏùò Î™®Î∞îÏùº ÏóÖÎ°úÎìú Ìè¥Îçî Ï°∞Ìöå
 */
export const getMyMobileUploadFolder = (options?: SecondParameter<typeof customFetcher>, signal?: AbortSignal) => {
  return customFetcher<ApiResponseSmartFolderResult>(
    { url: `/file/v1/my-folder/internal/mobile-upload-folder`, method: 'GET', signal },
    options,
  );
};

export const getGetMyMobileUploadFolderQueryKey = () => {
  return [`/file/v1/my-folder/internal/mobile-upload-folder`] as const;
};

export const getGetMyMobileUploadFolderQueryOptions = <
  TData = Awaited<ReturnType<typeof getMyMobileUploadFolder>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyMobileUploadFolder>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMyMobileUploadFolderQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyMobileUploadFolder>>> = ({ signal }) =>
    getMyMobileUploadFolder(requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMyMobileUploadFolder>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetMyMobileUploadFolderQueryResult = NonNullable<Awaited<ReturnType<typeof getMyMobileUploadFolder>>>;
export type GetMyMobileUploadFolderQueryError = unknown;

export function useGetMyMobileUploadFolder<
  TData = Awaited<ReturnType<typeof getMyMobileUploadFolder>>,
  TError = unknown,
>(options: {
  query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyMobileUploadFolder>>, TError, TData>> &
    Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getMyMobileUploadFolder>>, TError, TData>, 'initialData'>;
  request?: SecondParameter<typeof customFetcher>;
}): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetMyMobileUploadFolder<
  TData = Awaited<ReturnType<typeof getMyMobileUploadFolder>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyMobileUploadFolder>>, TError, TData>> &
    Pick<
      UndefinedInitialDataOptions<Awaited<ReturnType<typeof getMyMobileUploadFolder>>, TError, TData>,
      'initialData'
    >;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetMyMobileUploadFolder<
  TData = Awaited<ReturnType<typeof getMyMobileUploadFolder>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyMobileUploadFolder>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary (ÎÇ¥Î∂ÄÏö©)ÎÇ¥ Ìè¥ÎçîÏùò Î™®Î∞îÏùº ÏóÖÎ°úÎìú Ìè¥Îçî Ï°∞Ìöå
 */

export function useGetMyMobileUploadFolder<
  TData = Awaited<ReturnType<typeof getMyMobileUploadFolder>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyMobileUploadFolder>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetMyMobileUploadFolderQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÇ¨Ïö©ÏûêÏùò ÌîÑÎ°úÌïÑ idÎ°ú ÎÇ¥ Ìè¥Îçî Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.(ÏûêÎ£åÎ≥¥Îìú Î©îÏù∏ÌôîÎ©¥, ÏóÖÎ°úÎìúÏ∞ΩÏóêÏÑú ÎÇ¥ Ìè¥Îçî ÌÉ≠ Îì±ÏóêÏÑú ÏÇ¨Ïö©ÌïòÏãúÎ©¥ Îê† Í≤ÉÏúºÎ°ú ÏòàÏÉÅÎê©ÎãàÎã§.)
 * @summary ÏÇ¨Ïö©ÏûêÏùò ÌôàÏóêÏÑú Î≥¥Ïó¨Ï§Ñ ÎÇ¥ Ìè¥Îçî Î¶¨Ïä§Ìä∏ Ï°∞Ìöå
 */
export const getMyFolders = (options?: SecondParameter<typeof customFetcher>, signal?: AbortSignal) => {
  return customFetcher<ApiResponseListSmartFolderResult>(
    { url: `/file/v1/my-folder/home-folder-list`, method: 'GET', signal },
    options,
  );
};

export const getGetMyFoldersQueryKey = () => {
  return [`/file/v1/my-folder/home-folder-list`] as const;
};

export const getGetMyFoldersQueryOptions = <
  TData = Awaited<ReturnType<typeof getMyFolders>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyFolders>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMyFoldersQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyFolders>>> = ({ signal }) =>
    getMyFolders(requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMyFolders>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetMyFoldersQueryResult = NonNullable<Awaited<ReturnType<typeof getMyFolders>>>;
export type GetMyFoldersQueryError = unknown;

export function useGetMyFolders<TData = Awaited<ReturnType<typeof getMyFolders>>, TError = unknown>(options: {
  query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyFolders>>, TError, TData>> &
    Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getMyFolders>>, TError, TData>, 'initialData'>;
  request?: SecondParameter<typeof customFetcher>;
}): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetMyFolders<TData = Awaited<ReturnType<typeof getMyFolders>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyFolders>>, TError, TData>> &
    Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getMyFolders>>, TError, TData>, 'initialData'>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetMyFolders<TData = Awaited<ReturnType<typeof getMyFolders>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyFolders>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÏÇ¨Ïö©ÏûêÏùò ÌôàÏóêÏÑú Î≥¥Ïó¨Ï§Ñ ÎÇ¥ Ìè¥Îçî Î¶¨Ïä§Ìä∏ Ï°∞Ìöå
 */

export function useGetMyFolders<TData = Awaited<ReturnType<typeof getMyFolders>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyFolders>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetMyFoldersQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÇ¨Ïö©ÏûêÏùò ÌîÑÎ°úÌïÑ idÎ°ú Ìè¥ÎçîÍµ¨Ï°∞Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÏÇ¨Ïö©ÏûêÏùò ÎÇ¥ Ìè¥Îçî Íµ¨Ï°∞ Ï°∞Ìöå
 */
export const scanMyFolders = (
  params?: ScanMyFoldersParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderTreeResult>(
    { url: `/file/v1/my-folder/folder-tree`, method: 'GET', params, signal },
    options,
  );
};

export const getScanMyFoldersQueryKey = (params?: ScanMyFoldersParams) => {
  return [`/file/v1/my-folder/folder-tree`, ...(params ? [params] : [])] as const;
};

export const getScanMyFoldersQueryOptions = <TData = Awaited<ReturnType<typeof scanMyFolders>>, TError = unknown>(
  params?: ScanMyFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof scanMyFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getScanMyFoldersQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof scanMyFolders>>> = ({ signal }) =>
    scanMyFolders(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof scanMyFolders>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type ScanMyFoldersQueryResult = NonNullable<Awaited<ReturnType<typeof scanMyFolders>>>;
export type ScanMyFoldersQueryError = unknown;

export function useScanMyFolders<TData = Awaited<ReturnType<typeof scanMyFolders>>, TError = unknown>(
  params: undefined | ScanMyFoldersParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof scanMyFolders>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof scanMyFolders>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useScanMyFolders<TData = Awaited<ReturnType<typeof scanMyFolders>>, TError = unknown>(
  params?: ScanMyFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof scanMyFolders>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof scanMyFolders>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useScanMyFolders<TData = Awaited<ReturnType<typeof scanMyFolders>>, TError = unknown>(
  params?: ScanMyFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof scanMyFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÏÇ¨Ïö©ÏûêÏùò ÎÇ¥ Ìè¥Îçî Íµ¨Ï°∞ Ï°∞Ìöå
 */

export function useScanMyFolders<TData = Awaited<ReturnType<typeof scanMyFolders>>, TError = unknown>(
  params?: ScanMyFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof scanMyFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getScanMyFoldersQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÇ¨Ïö©ÏûêÏùò ÌîÑÎ°úÌïÑ idÎ°ú ÎÇ¥ Ìè¥Îçî Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÏÇ¨Ïö©ÏûêÏùò ÎÇ¥ Ìè¥Îçî Î¶¨Ïä§Ìä∏ Ï°∞Ìöå
 */
export const getMyFolders1 = (
  params?: GetMyFolders1Params,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderResult>(
    { url: `/file/v1/my-folder/folder-list`, method: 'GET', params, signal },
    options,
  );
};

export const getGetMyFolders1QueryKey = (params?: GetMyFolders1Params) => {
  return [`/file/v1/my-folder/folder-list`, ...(params ? [params] : [])] as const;
};

export const getGetMyFolders1QueryOptions = <TData = Awaited<ReturnType<typeof getMyFolders1>>, TError = unknown>(
  params?: GetMyFolders1Params,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyFolders1>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMyFolders1QueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyFolders1>>> = ({ signal }) =>
    getMyFolders1(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMyFolders1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetMyFolders1QueryResult = NonNullable<Awaited<ReturnType<typeof getMyFolders1>>>;
export type GetMyFolders1QueryError = unknown;

export function useGetMyFolders1<TData = Awaited<ReturnType<typeof getMyFolders1>>, TError = unknown>(
  params: undefined | GetMyFolders1Params,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyFolders1>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getMyFolders1>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetMyFolders1<TData = Awaited<ReturnType<typeof getMyFolders1>>, TError = unknown>(
  params?: GetMyFolders1Params,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyFolders1>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getMyFolders1>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetMyFolders1<TData = Awaited<ReturnType<typeof getMyFolders1>>, TError = unknown>(
  params?: GetMyFolders1Params,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyFolders1>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÏÇ¨Ïö©ÏûêÏùò ÎÇ¥ Ìè¥Îçî Î¶¨Ïä§Ìä∏ Ï°∞Ìöå
 */

export function useGetMyFolders1<TData = Awaited<ReturnType<typeof getMyFolders1>>, TError = unknown>(
  params?: GetMyFolders1Params,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyFolders1>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetMyFolders1QueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÌÇ§ÏõåÎìúÎ°ú ÎßàÏù¥Î≥¥ÎìúÎÇ¥Ïùò ÏûêÎ£åÎ•º Í≤ÄÏÉâÌï©ÎãàÎã§.
 * @summary ÎßàÏù¥Î≥¥ÎìúÏóêÏÑú ÏûêÎ£å Í≤ÄÏÉâ
 */
export const searchMyBoardData = (
  profileId: string,
  params: SearchMyBoardDataParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/file/v1/my-board/${profileId}/search`, method: 'GET', params, signal },
    options,
  );
};

export const getSearchMyBoardDataQueryKey = (profileId: string, params: SearchMyBoardDataParams) => {
  return [`/file/v1/my-board/${profileId}/search`, ...(params ? [params] : [])] as const;
};

export const getSearchMyBoardDataQueryOptions = <
  TData = Awaited<ReturnType<typeof searchMyBoardData>>,
  TError = unknown,
>(
  profileId: string,
  params: SearchMyBoardDataParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchMyBoardData>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSearchMyBoardDataQueryKey(profileId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof searchMyBoardData>>> = ({ signal }) =>
    searchMyBoardData(profileId, params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof searchMyBoardData>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type SearchMyBoardDataQueryResult = NonNullable<Awaited<ReturnType<typeof searchMyBoardData>>>;
export type SearchMyBoardDataQueryError = unknown;

export function useSearchMyBoardData<TData = Awaited<ReturnType<typeof searchMyBoardData>>, TError = unknown>(
  profileId: string,
  params: SearchMyBoardDataParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchMyBoardData>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof searchMyBoardData>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useSearchMyBoardData<TData = Awaited<ReturnType<typeof searchMyBoardData>>, TError = unknown>(
  profileId: string,
  params: SearchMyBoardDataParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchMyBoardData>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof searchMyBoardData>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useSearchMyBoardData<TData = Awaited<ReturnType<typeof searchMyBoardData>>, TError = unknown>(
  profileId: string,
  params: SearchMyBoardDataParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchMyBoardData>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÎßàÏù¥Î≥¥ÎìúÏóêÏÑú ÏûêÎ£å Í≤ÄÏÉâ
 */

export function useSearchMyBoardData<TData = Awaited<ReturnType<typeof searchMyBoardData>>, TError = unknown>(
  profileId: string,
  params: SearchMyBoardDataParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchMyBoardData>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getSearchMyBoardDataQueryOptions(profileId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÎßàÏù¥Î≥¥ÎìúÏóêÏÑú ÌÉ≠ Î≥ÑÎ°ú Î≥¥Ïó¨Ï§Ñ ÏûêÎ£å Î¶¨Ïä§Ìä∏Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÎßàÏù¥Î≥¥ÎìúÏóêÏÑú ÌÉ≠ÏóêÎî∞Îùº Î≥¥Ïó¨Ï§Ñ ÏûêÎ£å Î¶¨Ïä§Ìä∏Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 */
export const getMyBoardItems = (
  profileId: string,
  params: GetMyBoardItemsParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/file/v1/my-board/${profileId}/list`, method: 'GET', params, signal },
    options,
  );
};

export const getGetMyBoardItemsQueryKey = (profileId: string, params: GetMyBoardItemsParams) => {
  return [`/file/v1/my-board/${profileId}/list`, ...(params ? [params] : [])] as const;
};

export const getGetMyBoardItemsQueryOptions = <TData = Awaited<ReturnType<typeof getMyBoardItems>>, TError = unknown>(
  profileId: string,
  params: GetMyBoardItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyBoardItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMyBoardItemsQueryKey(profileId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyBoardItems>>> = ({ signal }) =>
    getMyBoardItems(profileId, params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMyBoardItems>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetMyBoardItemsQueryResult = NonNullable<Awaited<ReturnType<typeof getMyBoardItems>>>;
export type GetMyBoardItemsQueryError = unknown;

export function useGetMyBoardItems<TData = Awaited<ReturnType<typeof getMyBoardItems>>, TError = unknown>(
  profileId: string,
  params: GetMyBoardItemsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyBoardItems>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getMyBoardItems>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetMyBoardItems<TData = Awaited<ReturnType<typeof getMyBoardItems>>, TError = unknown>(
  profileId: string,
  params: GetMyBoardItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyBoardItems>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getMyBoardItems>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetMyBoardItems<TData = Awaited<ReturnType<typeof getMyBoardItems>>, TError = unknown>(
  profileId: string,
  params: GetMyBoardItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyBoardItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÎßàÏù¥Î≥¥ÎìúÏóêÏÑú ÌÉ≠ÏóêÎî∞Îùº Î≥¥Ïó¨Ï§Ñ ÏûêÎ£å Î¶¨Ïä§Ìä∏Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useGetMyBoardItems<TData = Awaited<ReturnType<typeof getMyBoardItems>>, TError = unknown>(
  profileId: string,
  params: GetMyBoardItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyBoardItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetMyBoardItemsQueryOptions(profileId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÎßàÏù¥Î≥¥ÎìúÏóêÏÑú Î≥¥Ïó¨Ï§Ñ Í≤åÏãúÍ∏Ä ÏàòÏôÄ Î∑∞ ÏàòÎ•º Ï≤¥ÌÅ¨Ìï©ÎãàÎã§.ÎÇòÏùò ÏûêÎ£åÎäî all countÎ•º ÎÇ®Ïùò ÏûêÎ£åÎäî public countÎ•º Î≥¥Ïó¨Ï£ºÎäîÍ≤å ÎßûÏùÑ Í≤É Í∞ôÏùÄÎç∞, ÏùºÎã® Í≥µÍ∞úÎêú ÏûêÎ£åÍ∏∞Ï§ÄÏúºÎ°ú public Ïπ¥Ïö¥Ìä∏Î°ú ÌëúÏãúÌï¥ÎëêÎäîÍ≤å ÎÇ† Í≤É Í∞ôÏäµÎãàÎã§(myBoardPublicItemCount, myBoardPublicViewCount).
 * @summary ÌîÑÎ°úÌïÑÏùò Í≤åÏãúÍ∏Ä Ïàò, Î∑∞ Ïàò Ï°∞Ìöå
 */
export const getCounts = (profileId: string, options?: SecondParameter<typeof customFetcher>, signal?: AbortSignal) => {
  return customFetcher<ApiResponseMyBoardCountsResult>(
    { url: `/file/v1/my-board/${profileId}/counts`, method: 'GET', signal },
    options,
  );
};

export const getGetCountsQueryKey = (profileId: string) => {
  return [`/file/v1/my-board/${profileId}/counts`] as const;
};

export const getGetCountsQueryOptions = <TData = Awaited<ReturnType<typeof getCounts>>, TError = unknown>(
  profileId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCounts>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCountsQueryKey(profileId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCounts>>> = ({ signal }) =>
    getCounts(profileId, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getCounts>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetCountsQueryResult = NonNullable<Awaited<ReturnType<typeof getCounts>>>;
export type GetCountsQueryError = unknown;

export function useGetCounts<TData = Awaited<ReturnType<typeof getCounts>>, TError = unknown>(
  profileId: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCounts>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getCounts>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetCounts<TData = Awaited<ReturnType<typeof getCounts>>, TError = unknown>(
  profileId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCounts>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getCounts>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetCounts<TData = Awaited<ReturnType<typeof getCounts>>, TError = unknown>(
  profileId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCounts>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÌîÑÎ°úÌïÑÏùò Í≤åÏãúÍ∏Ä Ïàò, Î∑∞ Ïàò Ï°∞Ìöå
 */

export function useGetCounts<TData = Awaited<ReturnType<typeof getCounts>>, TError = unknown>(
  profileId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCounts>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetCountsQueryOptions(profileId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÎÜÄÏù¥Î≥¥Í≥†ÏÑúÎ•º idÎ°ú Ï°∞Ìöå Ìï©ÎãàÎã§.
 * @summary ÎÜÄÏù¥Î≥¥Í≥†ÏÑú Ï°∞Ìöå
 */
export const getLectureReport = (
  id: number,
  params?: GetLectureReportParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseLectureReportResult>(
    { url: `/file/v1/lecture-report/${id}`, method: 'GET', params, signal },
    options,
  );
};

export const getGetLectureReportQueryKey = (id: number, params?: GetLectureReportParams) => {
  return [`/file/v1/lecture-report/${id}`, ...(params ? [params] : [])] as const;
};

export const getGetLectureReportQueryOptions = <TData = Awaited<ReturnType<typeof getLectureReport>>, TError = unknown>(
  id: number,
  params?: GetLectureReportParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLectureReport>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetLectureReportQueryKey(id, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLectureReport>>> = ({ signal }) =>
    getLectureReport(id, params, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!id, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getLectureReport>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetLectureReportQueryResult = NonNullable<Awaited<ReturnType<typeof getLectureReport>>>;
export type GetLectureReportQueryError = unknown;

export function useGetLectureReport<TData = Awaited<ReturnType<typeof getLectureReport>>, TError = unknown>(
  id: number,
  params: undefined | GetLectureReportParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLectureReport>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getLectureReport>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetLectureReport<TData = Awaited<ReturnType<typeof getLectureReport>>, TError = unknown>(
  id: number,
  params?: GetLectureReportParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLectureReport>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getLectureReport>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetLectureReport<TData = Awaited<ReturnType<typeof getLectureReport>>, TError = unknown>(
  id: number,
  params?: GetLectureReportParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLectureReport>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÎÜÄÏù¥Î≥¥Í≥†ÏÑú Ï°∞Ìöå
 */

export function useGetLectureReport<TData = Awaited<ReturnType<typeof getLectureReport>>, TError = unknown>(
  id: number,
  params?: GetLectureReportParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLectureReport>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetLectureReportQueryOptions(id, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Í∏∞Í∞ÑÏóê Îî∞ÎùºÏÑú Î™®Î∞îÏùºÏóÖÎ°úÎìú, Ïö∞Î¶¨Î∞òÏÇ¨ÏßÑ Îì±ÏóêÏÑú ÏûêÎ£åÎ•º Í≤ÄÏÉâÌï©ÎãàÎã§.
 * @summary ÌôúÎèô Í∏∞Í∞ÑÏóê Îî∞Î•∏ ÏÇ¨ÏßÑ Ï°∞Ìöå
 */
export const getPhotosForReport = (
  profileId: string,
  params: GetPhotosForReportParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/file/v1/lecture-report/photos-for-report/${profileId}`, method: 'GET', params, signal },
    options,
  );
};

export const getGetPhotosForReportQueryKey = (profileId: string, params: GetPhotosForReportParams) => {
  return [`/file/v1/lecture-report/photos-for-report/${profileId}`, ...(params ? [params] : [])] as const;
};

export const getGetPhotosForReportQueryOptions = <
  TData = Awaited<ReturnType<typeof getPhotosForReport>>,
  TError = unknown,
>(
  profileId: string,
  params: GetPhotosForReportParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotosForReport>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPhotosForReportQueryKey(profileId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPhotosForReport>>> = ({ signal }) =>
    getPhotosForReport(profileId, params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPhotosForReport>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetPhotosForReportQueryResult = NonNullable<Awaited<ReturnType<typeof getPhotosForReport>>>;
export type GetPhotosForReportQueryError = unknown;

export function useGetPhotosForReport<TData = Awaited<ReturnType<typeof getPhotosForReport>>, TError = unknown>(
  profileId: string,
  params: GetPhotosForReportParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotosForReport>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getPhotosForReport>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetPhotosForReport<TData = Awaited<ReturnType<typeof getPhotosForReport>>, TError = unknown>(
  profileId: string,
  params: GetPhotosForReportParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotosForReport>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getPhotosForReport>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetPhotosForReport<TData = Awaited<ReturnType<typeof getPhotosForReport>>, TError = unknown>(
  profileId: string,
  params: GetPhotosForReportParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotosForReport>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÌôúÎèô Í∏∞Í∞ÑÏóê Îî∞Î•∏ ÏÇ¨ÏßÑ Ï°∞Ìöå
 */

export function useGetPhotosForReport<TData = Awaited<ReturnType<typeof getPhotosForReport>>, TError = unknown>(
  profileId: string,
  params: GetPhotosForReportParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhotosForReport>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetPhotosForReportQueryOptions(profileId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÎÜÄÏù¥Í≥ÑÌöçÏùÑ idÎ°ú Ï°∞Ìöå Ìï©ÎãàÎã§.
 * @summary ÎÜÄÏù¥Í≥ÑÌöç Ï°∞Ìöå
 */
export const getLecturePlan = (
  lecturePlanId: number,
  params?: GetLecturePlanParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseLecturePlanResult>(
    { url: `/file/v1/lecture-plan/${lecturePlanId}`, method: 'GET', params, signal },
    options,
  );
};

export const getGetLecturePlanQueryKey = (lecturePlanId: number, params?: GetLecturePlanParams) => {
  return [`/file/v1/lecture-plan/${lecturePlanId}`, ...(params ? [params] : [])] as const;
};

export const getGetLecturePlanQueryOptions = <TData = Awaited<ReturnType<typeof getLecturePlan>>, TError = unknown>(
  lecturePlanId: number,
  params?: GetLecturePlanParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlan>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetLecturePlanQueryKey(lecturePlanId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLecturePlan>>> = ({ signal }) =>
    getLecturePlan(lecturePlanId, params, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!lecturePlanId, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getLecturePlan>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetLecturePlanQueryResult = NonNullable<Awaited<ReturnType<typeof getLecturePlan>>>;
export type GetLecturePlanQueryError = unknown;

export function useGetLecturePlan<TData = Awaited<ReturnType<typeof getLecturePlan>>, TError = unknown>(
  lecturePlanId: number,
  params: undefined | GetLecturePlanParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlan>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getLecturePlan>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetLecturePlan<TData = Awaited<ReturnType<typeof getLecturePlan>>, TError = unknown>(
  lecturePlanId: number,
  params?: GetLecturePlanParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlan>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getLecturePlan>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetLecturePlan<TData = Awaited<ReturnType<typeof getLecturePlan>>, TError = unknown>(
  lecturePlanId: number,
  params?: GetLecturePlanParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlan>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÎÜÄÏù¥Í≥ÑÌöç Ï°∞Ìöå
 */

export function useGetLecturePlan<TData = Awaited<ReturnType<typeof getLecturePlan>>, TError = unknown>(
  lecturePlanId: number,
  params?: GetLecturePlanParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlan>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetLecturePlanQueryOptions(lecturePlanId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÎãπÏùº Í∏∞Ï§ÄÏúºÎ°ú ÎÜÄÏù¥Í≥ÑÌöçÏïàÏóê Î®ºÏ†Ä ÎÑ£Ïñ¥Ï§Ñ Í∏∞Í∞ÑÏùÑ Í≥ÑÏÇ∞Ìï©ÎãàÎã§.ÏãúÏûëÏùº: ÎÜÄÏù¥ Í≥ÑÌöçÏùÑ ÏÉùÏÑ± ÏãúÏûëÌïú ÏùºÏûêÏùò Îã§Ïùå ÎÇ† (Ï£ºÎßêÏù¥Î©¥ ÏùºÎã® ÏõîÏöîÏùºÎ°ú)
Ï¢ÖÎ£åÏùº: 60Î∂Ñ ÎØ∏ÎßåÏùÄ ÏãúÏûëÏùºÍ≥º ÎèôÏùº, 1Ïùº, 3Ïùº, 5Ïùº, 2Ï£º, 3Ï£º, 4Ï£ºÎäî ÏãúÏûëÏùºÏóê Í≥ÑÏÇ∞ÌïòÏó¨ Ï†ÅÏö© 
Ïó∞Î†πÏù¥ÎÇò ÏÇ¨Ïö©ÏûêÏùò Ï†ïÎ≥¥ÎèÑ Î∞õÏïÑÏÑú, Ï∂îÌõÑ Ïù¥ ÏÇ¨ÎûåÏù¥ Ï£ºÎ°ú Í∏∞ÌöçÌïòÎäî Ï£ºÍ∏∞Î•º ÏòàÏ∏°ÌïòÏó¨ ÏùëÎãµÌïòÍ∏∞Ìï† Ïàò ÏûàÏùÑ Í≤É Í∞ôÏäµÎãàÎã§.
 * @summary ÎÜÄÏù¥Í≥ÑÌöçÏóêÏÑú Î®ºÏ†Ä ÏÑ§Ï†ïÌï¥Ï§Ñ Í∏∞Í∞ÑÏùÑ Ï°∞Ìöå
 */
export const getTerm = (
  params: GetTermParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseLecturePlanTermResult>(
    { url: `/file/v1/lecture-plan/term`, method: 'GET', params, signal },
    options,
  );
};

export const getGetTermQueryKey = (params: GetTermParams) => {
  return [`/file/v1/lecture-plan/term`, ...(params ? [params] : [])] as const;
};

export const getGetTermQueryOptions = <TData = Awaited<ReturnType<typeof getTerm>>, TError = unknown>(
  params: GetTermParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTerm>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTermQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTerm>>> = ({ signal }) =>
    getTerm(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getTerm>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetTermQueryResult = NonNullable<Awaited<ReturnType<typeof getTerm>>>;
export type GetTermQueryError = unknown;

export function useGetTerm<TData = Awaited<ReturnType<typeof getTerm>>, TError = unknown>(
  params: GetTermParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTerm>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getTerm>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetTerm<TData = Awaited<ReturnType<typeof getTerm>>, TError = unknown>(
  params: GetTermParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTerm>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getTerm>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetTerm<TData = Awaited<ReturnType<typeof getTerm>>, TError = unknown>(
  params: GetTermParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTerm>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÎÜÄÏù¥Í≥ÑÌöçÏóêÏÑú Î®ºÏ†Ä ÏÑ§Ï†ïÌï¥Ï§Ñ Í∏∞Í∞ÑÏùÑ Ï°∞Ìöå
 */

export function useGetTerm<TData = Awaited<ReturnType<typeof getTerm>>, TError = unknown>(
  params: GetTermParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTerm>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetTermQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÇ¨Ïö©ÏûêÏùò ÌîÑÎ°úÌïÑ idÎ°ú ÎÜÄÏù¥Í≥ÑÌöçÎ™©Î°ùÏùÑ Ï°∞Ìöå Ìï©ÎãàÎã§.
 * @summary ÏÇ¨Ïö©Ïûê ÌîÑÎ°úÌïÑ idÎ°ú ÎÜÄÏù¥Í≥ÑÌöç Î™©Î°ù Ï°∞Ìöå
 */
export const getLecturePlanList = (
  params?: GetLecturePlanListParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListLecturePlanResult>(
    { url: `/file/v1/lecture-plan/list`, method: 'GET', params, signal },
    options,
  );
};

export const getGetLecturePlanListQueryKey = (params?: GetLecturePlanListParams) => {
  return [`/file/v1/lecture-plan/list`, ...(params ? [params] : [])] as const;
};

export const getGetLecturePlanListQueryOptions = <
  TData = Awaited<ReturnType<typeof getLecturePlanList>>,
  TError = unknown,
>(
  params?: GetLecturePlanListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlanList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetLecturePlanListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLecturePlanList>>> = ({ signal }) =>
    getLecturePlanList(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getLecturePlanList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetLecturePlanListQueryResult = NonNullable<Awaited<ReturnType<typeof getLecturePlanList>>>;
export type GetLecturePlanListQueryError = unknown;

export function useGetLecturePlanList<TData = Awaited<ReturnType<typeof getLecturePlanList>>, TError = unknown>(
  params: undefined | GetLecturePlanListParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlanList>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getLecturePlanList>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetLecturePlanList<TData = Awaited<ReturnType<typeof getLecturePlanList>>, TError = unknown>(
  params?: GetLecturePlanListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlanList>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getLecturePlanList>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetLecturePlanList<TData = Awaited<ReturnType<typeof getLecturePlanList>>, TError = unknown>(
  params?: GetLecturePlanListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlanList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÏÇ¨Ïö©Ïûê ÌîÑÎ°úÌïÑ idÎ°ú ÎÜÄÏù¥Í≥ÑÌöç Î™©Î°ù Ï°∞Ìöå
 */

export function useGetLecturePlanList<TData = Awaited<ReturnType<typeof getLecturePlanList>>, TError = unknown>(
  params?: GetLecturePlanListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlanList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetLecturePlanListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÇ¨Ïö©ÏûêÏùò ÌîÑÎ°úÌïÑ idÎ°ú ÎÜÄÏù¥Í≥ÑÌöçÎ™©Î°ùÏùÑ Ï°∞Ìöå Ìï©ÎãàÎã§. Í≤ÄÏÉâÏñ¥Í∞Ä nullÏù¥ÎÇò Îπà Î¨∏ÏûêÏó¥Ïù¥Î©¥ Í∑∏ÎÉ• Ìï¥Îãπ ÏÇ¨Ïö©ÏûêÏùò ÎÜÄÏù¥Í≥ÑÌöçÏïàÏùÑ Î∂àÎü¨ÏòµÎãàÎã§.
 * @summary ÏÇ¨Ïö©Ïûê ÌîÑÎ°úÌïÑ idÎ°ú ÎÜÄÏù¥Í≥ÑÌöç Î™©Î°ù Ï°∞Ìöå(Í≤ÄÏÉâ Ï∂îÍ∞Ä)
 */
export const getLecturePlanListWithSearch = (
  params?: GetLecturePlanListWithSearchParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListLecturePlanResult>(
    { url: `/file/v1/lecture-plan/list-with-search`, method: 'GET', params, signal },
    options,
  );
};

export const getGetLecturePlanListWithSearchQueryKey = (params?: GetLecturePlanListWithSearchParams) => {
  return [`/file/v1/lecture-plan/list-with-search`, ...(params ? [params] : [])] as const;
};

export const getGetLecturePlanListWithSearchQueryOptions = <
  TData = Awaited<ReturnType<typeof getLecturePlanListWithSearch>>,
  TError = unknown,
>(
  params?: GetLecturePlanListWithSearchParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlanListWithSearch>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetLecturePlanListWithSearchQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLecturePlanListWithSearch>>> = ({ signal }) =>
    getLecturePlanListWithSearch(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getLecturePlanListWithSearch>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetLecturePlanListWithSearchQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLecturePlanListWithSearch>>
>;
export type GetLecturePlanListWithSearchQueryError = unknown;

export function useGetLecturePlanListWithSearch<
  TData = Awaited<ReturnType<typeof getLecturePlanListWithSearch>>,
  TError = unknown,
>(
  params: undefined | GetLecturePlanListWithSearchParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlanListWithSearch>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getLecturePlanListWithSearch>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetLecturePlanListWithSearch<
  TData = Awaited<ReturnType<typeof getLecturePlanListWithSearch>>,
  TError = unknown,
>(
  params?: GetLecturePlanListWithSearchParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlanListWithSearch>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getLecturePlanListWithSearch>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetLecturePlanListWithSearch<
  TData = Awaited<ReturnType<typeof getLecturePlanListWithSearch>>,
  TError = unknown,
>(
  params?: GetLecturePlanListWithSearchParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlanListWithSearch>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÏÇ¨Ïö©Ïûê ÌîÑÎ°úÌïÑ idÎ°ú ÎÜÄÏù¥Í≥ÑÌöç Î™©Î°ù Ï°∞Ìöå(Í≤ÄÏÉâ Ï∂îÍ∞Ä)
 */

export function useGetLecturePlanListWithSearch<
  TData = Awaited<ReturnType<typeof getLecturePlanListWithSearch>>,
  TError = unknown,
>(
  params?: GetLecturePlanListWithSearchParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlanListWithSearch>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetLecturePlanListWithSearchQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏûêÎ£åÏùò idÎÇò ÌÇ§ Í∞íÏúºÎ°ú ÏûêÎ£åÏùò Ï†ïÎ≥¥Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÏûêÎ£å Ï†ïÎ≥¥ Ï°∞Ìöå
 */
export const getByIdOrKey = (
  idOrKey: string,
  params: GetByIdOrKeyParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseDriveItemResult>(
    { url: `/file/v1/drive-items/${idOrKey}`, method: 'GET', params, signal },
    options,
  );
};

export const getGetByIdOrKeyQueryKey = (idOrKey: string, params: GetByIdOrKeyParams) => {
  return [`/file/v1/drive-items/${idOrKey}`, ...(params ? [params] : [])] as const;
};

export const getGetByIdOrKeyQueryOptions = <TData = Awaited<ReturnType<typeof getByIdOrKey>>, TError = unknown>(
  idOrKey: string,
  params: GetByIdOrKeyParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getByIdOrKey>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetByIdOrKeyQueryKey(idOrKey, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getByIdOrKey>>> = ({ signal }) =>
    getByIdOrKey(idOrKey, params, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!idOrKey, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getByIdOrKey>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetByIdOrKeyQueryResult = NonNullable<Awaited<ReturnType<typeof getByIdOrKey>>>;
export type GetByIdOrKeyQueryError = unknown;

export function useGetByIdOrKey<TData = Awaited<ReturnType<typeof getByIdOrKey>>, TError = unknown>(
  idOrKey: string,
  params: GetByIdOrKeyParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getByIdOrKey>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getByIdOrKey>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetByIdOrKey<TData = Awaited<ReturnType<typeof getByIdOrKey>>, TError = unknown>(
  idOrKey: string,
  params: GetByIdOrKeyParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getByIdOrKey>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getByIdOrKey>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetByIdOrKey<TData = Awaited<ReturnType<typeof getByIdOrKey>>, TError = unknown>(
  idOrKey: string,
  params: GetByIdOrKeyParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getByIdOrKey>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÏûêÎ£å Ï†ïÎ≥¥ Ï°∞Ìöå
 */

export function useGetByIdOrKey<TData = Awaited<ReturnType<typeof getByIdOrKey>>, TError = unknown>(
  idOrKey: string,
  params: GetByIdOrKeyParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getByIdOrKey>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetByIdOrKeyQueryOptions(idOrKey, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏûêÎ£åÏóê Îì±Î°ùÎêú ÏûêÏãù ÎåìÍ∏Ä Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÌïòÏúÑ ÎåìÍ∏Ä Ï°∞Ìöå
 */
export const getChildPagingReplies = (
  driveItemIdOrKey: string,
  parentId: string,
  params?: GetChildPagingRepliesParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListReplyResult>(
    { url: `/file/v1/drive-items/${driveItemIdOrKey}/replies/${parentId}`, method: 'GET', params, signal },
    options,
  );
};

export const getGetChildPagingRepliesQueryKey = (
  driveItemIdOrKey: string,
  parentId: string,
  params?: GetChildPagingRepliesParams,
) => {
  return [`/file/v1/drive-items/${driveItemIdOrKey}/replies/${parentId}`, ...(params ? [params] : [])] as const;
};

export const getGetChildPagingRepliesQueryOptions = <
  TData = Awaited<ReturnType<typeof getChildPagingReplies>>,
  TError = unknown,
>(
  driveItemIdOrKey: string,
  parentId: string,
  params?: GetChildPagingRepliesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getChildPagingReplies>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetChildPagingRepliesQueryKey(driveItemIdOrKey, parentId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getChildPagingReplies>>> = ({ signal }) =>
    getChildPagingReplies(driveItemIdOrKey, parentId, params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(driveItemIdOrKey && parentId),
    staleTime: 60000,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getChildPagingReplies>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData>;
  };
};

export type GetChildPagingRepliesQueryResult = NonNullable<Awaited<ReturnType<typeof getChildPagingReplies>>>;
export type GetChildPagingRepliesQueryError = unknown;

export function useGetChildPagingReplies<TData = Awaited<ReturnType<typeof getChildPagingReplies>>, TError = unknown>(
  driveItemIdOrKey: string,
  parentId: string,
  params: undefined | GetChildPagingRepliesParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getChildPagingReplies>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getChildPagingReplies>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetChildPagingReplies<TData = Awaited<ReturnType<typeof getChildPagingReplies>>, TError = unknown>(
  driveItemIdOrKey: string,
  parentId: string,
  params?: GetChildPagingRepliesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getChildPagingReplies>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getChildPagingReplies>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetChildPagingReplies<TData = Awaited<ReturnType<typeof getChildPagingReplies>>, TError = unknown>(
  driveItemIdOrKey: string,
  parentId: string,
  params?: GetChildPagingRepliesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getChildPagingReplies>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÌïòÏúÑ ÎåìÍ∏Ä Ï°∞Ìöå
 */

export function useGetChildPagingReplies<TData = Awaited<ReturnType<typeof getChildPagingReplies>>, TError = unknown>(
  driveItemIdOrKey: string,
  parentId: string,
  params?: GetChildPagingRepliesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getChildPagingReplies>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetChildPagingRepliesQueryOptions(driveItemIdOrKey, parentId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const searchKeywordAnalize = (
  params: SearchKeywordAnalizeParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListString>(
    { url: `/file/v1/drive-items/test/keyword-analyze`, method: 'GET', params, signal },
    options,
  );
};

export const getSearchKeywordAnalizeQueryKey = (params: SearchKeywordAnalizeParams) => {
  return [`/file/v1/drive-items/test/keyword-analyze`, ...(params ? [params] : [])] as const;
};

export const getSearchKeywordAnalizeQueryOptions = <
  TData = Awaited<ReturnType<typeof searchKeywordAnalize>>,
  TError = unknown,
>(
  params: SearchKeywordAnalizeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchKeywordAnalize>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSearchKeywordAnalizeQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof searchKeywordAnalize>>> = ({ signal }) =>
    searchKeywordAnalize(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof searchKeywordAnalize>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type SearchKeywordAnalizeQueryResult = NonNullable<Awaited<ReturnType<typeof searchKeywordAnalize>>>;
export type SearchKeywordAnalizeQueryError = unknown;

export function useSearchKeywordAnalize<TData = Awaited<ReturnType<typeof searchKeywordAnalize>>, TError = unknown>(
  params: SearchKeywordAnalizeParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchKeywordAnalize>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof searchKeywordAnalize>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useSearchKeywordAnalize<TData = Awaited<ReturnType<typeof searchKeywordAnalize>>, TError = unknown>(
  params: SearchKeywordAnalizeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchKeywordAnalize>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof searchKeywordAnalize>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useSearchKeywordAnalize<TData = Awaited<ReturnType<typeof searchKeywordAnalize>>, TError = unknown>(
  params: SearchKeywordAnalizeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchKeywordAnalize>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

export function useSearchKeywordAnalize<TData = Awaited<ReturnType<typeof searchKeywordAnalize>>, TError = unknown>(
  params: SearchKeywordAnalizeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchKeywordAnalize>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getSearchKeywordAnalizeQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const checkNotIndexedItems = (options?: SecondParameter<typeof customFetcher>, signal?: AbortSignal) => {
  return customFetcher<ApiResponseListDriveItemResult>(
    { url: `/file/v1/drive-items/test/check-not-indexed-items`, method: 'GET', signal },
    options,
  );
};

export const getCheckNotIndexedItemsQueryKey = () => {
  return [`/file/v1/drive-items/test/check-not-indexed-items`] as const;
};

export const getCheckNotIndexedItemsQueryOptions = <
  TData = Awaited<ReturnType<typeof checkNotIndexedItems>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof checkNotIndexedItems>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getCheckNotIndexedItemsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof checkNotIndexedItems>>> = ({ signal }) =>
    checkNotIndexedItems(requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof checkNotIndexedItems>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type CheckNotIndexedItemsQueryResult = NonNullable<Awaited<ReturnType<typeof checkNotIndexedItems>>>;
export type CheckNotIndexedItemsQueryError = unknown;

export function useCheckNotIndexedItems<
  TData = Awaited<ReturnType<typeof checkNotIndexedItems>>,
  TError = unknown,
>(options: {
  query: Partial<UseQueryOptions<Awaited<ReturnType<typeof checkNotIndexedItems>>, TError, TData>> &
    Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof checkNotIndexedItems>>, TError, TData>, 'initialData'>;
  request?: SecondParameter<typeof customFetcher>;
}): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useCheckNotIndexedItems<
  TData = Awaited<ReturnType<typeof checkNotIndexedItems>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof checkNotIndexedItems>>, TError, TData>> &
    Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof checkNotIndexedItems>>, TError, TData>, 'initialData'>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useCheckNotIndexedItems<
  TData = Awaited<ReturnType<typeof checkNotIndexedItems>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof checkNotIndexedItems>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

export function useCheckNotIndexedItems<
  TData = Awaited<ReturnType<typeof checkNotIndexedItems>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof checkNotIndexedItems>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getCheckNotIndexedItemsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const checkNotIndexedItems2 = (
  params: CheckNotIndexedItems2Params,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderDocumentItem>(
    { url: `/file/v1/drive-items/test/check-not-indexed-items-2`, method: 'GET', params, signal },
    options,
  );
};

export const getCheckNotIndexedItems2QueryKey = (params: CheckNotIndexedItems2Params) => {
  return [`/file/v1/drive-items/test/check-not-indexed-items-2`, ...(params ? [params] : [])] as const;
};

export const getCheckNotIndexedItems2QueryOptions = <
  TData = Awaited<ReturnType<typeof checkNotIndexedItems2>>,
  TError = unknown,
>(
  params: CheckNotIndexedItems2Params,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof checkNotIndexedItems2>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getCheckNotIndexedItems2QueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof checkNotIndexedItems2>>> = ({ signal }) =>
    checkNotIndexedItems2(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof checkNotIndexedItems2>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type CheckNotIndexedItems2QueryResult = NonNullable<Awaited<ReturnType<typeof checkNotIndexedItems2>>>;
export type CheckNotIndexedItems2QueryError = unknown;

export function useCheckNotIndexedItems2<TData = Awaited<ReturnType<typeof checkNotIndexedItems2>>, TError = unknown>(
  params: CheckNotIndexedItems2Params,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof checkNotIndexedItems2>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof checkNotIndexedItems2>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useCheckNotIndexedItems2<TData = Awaited<ReturnType<typeof checkNotIndexedItems2>>, TError = unknown>(
  params: CheckNotIndexedItems2Params,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof checkNotIndexedItems2>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof checkNotIndexedItems2>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useCheckNotIndexedItems2<TData = Awaited<ReturnType<typeof checkNotIndexedItems2>>, TError = unknown>(
  params: CheckNotIndexedItems2Params,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof checkNotIndexedItems2>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

export function useCheckNotIndexedItems2<TData = Awaited<ReturnType<typeof checkNotIndexedItems2>>, TError = unknown>(
  params: CheckNotIndexedItems2Params,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof checkNotIndexedItems2>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getCheckNotIndexedItems2QueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÎÇòÏù¥Î°ú Ïñ¥Îñ§ Í≥ºÏ†ïÏóê Ìï¥ÎãπÌïòÎäî ÏßÄÌôïÏù∏Ìï©ÎãàÎã§.
 * @summary ÎÇòÏù¥Î°ú Í≥ºÏ†ïÏ†ïÎ≥¥ ÌôïÏù∏
 */
export const getCourse = (
  params: GetCourseParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseCourseResult>({ url: `/file/v1/course`, method: 'GET', params, signal }, options);
};

export const getGetCourseQueryKey = (params: GetCourseParams) => {
  return [`/file/v1/course`, ...(params ? [params] : [])] as const;
};

export const getGetCourseQueryOptions = <TData = Awaited<ReturnType<typeof getCourse>>, TError = unknown>(
  params: GetCourseParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCourse>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCourseQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCourse>>> = ({ signal }) =>
    getCourse(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getCourse>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetCourseQueryResult = NonNullable<Awaited<ReturnType<typeof getCourse>>>;
export type GetCourseQueryError = unknown;

export function useGetCourse<TData = Awaited<ReturnType<typeof getCourse>>, TError = unknown>(
  params: GetCourseParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCourse>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getCourse>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetCourse<TData = Awaited<ReturnType<typeof getCourse>>, TError = unknown>(
  params: GetCourseParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCourse>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getCourse>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetCourse<TData = Awaited<ReturnType<typeof getCourse>>, TError = unknown>(
  params: GetCourseParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCourse>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÎÇòÏù¥Î°ú Í≥ºÏ†ïÏ†ïÎ≥¥ ÌôïÏù∏
 */

export function useGetCourse<TData = Awaited<ReturnType<typeof getCourse>>, TError = unknown>(
  params: GetCourseParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCourse>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetCourseQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Îì±Î°ùÎêòÏñ¥ÏûáÎäî Í≥ºÏ†ï Î¶¨Ïä§Ìä∏Î•º Ï°∞ÌöåÌï©ÎãàÎã§. 1Ï∞®Îäî Ïñ¥Î¶∞Ïù¥Ïßë, Ïú†ÏπòÏõê, Ï¥àÎì±ÌïôÍµêÎßå.
 * @summary Îì±Î°ùÎêú Í≥ºÏ†ï Î¶¨Ïä§Ìä∏ Ï°∞Ìöå
 */
export const getCourse1 = (options?: SecondParameter<typeof customFetcher>, signal?: AbortSignal) => {
  return customFetcher<ApiResponseListCourseResult>({ url: `/file/v1/course/list`, method: 'GET', signal }, options);
};

export const getGetCourse1QueryKey = () => {
  return [`/file/v1/course/list`] as const;
};

export const getGetCourse1QueryOptions = <TData = Awaited<ReturnType<typeof getCourse1>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCourse1>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCourse1QueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCourse1>>> = ({ signal }) =>
    getCourse1(requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getCourse1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetCourse1QueryResult = NonNullable<Awaited<ReturnType<typeof getCourse1>>>;
export type GetCourse1QueryError = unknown;

export function useGetCourse1<TData = Awaited<ReturnType<typeof getCourse1>>, TError = unknown>(options: {
  query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCourse1>>, TError, TData>> &
    Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getCourse1>>, TError, TData>, 'initialData'>;
  request?: SecondParameter<typeof customFetcher>;
}): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetCourse1<TData = Awaited<ReturnType<typeof getCourse1>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCourse1>>, TError, TData>> &
    Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getCourse1>>, TError, TData>, 'initialData'>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetCourse1<TData = Awaited<ReturnType<typeof getCourse1>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCourse1>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Îì±Î°ùÎêú Í≥ºÏ†ï Î¶¨Ïä§Ìä∏ Ï°∞Ìöå
 */

export function useGetCourse1<TData = Awaited<ReturnType<typeof getCourse1>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCourse1>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetCourse1QueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÌÇ§ÏõåÎìúÎ°ú ÏûêÏã†Ïùò ÏûêÎ£åÎ•º Í≤ÄÏÉâÌï©ÎãàÎã§.<br>ÌÇ§ÏõåÎìúÎ°ú Í≤ÄÏÉâ ÌõÑ ÏÇ≠Ï†úÎêú ÏûêÎ£åÎÇò Îã§Î•∏ ÌïÑÌÑ∞ÎßÅÏùÑ Í±∞ÏπòÍ∏∞ ÎïåÎ¨∏Ïóê<br>Ïó¨Í∏∞ÏÑúÎäî offsetSizeWithLimit Ïóê Îã§Î•∏ ÏûêÎ£åÏôÄ Îã§Î•¥Í≤å ÌéòÏù¥ÏßÄÏàòÍ∞Ä ÏïÑÎãå Ïù¥Ï†Ñ Ï°∞ÌöåÏóê ÏôîÎçò nextOffsetÎ•º ÎÑ£Ïñ¥Ï£ºÏÖîÏïºÌï©ÎãàÎã§.<br>ÏùëÎãµÏóê nextOffsetÍ≥º totalÏù¥ Í∞ôÏúºÎ©¥ ÎçîÏù¥ÏÉÅ Î°úÎìúÌï† Í≤ÉÏù¥ ÏóÜÎã§Îäî ÎúªÏûÖÎãàÎã§.
 * @summary ÎÇ¥ ÏûêÎ£å Í≤ÄÏÉâ
 */
export const searchMyData = (
  params: SearchMyDataParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseSearchListResultSmartFolderItemResult>(
    { url: `/file/v1/common-smart-folder/search`, method: 'GET', params, signal },
    options,
  );
};

export const getSearchMyDataQueryKey = (params: SearchMyDataParams) => {
  return [`/file/v1/common-smart-folder/search`, ...(params ? [params] : [])] as const;
};

export const getSearchMyDataQueryOptions = <TData = Awaited<ReturnType<typeof searchMyData>>, TError = unknown>(
  params: SearchMyDataParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchMyData>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSearchMyDataQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof searchMyData>>> = ({ signal }) =>
    searchMyData(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof searchMyData>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type SearchMyDataQueryResult = NonNullable<Awaited<ReturnType<typeof searchMyData>>>;
export type SearchMyDataQueryError = unknown;

export function useSearchMyData<TData = Awaited<ReturnType<typeof searchMyData>>, TError = unknown>(
  params: SearchMyDataParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchMyData>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof searchMyData>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useSearchMyData<TData = Awaited<ReturnType<typeof searchMyData>>, TError = unknown>(
  params: SearchMyDataParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchMyData>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof searchMyData>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useSearchMyData<TData = Awaited<ReturnType<typeof searchMyData>>, TError = unknown>(
  params: SearchMyDataParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchMyData>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÎÇ¥ ÏûêÎ£å Í≤ÄÏÉâ
 */

export function useSearchMyData<TData = Awaited<ReturnType<typeof searchMyData>>, TError = unknown>(
  params: SearchMyDataParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchMyData>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getSearchMyDataQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÌïôÏÉùÍ≥º Í¥ÄÎ†®Îêú ÏûêÎ£åÎ•º Í≤ÄÏÉâÌïòÎäî apiÏûÖÎãàÎã§. Í∏∞Î≥∏Ï†ÅÏúºÎ°ú Í¥ÄÏ∞∞Í∏∞Î°ù ÏûëÏÑ± ÌïòÎã®Ïóê ÏûêÎ£å Î¶¨Ïä§Ìä∏ÏóêÏÑú Ïù¥Í±∞ ÏÇ¨Ïö©Ìï¥Ï£ºÏÑ∏Ïöî.
 * @summary ÌïôÏÉùÍ≥º Í¥ÄÎ†®Îêú ÏûêÎ£å Í≤ÄÏÉâ
 */
export const searchStudentData = (
  params: SearchStudentDataParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/file/v1/common-smart-folder/search-student-item-list`, method: 'GET', params, signal },
    options,
  );
};

export const getSearchStudentDataQueryKey = (params: SearchStudentDataParams) => {
  return [`/file/v1/common-smart-folder/search-student-item-list`, ...(params ? [params] : [])] as const;
};

export const getSearchStudentDataQueryOptions = <
  TData = Awaited<ReturnType<typeof searchStudentData>>,
  TError = unknown,
>(
  params: SearchStudentDataParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchStudentData>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSearchStudentDataQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof searchStudentData>>> = ({ signal }) =>
    searchStudentData(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof searchStudentData>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type SearchStudentDataQueryResult = NonNullable<Awaited<ReturnType<typeof searchStudentData>>>;
export type SearchStudentDataQueryError = unknown;

export function useSearchStudentData<TData = Awaited<ReturnType<typeof searchStudentData>>, TError = unknown>(
  params: SearchStudentDataParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchStudentData>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof searchStudentData>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useSearchStudentData<TData = Awaited<ReturnType<typeof searchStudentData>>, TError = unknown>(
  params: SearchStudentDataParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchStudentData>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof searchStudentData>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useSearchStudentData<TData = Awaited<ReturnType<typeof searchStudentData>>, TError = unknown>(
  params: SearchStudentDataParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchStudentData>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÌïôÏÉùÍ≥º Í¥ÄÎ†®Îêú ÏûêÎ£å Í≤ÄÏÉâ
 */

export function useSearchStudentData<TData = Awaited<ReturnType<typeof searchStudentData>>, TError = unknown>(
  params: SearchStudentDataParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchStudentData>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getSearchStudentDataQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏûêÎ£å idÎ•º Ïù¥Ïö©Ìï¥ÏÑú ÏûêÎ£åÏùò Í≥µÍ∞ú ÏÉÅÌÉú Î∞è Í≥µÏú†ÏΩîÎìúÎ•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÏûêÎ£åÏùò Í≥µÍ∞ú ÏÉÅÌÉúÎ•º ÌôïÏù∏ÌïòÎäî api(Í≥µÍ∞úÍ¥ÄÎ¶¨ ÌåùÏóÖÏ∞Ω Ïó¥ Îïå Ìò∏Ï∂ú)
 */
export const getPublicUrlItemCode = (
  params: GetPublicUrlItemCodeParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponsePublicUrlItemCodeResult>(
    { url: `/file/v1/common-smart-folder/public-url-code`, method: 'GET', params, signal },
    options,
  );
};

export const getGetPublicUrlItemCodeQueryKey = (params: GetPublicUrlItemCodeParams) => {
  return [`/file/v1/common-smart-folder/public-url-code`, ...(params ? [params] : [])] as const;
};

export const getGetPublicUrlItemCodeQueryOptions = <
  TData = Awaited<ReturnType<typeof getPublicUrlItemCode>>,
  TError = unknown,
>(
  params: GetPublicUrlItemCodeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicUrlItemCode>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPublicUrlItemCodeQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPublicUrlItemCode>>> = ({ signal }) =>
    getPublicUrlItemCode(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPublicUrlItemCode>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetPublicUrlItemCodeQueryResult = NonNullable<Awaited<ReturnType<typeof getPublicUrlItemCode>>>;
export type GetPublicUrlItemCodeQueryError = unknown;

export function useGetPublicUrlItemCode<TData = Awaited<ReturnType<typeof getPublicUrlItemCode>>, TError = unknown>(
  params: GetPublicUrlItemCodeParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicUrlItemCode>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getPublicUrlItemCode>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetPublicUrlItemCode<TData = Awaited<ReturnType<typeof getPublicUrlItemCode>>, TError = unknown>(
  params: GetPublicUrlItemCodeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicUrlItemCode>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getPublicUrlItemCode>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetPublicUrlItemCode<TData = Awaited<ReturnType<typeof getPublicUrlItemCode>>, TError = unknown>(
  params: GetPublicUrlItemCodeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicUrlItemCode>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÏûêÎ£åÏùò Í≥µÍ∞ú ÏÉÅÌÉúÎ•º ÌôïÏù∏ÌïòÎäî api(Í≥µÍ∞úÍ¥ÄÎ¶¨ ÌåùÏóÖÏ∞Ω Ïó¥ Îïå Ìò∏Ï∂ú)
 */

export function useGetPublicUrlItemCode<TData = Awaited<ReturnType<typeof getPublicUrlItemCode>>, TError = unknown>(
  params: GetPublicUrlItemCodeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicUrlItemCode>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetPublicUrlItemCodeQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏûêÎ£åÎ≥¥ÎìúÏùò ÏûêÎ£å idÎ•º Ïù¥Ïö©Ìï¥ÏÑú ÏûêÎ£åÏùò Í≤ΩÎ°úÎ•º Ï°∞ÌöåÌï©ÎãàÎã§.(ÎπµÎøåÏãúÎûòÍ∏∞ ÌëúÏãúÏö©)
 * @summary ÌååÏùºÏùò Ìè¥Îçî Í≤ΩÎ°úÎ•º Ï°∞ÌöåÌïòÎäî api
 */
export const getItemPathTree = (
  params: GetItemPathTreeParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseSmartFolderTreeResult>(
    { url: `/file/v1/common-smart-folder/path-tree`, method: 'GET', params, signal },
    options,
  );
};

export const getGetItemPathTreeQueryKey = (params: GetItemPathTreeParams) => {
  return [`/file/v1/common-smart-folder/path-tree`, ...(params ? [params] : [])] as const;
};

export const getGetItemPathTreeQueryOptions = <TData = Awaited<ReturnType<typeof getItemPathTree>>, TError = unknown>(
  params: GetItemPathTreeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemPathTree>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetItemPathTreeQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemPathTree>>> = ({ signal }) =>
    getItemPathTree(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getItemPathTree>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetItemPathTreeQueryResult = NonNullable<Awaited<ReturnType<typeof getItemPathTree>>>;
export type GetItemPathTreeQueryError = unknown;

export function useGetItemPathTree<TData = Awaited<ReturnType<typeof getItemPathTree>>, TError = unknown>(
  params: GetItemPathTreeParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemPathTree>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getItemPathTree>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetItemPathTree<TData = Awaited<ReturnType<typeof getItemPathTree>>, TError = unknown>(
  params: GetItemPathTreeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemPathTree>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getItemPathTree>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetItemPathTree<TData = Awaited<ReturnType<typeof getItemPathTree>>, TError = unknown>(
  params: GetItemPathTreeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemPathTree>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÌååÏùºÏùò Ìè¥Îçî Í≤ΩÎ°úÎ•º Ï°∞ÌöåÌïòÎäî api
 */

export function useGetItemPathTree<TData = Awaited<ReturnType<typeof getItemPathTree>>, TError = unknown>(
  params: GetItemPathTreeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemPathTree>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetItemPathTreeQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏûêÎ£åÎ≥¥Îìú Î©îÏù∏ÌôîÎ©¥ SNBÏùò Í≥µÍ∞úÏûêÎ£åÎ•º Ï°∞ÌöåÌïòÎäî api ÏûÖÎãàÎã§.
 * @summary ÎÇòÏùò Í≥µÍ∞úÎêú ÏûêÎ£å Î¶¨Ïä§Ìä∏Î•º Ï°∞ÌöåÌïòÎäî api
 */
export const getPublicItemForMyList = (
  params?: GetPublicItemForMyListParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/file/v1/common-smart-folder/my-public-item-list`, method: 'GET', params, signal },
    options,
  );
};

export const getGetPublicItemForMyListQueryKey = (params?: GetPublicItemForMyListParams) => {
  return [`/file/v1/common-smart-folder/my-public-item-list`, ...(params ? [params] : [])] as const;
};

export const getGetPublicItemForMyListQueryOptions = <
  TData = Awaited<ReturnType<typeof getPublicItemForMyList>>,
  TError = unknown,
>(
  params?: GetPublicItemForMyListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicItemForMyList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPublicItemForMyListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPublicItemForMyList>>> = ({ signal }) =>
    getPublicItemForMyList(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPublicItemForMyList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetPublicItemForMyListQueryResult = NonNullable<Awaited<ReturnType<typeof getPublicItemForMyList>>>;
export type GetPublicItemForMyListQueryError = unknown;

export function useGetPublicItemForMyList<TData = Awaited<ReturnType<typeof getPublicItemForMyList>>, TError = unknown>(
  params: undefined | GetPublicItemForMyListParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicItemForMyList>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getPublicItemForMyList>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetPublicItemForMyList<TData = Awaited<ReturnType<typeof getPublicItemForMyList>>, TError = unknown>(
  params?: GetPublicItemForMyListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicItemForMyList>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getPublicItemForMyList>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetPublicItemForMyList<TData = Awaited<ReturnType<typeof getPublicItemForMyList>>, TError = unknown>(
  params?: GetPublicItemForMyListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicItemForMyList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÎÇòÏùò Í≥µÍ∞úÎêú ÏûêÎ£å Î¶¨Ïä§Ìä∏Î•º Ï°∞ÌöåÌïòÎäî api
 */

export function useGetPublicItemForMyList<TData = Awaited<ReturnType<typeof getPublicItemForMyList>>, TError = unknown>(
  params?: GetPublicItemForMyListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublicItemForMyList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetPublicItemForMyListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÇ¨Ïö©ÏûêÏùò ÌîÑÎ°úÌïÑ idÏôÄ ÌäπÏ†ïÌè¥Îçî idÎ°ú Ìè¥Îçî ÏïÑÎûòÏùò ÏûêÎ£å Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÏûêÎ£åÎ≥¥ÎìúÏùò ÌïòÏúÑ Ìè¥ÎçîÏùò ÏûêÎ£å Î™©Î°ù Ï°∞Ìöå
 */
export const getItemList = (
  params?: GetItemListParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/file/v1/common-smart-folder/item-list`, method: 'GET', params, signal },
    options,
  );
};

export const getGetItemListQueryKey = (params?: GetItemListParams) => {
  return [`/file/v1/common-smart-folder/item-list`, ...(params ? [params] : [])] as const;
};

export const getGetItemListQueryOptions = <TData = Awaited<ReturnType<typeof getItemList>>, TError = unknown>(
  params?: GetItemListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetItemListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemList>>> = ({ signal }) =>
    getItemList(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getItemList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetItemListQueryResult = NonNullable<Awaited<ReturnType<typeof getItemList>>>;
export type GetItemListQueryError = unknown;

export function useGetItemList<TData = Awaited<ReturnType<typeof getItemList>>, TError = unknown>(
  params: undefined | GetItemListParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemList>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getItemList>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetItemList<TData = Awaited<ReturnType<typeof getItemList>>, TError = unknown>(
  params?: GetItemListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemList>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getItemList>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetItemList<TData = Awaited<ReturnType<typeof getItemList>>, TError = unknown>(
  params?: GetItemListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÏûêÎ£åÎ≥¥ÎìúÏùò ÌïòÏúÑ Ìè¥ÎçîÏùò ÏûêÎ£å Î™©Î°ù Ï°∞Ìöå
 */

export function useGetItemList<TData = Awaited<ReturnType<typeof getItemList>>, TError = unknown>(
  params?: GetItemListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetItemListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏÇ¨Ïö©ÏûêÏùò ÌîÑÎ°úÌïÑ idÏôÄ ÌäπÏ†ï Ìè¥ÎçîÍ∞Ä ÏûàÎã§Î©¥ ÌäπÏ†ïÌè¥Îçî idÎ°ú Ìè¥Îçî Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÏûêÎ£åÎ≥¥ÎìúÏùò ÌïòÏúÑ Ìè¥Îçî Î™©Î°ù Î∞è ÏÇ¨Ïö©ÏûêÍ∞Ä ÎßåÎì† Ìè¥Îçî Î™©Î°ù Ï°∞Ìöå
 */
export const getFolders = (
  params?: GetFoldersParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderResult>(
    { url: `/file/v1/common-smart-folder/folder-list`, method: 'GET', params, signal },
    options,
  );
};

export const getGetFoldersQueryKey = (params?: GetFoldersParams) => {
  return [`/file/v1/common-smart-folder/folder-list`, ...(params ? [params] : [])] as const;
};

export const getGetFoldersQueryOptions = <TData = Awaited<ReturnType<typeof getFolders>>, TError = unknown>(
  params?: GetFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetFoldersQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFolders>>> = ({ signal }) =>
    getFolders(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getFolders>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetFoldersQueryResult = NonNullable<Awaited<ReturnType<typeof getFolders>>>;
export type GetFoldersQueryError = unknown;

export function useGetFolders<TData = Awaited<ReturnType<typeof getFolders>>, TError = unknown>(
  params: undefined | GetFoldersParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFolders>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getFolders>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetFolders<TData = Awaited<ReturnType<typeof getFolders>>, TError = unknown>(
  params?: GetFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFolders>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getFolders>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetFolders<TData = Awaited<ReturnType<typeof getFolders>>, TError = unknown>(
  params?: GetFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÏûêÎ£åÎ≥¥ÎìúÏùò ÌïòÏúÑ Ìè¥Îçî Î™©Î°ù Î∞è ÏÇ¨Ïö©ÏûêÍ∞Ä ÎßåÎì† Ìè¥Îçî Î™©Î°ù Ï°∞Ìöå
 */

export function useGetFolders<TData = Awaited<ReturnType<typeof getFolders>>, TError = unknown>(
  params?: GetFoldersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getFolders>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetFoldersQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏûêÎ£åÎ≥¥ÎìúÏùò ÏûêÎ£å idÎ•º Ïù¥Ïö©Ìï¥ÏÑú ÏûêÎ£åÏùò Í≤ΩÎ°úÎ•º Ï°∞ÌöåÌï©ÎãàÎã§.(ÎπµÎøåÏãúÎûòÍ∏∞ ÌëúÏãúÏö©)
 * @summary ÌååÏùºÏùò Ìè¥Îçî Í≤ΩÎ°úÎ•º Ï°∞ÌöåÌïòÎäî api
 */
export const getItemFlatPathTree = (
  params: GetItemFlatPathTreeParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderTreeResult>(
    { url: `/file/v1/common-smart-folder/flat-path-tree`, method: 'GET', params, signal },
    options,
  );
};

export const getGetItemFlatPathTreeQueryKey = (params: GetItemFlatPathTreeParams) => {
  return [`/file/v1/common-smart-folder/flat-path-tree`, ...(params ? [params] : [])] as const;
};

export const getGetItemFlatPathTreeQueryOptions = <
  TData = Awaited<ReturnType<typeof getItemFlatPathTree>>,
  TError = unknown,
>(
  params: GetItemFlatPathTreeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemFlatPathTree>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetItemFlatPathTreeQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemFlatPathTree>>> = ({ signal }) =>
    getItemFlatPathTree(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getItemFlatPathTree>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetItemFlatPathTreeQueryResult = NonNullable<Awaited<ReturnType<typeof getItemFlatPathTree>>>;
export type GetItemFlatPathTreeQueryError = unknown;

export function useGetItemFlatPathTree<TData = Awaited<ReturnType<typeof getItemFlatPathTree>>, TError = unknown>(
  params: GetItemFlatPathTreeParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemFlatPathTree>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getItemFlatPathTree>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetItemFlatPathTree<TData = Awaited<ReturnType<typeof getItemFlatPathTree>>, TError = unknown>(
  params: GetItemFlatPathTreeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemFlatPathTree>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getItemFlatPathTree>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetItemFlatPathTree<TData = Awaited<ReturnType<typeof getItemFlatPathTree>>, TError = unknown>(
  params: GetItemFlatPathTreeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemFlatPathTree>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÌååÏùºÏùò Ìè¥Îçî Í≤ΩÎ°úÎ•º Ï°∞ÌöåÌïòÎäî api
 */

export function useGetItemFlatPathTree<TData = Awaited<ReturnType<typeof getItemFlatPathTree>>, TError = unknown>(
  params: GetItemFlatPathTreeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemFlatPathTree>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetItemFlatPathTreeQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Îã§Ïö¥Î∞õÍ∏∞ ÏöîÏ≤≠ÏùÑ ÏúÑÌï¥ÏÑú Ìè¥Îçî ÌïòÏúÑÏùò ÏûêÎ£åÌÇ§ Î¶¨Ïä§Ìä∏Î•º ÏöîÏ≤≠Ìï©ÎãàÎã§.
 * @summary ÏöîÏ≤≠Ìïú Ìè¥Îçî ÌïòÏúÑÏùò ÏûêÎ£å ÌÇ§ Î™©Î°ù Ï°∞Ìöå(Ìè¥Îçî Îã§Ïö¥Î°úÎìúÏö©)
 */
export const getItemKeyList = (
  params: GetItemKeyListParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListString>(
    { url: `/file/v1/common-smart-folder/drive-key-list`, method: 'GET', params, signal },
    options,
  );
};

export const getGetItemKeyListQueryKey = (params: GetItemKeyListParams) => {
  return [`/file/v1/common-smart-folder/drive-key-list`, ...(params ? [params] : [])] as const;
};

export const getGetItemKeyListQueryOptions = <TData = Awaited<ReturnType<typeof getItemKeyList>>, TError = unknown>(
  params: GetItemKeyListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemKeyList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetItemKeyListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemKeyList>>> = ({ signal }) =>
    getItemKeyList(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getItemKeyList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetItemKeyListQueryResult = NonNullable<Awaited<ReturnType<typeof getItemKeyList>>>;
export type GetItemKeyListQueryError = unknown;

export function useGetItemKeyList<TData = Awaited<ReturnType<typeof getItemKeyList>>, TError = unknown>(
  params: GetItemKeyListParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemKeyList>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getItemKeyList>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetItemKeyList<TData = Awaited<ReturnType<typeof getItemKeyList>>, TError = unknown>(
  params: GetItemKeyListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemKeyList>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getItemKeyList>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetItemKeyList<TData = Awaited<ReturnType<typeof getItemKeyList>>, TError = unknown>(
  params: GetItemKeyListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemKeyList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÏöîÏ≤≠Ìïú Ìè¥Îçî ÌïòÏúÑÏùò ÏûêÎ£å ÌÇ§ Î™©Î°ù Ï°∞Ìöå(Ìè¥Îçî Îã§Ïö¥Î°úÎìúÏö©)
 */

export function useGetItemKeyList<TData = Awaited<ReturnType<typeof getItemKeyList>>, TError = unknown>(
  params: GetItemKeyListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemKeyList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetItemKeyListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏûêÎ£åÎ≥¥ÎìúÏùò ÏûêÎ£å idÎ•º Ïù¥Ïö©Ìï¥ÏÑú ÏûêÎ£åÏùò ÏÑ∏Î∂ÄÏ†ïÎ≥¥Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary ÌååÏùºÏùò ÏÉÅÏÑ∏Î≥¥Í∏∞ Íµ¨ÌòÑÏùÑ ÏúÑÌï¥ Ï°∞ÌöåÌïòÎäî api
 */
export const getSmartFolderItem1 = (
  params: GetSmartFolderItem1Params,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseSmartFolderItemDetailedResult>(
    { url: `/file/v1/common-smart-folder/detailed-info`, method: 'GET', params, signal },
    options,
  );
};

export const getGetSmartFolderItem1QueryKey = (params: GetSmartFolderItem1Params) => {
  return [`/file/v1/common-smart-folder/detailed-info`, ...(params ? [params] : [])] as const;
};

export const getGetSmartFolderItem1QueryOptions = <
  TData = Awaited<ReturnType<typeof getSmartFolderItem1>>,
  TError = unknown,
>(
  params: GetSmartFolderItem1Params,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItem1>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSmartFolderItem1QueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSmartFolderItem1>>> = ({ signal }) =>
    getSmartFolderItem1(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSmartFolderItem1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetSmartFolderItem1QueryResult = NonNullable<Awaited<ReturnType<typeof getSmartFolderItem1>>>;
export type GetSmartFolderItem1QueryError = unknown;

export function useGetSmartFolderItem1<TData = Awaited<ReturnType<typeof getSmartFolderItem1>>, TError = unknown>(
  params: GetSmartFolderItem1Params,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItem1>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getSmartFolderItem1>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetSmartFolderItem1<TData = Awaited<ReturnType<typeof getSmartFolderItem1>>, TError = unknown>(
  params: GetSmartFolderItem1Params,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItem1>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getSmartFolderItem1>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetSmartFolderItem1<TData = Awaited<ReturnType<typeof getSmartFolderItem1>>, TError = unknown>(
  params: GetSmartFolderItem1Params,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItem1>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ÌååÏùºÏùò ÏÉÅÏÑ∏Î≥¥Í∏∞ Íµ¨ÌòÑÏùÑ ÏúÑÌï¥ Ï°∞ÌöåÌïòÎäî api
 */

export function useGetSmartFolderItem1<TData = Awaited<ReturnType<typeof getSmartFolderItem1>>, TError = unknown>(
  params: GetSmartFolderItem1Params,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItem1>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetSmartFolderItem1QueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const removeFromService = (
  trashcanRequest: TrashcanRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseString>(
    {
      url: `/file/v1/trashcan/remove-from-service`,
      method: 'DELETE',
      headers: { 'Content-Type': 'application/json' },
      data: trashcanRequest,
    },
    options,
  );
};

export const getRemoveFromServiceMutationOptions = <
  TData = Awaited<ReturnType<typeof removeFromService>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: TrashcanRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['removeFromService'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeFromService>>, { data: TrashcanRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return removeFromService(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError, { data: TrashcanRequest }, TContext>;
};

export type RemoveFromServiceMutationResult = NonNullable<Awaited<ReturnType<typeof removeFromService>>>;
export type RemoveFromServiceMutationBody = TrashcanRequest;
export type RemoveFromServiceMutationError = unknown;

export const useRemoveFromService = <
  TData = Awaited<ReturnType<typeof removeFromService>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: TrashcanRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: TrashcanRequest }, TContext> => {
  const mutationOptions = getRemoveFromServiceMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Ï∂îÏ≤ú ÌÇ§ÏõåÎìú Ï†ïÎ≥¥Î•º ÏÇ≠Ï†úÌï©ÎãàÎã§.
 * @summary Ï∂îÏ≤ú ÌÇ§ÏõåÎìú Ï†ïÎ≥¥ ÏÇ≠Ï†ú
 */
export const deleteRecommendationKeywordInfo = (
  id: string,
  params: DeleteRecommendationKeywordInfoParams,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseString>(
    { url: `/file/v1/recommendation/common-keywords/${id}/delete`, method: 'DELETE', params },
    options,
  );
};

export const getDeleteRecommendationKeywordInfoMutationOptions = <
  TData = Awaited<ReturnType<typeof deleteRecommendationKeywordInfo>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { id: string; params: DeleteRecommendationKeywordInfoParams }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['deleteRecommendationKeywordInfo'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteRecommendationKeywordInfo>>,
    { id: string; params: DeleteRecommendationKeywordInfoParams }
  > = (props) => {
    const { id, params } = props ?? {};

    return deleteRecommendationKeywordInfo(id, params, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { id: string; params: DeleteRecommendationKeywordInfoParams },
    TContext
  >;
};

export type DeleteRecommendationKeywordInfoMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteRecommendationKeywordInfo>>
>;

export type DeleteRecommendationKeywordInfoMutationError = unknown;

/**
 * @summary Ï∂îÏ≤ú ÌÇ§ÏõåÎìú Ï†ïÎ≥¥ ÏÇ≠Ï†ú
 */
export const useDeleteRecommendationKeywordInfo = <
  TData = Awaited<ReturnType<typeof deleteRecommendationKeywordInfo>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { id: string; params: DeleteRecommendationKeywordInfoParams }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { id: string; params: DeleteRecommendationKeywordInfoParams }, TContext> => {
  const mutationOptions = getDeleteRecommendationKeywordInfoMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏöîÏ≤≠ ÏûêÎ£åÎì§ÏùÑ Ìï¥Îãπ Ìè¥ÎçîÏóêÏÑú Ï†úÏô∏ ÏãúÌÇµÎãàÎã§.
 * @summary ÎÇ¥ Ìè¥ÎçîÏóêÏÑú ÏûêÎ£å Ï†úÏô∏(ÎÇ¥ Ìè¥ÎçîÏùò id)
 */
export const removeItem = (
  smartFolderItemid: string,
  removeSmartFolderItemWithIdRequest: RemoveSmartFolderItemWithIdRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseString>(
    {
      url: `/file/v1/my-folder/${smartFolderItemid}/remove-items`,
      method: 'DELETE',
      headers: { 'Content-Type': 'application/json' },
      data: removeSmartFolderItemWithIdRequest,
    },
    options,
  );
};

export const getRemoveItemMutationOptions = <
  TData = Awaited<ReturnType<typeof removeItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { smartFolderItemid: string; data: RemoveSmartFolderItemWithIdRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['removeItem'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeItem>>,
    { smartFolderItemid: string; data: RemoveSmartFolderItemWithIdRequest }
  > = (props) => {
    const { smartFolderItemid, data } = props ?? {};

    return removeItem(smartFolderItemid, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { smartFolderItemid: string; data: RemoveSmartFolderItemWithIdRequest },
    TContext
  >;
};

export type RemoveItemMutationResult = NonNullable<Awaited<ReturnType<typeof removeItem>>>;
export type RemoveItemMutationBody = RemoveSmartFolderItemWithIdRequest;
export type RemoveItemMutationError = unknown;

/**
 * @summary ÎÇ¥ Ìè¥ÎçîÏóêÏÑú ÏûêÎ£å Ï†úÏô∏(ÎÇ¥ Ìè¥ÎçîÏùò id)
 */
export const useRemoveItem = <
  TData = Awaited<ReturnType<typeof removeItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { smartFolderItemid: string; data: RemoveSmartFolderItemWithIdRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<
  TData,
  TError,
  { smartFolderItemid: string; data: RemoveSmartFolderItemWithIdRequest },
  TContext
> => {
  const mutationOptions = getRemoveItemMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏöîÏ≤≠ ÏûêÎ£åÎì§ÏùÑ Ìï¥Îãπ Ìè¥ÎçîÏóêÏÑú Ï†úÏô∏ ÏãúÌÇµÎãàÎã§.
 * @summary ÎÇ¥ Ìè¥ÎçîÏóêÏÑú ÏûêÎ£å Ï†úÏô∏(ÏûêÎ£å ÌÇ§)
 */
export const removeDriveItem = (
  smartFolderItemid: string,
  removeDriveItemFromMyFolderWithKeyRequest: RemoveDriveItemFromMyFolderWithKeyRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseString>(
    {
      url: `/file/v1/my-folder/${smartFolderItemid}/remove-drive-items`,
      method: 'DELETE',
      headers: { 'Content-Type': 'application/json' },
      data: removeDriveItemFromMyFolderWithKeyRequest,
    },
    options,
  );
};

export const getRemoveDriveItemMutationOptions = <
  TData = Awaited<ReturnType<typeof removeDriveItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { smartFolderItemid: string; data: RemoveDriveItemFromMyFolderWithKeyRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['removeDriveItem'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeDriveItem>>,
    { smartFolderItemid: string; data: RemoveDriveItemFromMyFolderWithKeyRequest }
  > = (props) => {
    const { smartFolderItemid, data } = props ?? {};

    return removeDriveItem(smartFolderItemid, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { smartFolderItemid: string; data: RemoveDriveItemFromMyFolderWithKeyRequest },
    TContext
  >;
};

export type RemoveDriveItemMutationResult = NonNullable<Awaited<ReturnType<typeof removeDriveItem>>>;
export type RemoveDriveItemMutationBody = RemoveDriveItemFromMyFolderWithKeyRequest;
export type RemoveDriveItemMutationError = unknown;

/**
 * @summary ÎÇ¥ Ìè¥ÎçîÏóêÏÑú ÏûêÎ£å Ï†úÏô∏(ÏûêÎ£å ÌÇ§)
 */
export const useRemoveDriveItem = <
  TData = Awaited<ReturnType<typeof removeDriveItem>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { smartFolderItemid: string; data: RemoveDriveItemFromMyFolderWithKeyRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<
  TData,
  TError,
  { smartFolderItemid: string; data: RemoveDriveItemFromMyFolderWithKeyRequest },
  TContext
> => {
  const mutationOptions = getRemoveDriveItemMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏöîÏ≤≠ ÏûêÎ£åÎ•º Ìú¥ÏßÄÌÜµÏúºÎ°ú Ïù¥ÎèôÌï©ÎãàÎã§. Ïã§Ï†ú Î¨ºÎ¶¨Ï†Å ÏûêÎ£åÎßå Ïù¥ÎèôÌï©ÎãàÎã§.
 * @summary ÏûêÎ£åÎ•º Ìú¥ÏßÄÌÜµÏúºÎ°ú Ïù¥Îèô (Ìú¥ÏßÄÌÜµ Í¥ÄÎ†® Ï†ïÏ±Ö Ï†ïÌï¥ÏßÄÎ©¥ Í∞úÎ∞ú ÏòàÏ†ï)
 */
export const moveItemToTrash = (
  moveItemToTrashRequest: MoveItemToTrashRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseString>(
    {
      url: `/file/v1/my-folder/move-to-trash`,
      method: 'DELETE',
      headers: { 'Content-Type': 'application/json' },
      data: moveItemToTrashRequest,
    },
    options,
  );
};

export const getMoveItemToTrashMutationOptions = <
  TData = Awaited<ReturnType<typeof moveItemToTrash>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MoveItemToTrashRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['moveItemToTrash'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof moveItemToTrash>>, { data: MoveItemToTrashRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return moveItemToTrash(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: MoveItemToTrashRequest },
    TContext
  >;
};

export type MoveItemToTrashMutationResult = NonNullable<Awaited<ReturnType<typeof moveItemToTrash>>>;
export type MoveItemToTrashMutationBody = MoveItemToTrashRequest;
export type MoveItemToTrashMutationError = unknown;

/**
 * @summary ÏûêÎ£åÎ•º Ìú¥ÏßÄÌÜµÏúºÎ°ú Ïù¥Îèô (Ìú¥ÏßÄÌÜµ Í¥ÄÎ†® Ï†ïÏ±Ö Ï†ïÌï¥ÏßÄÎ©¥ Í∞úÎ∞ú ÏòàÏ†ï)
 */
export const useMoveItemToTrash = <
  TData = Awaited<ReturnType<typeof moveItemToTrash>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MoveItemToTrashRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: MoveItemToTrashRequest }, TContext> => {
  const mutationOptions = getMoveItemToTrashMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Î≥¥Ïó¨Ï£ºÎçò ÏûêÎ£åÎ•º Ï†úÍ±∞Ìï©ÎãàÎã§. ÏûêÎ£åÏùò Í≥µÍ∞ú ÏÉÅÌÉúÏóê Îî∞Îùº Ïπ¥Ïö¥Ìä∏ÌïòÎçò Ïà´ÏûêÎì§ÎèÑ Ï†úÏô∏ÏãúÌÇµÎãàÎã§.
 * @summary ÎßàÏù¥Î≥¥ÎìúÏóêÏÑú ÏûêÎ£åÎ•º Ï†úÍ±∞ Ìï©ÎãàÎã§.
 */
export const deleteItems = (
  profileId: string,
  deleteMyBoardItemRequest: DeleteMyBoardItemRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseString>(
    {
      url: `/file/v1/my-board/${profileId}/delete`,
      method: 'DELETE',
      headers: { 'Content-Type': 'application/json' },
      data: deleteMyBoardItemRequest,
    },
    options,
  );
};

export const getDeleteItemsMutationOptions = <
  TData = Awaited<ReturnType<typeof deleteItems>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { profileId: string; data: DeleteMyBoardItemRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['deleteItems'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteItems>>,
    { profileId: string; data: DeleteMyBoardItemRequest }
  > = (props) => {
    const { profileId, data } = props ?? {};

    return deleteItems(profileId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { profileId: string; data: DeleteMyBoardItemRequest },
    TContext
  >;
};

export type DeleteItemsMutationResult = NonNullable<Awaited<ReturnType<typeof deleteItems>>>;
export type DeleteItemsMutationBody = DeleteMyBoardItemRequest;
export type DeleteItemsMutationError = unknown;

/**
 * @summary ÎßàÏù¥Î≥¥ÎìúÏóêÏÑú ÏûêÎ£åÎ•º Ï†úÍ±∞ Ìï©ÎãàÎã§.
 */
export const useDeleteItems = <
  TData = Awaited<ReturnType<typeof deleteItems>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { profileId: string; data: DeleteMyBoardItemRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { profileId: string; data: DeleteMyBoardItemRequest }, TContext> => {
  const mutationOptions = getDeleteItemsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏöîÏ≤≠ ÏûêÎ£åÎ•º Ìú¥ÏßÄÌÜµÏúºÎ°ú Ïù¥ÎèôÌï©ÎãàÎã§.
 * @summary ÏûêÎ£åÎ•º Ìú¥ÏßÄÌÜµÏúºÎ°ú Ïù¥Îèô
 */
export const moveItemToTrash1 = (trashcanRequest: TrashcanRequest, options?: SecondParameter<typeof customFetcher>) => {
  return customFetcher<ApiResponseString>(
    {
      url: `/file/v1/common-smart-folder/move-to-trash`,
      method: 'DELETE',
      headers: { 'Content-Type': 'application/json' },
      data: trashcanRequest,
    },
    options,
  );
};

export const getMoveItemToTrash1MutationOptions = <
  TData = Awaited<ReturnType<typeof moveItemToTrash1>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: TrashcanRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['moveItemToTrash1'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof moveItemToTrash1>>, { data: TrashcanRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return moveItemToTrash1(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError, { data: TrashcanRequest }, TContext>;
};

export type MoveItemToTrash1MutationResult = NonNullable<Awaited<ReturnType<typeof moveItemToTrash1>>>;
export type MoveItemToTrash1MutationBody = TrashcanRequest;
export type MoveItemToTrash1MutationError = unknown;

/**
 * @summary ÏûêÎ£åÎ•º Ìú¥ÏßÄÌÜµÏúºÎ°ú Ïù¥Îèô
 */
export const useMoveItemToTrash1 = <
  TData = Awaited<ReturnType<typeof moveItemToTrash1>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: TrashcanRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: TrashcanRequest }, TContext> => {
  const mutationOptions = getMoveItemToTrash1MutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ÏöîÏ≤≠ ÏûêÎ£åÎ•º Ìï¥Îãπ Ìè¥ÎçîÏóêÏÑú Î≥¥Ïù¥ÏßÄ ÏïäÍ≤å Ìï©ÎãàÎã§.(ÌòπÏùÄ Ï†úÏô∏) ÎÇ¥ Ìè¥ÎçîÏóêÏÑ† ÏÇ≠Ï†úÌïòÍ≥†, Ïä§ÎßàÌä∏Ìè¥ÎçîÏóêÏÑúÎäî Ïà®ÍπÄÏ≤òÎ¶¨Î•º Ìï©ÎãàÎã§.
 * @summary ÏûêÎ£åÎ•º Ìï¥Îãπ Ìè¥ÎçîÏóêÏÑú Ïà®Í∏∞Í∏∞(Îçî Ïù¥ÏÉÅ Î≥¥ÏßÄÏïäÍ∏∞)
 */
export const hideItems = (
  commonHideItemRequest: CommonHideItemRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseString>(
    {
      url: `/file/v1/common-smart-folder/hide`,
      method: 'DELETE',
      headers: { 'Content-Type': 'application/json' },
      data: commonHideItemRequest,
    },
    options,
  );
};

export const getHideItemsMutationOptions = <
  TData = Awaited<ReturnType<typeof hideItems>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CommonHideItemRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['hideItems'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof hideItems>>, { data: CommonHideItemRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return hideItems(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: CommonHideItemRequest },
    TContext
  >;
};

export type HideItemsMutationResult = NonNullable<Awaited<ReturnType<typeof hideItems>>>;
export type HideItemsMutationBody = CommonHideItemRequest;
export type HideItemsMutationError = unknown;

/**
 * @summary ÏûêÎ£åÎ•º Ìï¥Îãπ Ìè¥ÎçîÏóêÏÑú Ïà®Í∏∞Í∏∞(Îçî Ïù¥ÏÉÅ Î≥¥ÏßÄÏïäÍ∏∞)
 */
export const useHideItems = <
  TData = Awaited<ReturnType<typeof hideItems>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: CommonHideItemRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: CommonHideItemRequest }, TContext> => {
  const mutationOptions = getHideItemsMutationOptions(options);

  return useMutation(mutationOptions);
};
