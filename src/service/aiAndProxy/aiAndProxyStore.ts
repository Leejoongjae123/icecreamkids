/**
 * Generated by orval v7.4.1 ğŸº
 * Do not edit manually.
 * Ai and Proxy API
 * isd / kinder board api doc
 * OpenAPI spec version: v1.1.0
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';
import type {
  AIMaskingReqeust,
  AccountWithdrawRequest,
  AiBlurReqeust,
  ApiResponseAccountResultV2,
  ApiResponseAiEvaluationContentsResult,
  ApiResponseAuthSessionResult,
  ApiResponseBoolean,
  ApiResponseDriveItemResult,
  ApiResponseEducationalClassResult,
  ApiResponseLecturePlanReportCreateSubjectAndEtcWithAiResponse,
  ApiResponseLecturePlanResult,
  ApiResponseListAbusingReportOptionResult,
  ApiResponseListBasicProfilePhotoResult,
  ApiResponseListCdnFileResult,
  ApiResponseListDouble,
  ApiResponseListEducationalClassResult,
  ApiResponseListFileObjectResult,
  ApiResponseListLecturePlanResult,
  ApiResponseListSmartFolderItemResult,
  ApiResponseListSmartFolderResult,
  ApiResponseListString,
  ApiResponseListStudentFaceVectorResult,
  ApiResponseListStudentResult,
  ApiResponseProfileResult,
  ApiResponseSimilarityResult,
  ApiResponseSmartFolderItemDetailedResult,
  ApiResponseSmartFolderItemResult,
  ApiResponseSmsUserValidateSendResponse,
  ApiResponseString,
  ApiResponseStudentFaceVectorResult,
  ApiResponseStudentRecordCreateAiObservationResult,
  ApiResponseStudentResult,
  ApiResponseTitleAndContents,
  ApiResponseUserValidationCodeState,
  DriveItemKeysReqeust,
  EducationalClassUpdateRequest,
  EncodeTestParams,
  FileObjectUploadRequestDto,
  GetAllOptionsParams,
  GetBasicEducationalClassParams,
  GetEducationalClassByIdParams,
  GetEducationalClassesParams,
  GetFaceVectorParams,
  GetLecturePlanListParams,
  GetLecturePlanParams,
  GetRecommendPlansFromMyItemsParams,
  GetSmartFolderItemInfoParams,
  GetStudentFaceVectorListParams,
  GetStudentParams,
  GetStudentsParams,
  GetUploadedFileDeprecatedParams,
  GetUploadedFilesParams,
  LecturePlanCreateWithAiRequest,
  LecturePlanReportCreatePhotoCaptionWithAiRequest,
  LecturePlanReportCreateSubjectAndEtcWithAiRequest,
  MobileAccountJoinWithPhoneRequest,
  MobileAccountUpdateRequestV2,
  MobileCdnFileDownloadRequest,
  MobileChangeAccountPasswordRequest,
  MobileEducationalClassAddRequest,
  MobileMemoFileCreateRequest,
  MobileMemoFileUpdateRequest,
  MobileResetPasswordRequest,
  MobileSignInWithPhoneRequest,
  MobileUpdateTaggedStudentRequestDto,
  MobileUploadCompleteRequest,
  ProfileModifyPhotoRequest,
  SmsUserValidateRequest,
  SmsUserValidateSendRequest,
  StudentAddRequest,
  StudentMoveRequest,
  StudentRecordAiRecreateRequest,
  StudentRecordCreateAiObservationRequest,
  StudentUpdateRequest,
  StudentVectorAddRequest,
  StudentVectorDeleteRequest,
  StudentVectorUpdateRequest,
  TestTwoDriveItemKeysReqeust,
  TimeEncodeParams,
} from './schemas';
import { customFetcher } from '../custom-fetcher';

type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1];

/**
 * í† í°ì„ ê°±ì‹ í•˜ê±°ë‚˜, í˜„ì¬ í† í°ì„ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
 * @summary í† í° ì¡°íšŒ or ê°±ì‹ 
 */
export const refreshToken = (token: string, options?: SecondParameter<typeof customFetcher>) => {
  return customFetcher<ApiResponseAuthSessionResult>(
    { url: `/m/member/refresh-token/${token}`, method: 'PUT' },
    options,
  );
};

export const getRefreshTokenMutationOptions = <
  TData = Awaited<ReturnType<typeof refreshToken>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { token: string }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['refreshToken'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof refreshToken>>, { token: string }> = (props) => {
    const { token } = props ?? {};

    return refreshToken(token, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError, { token: string }, TContext>;
};

export type RefreshTokenMutationResult = NonNullable<Awaited<ReturnType<typeof refreshToken>>>;

export type RefreshTokenMutationError = unknown;

/**
 * @summary í† í° ì¡°íšŒ or ê°±ì‹ 
 */
export const useRefreshToken = <
  TData = Awaited<ReturnType<typeof refreshToken>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { token: string }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { token: string }, TContext> => {
  const mutationOptions = getRefreshTokenMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ì‚¬ì§„ì„ ì—…ë¡œë“œí•˜ê³ , ì—…ë¡œë“œ ì™„ë£Œí•œ fileObjectì˜ idë¡œ í”„ë¡œí•„ ì‚¬ì§„ì„ ë³€ê²½í•©ë‹ˆë‹¤.
 * @summary í”„ë¡œí•„ ì‚¬ì§„ ë“±ë¡(ë³€ê²½)
 */
export const modifyPhoto = (
  profileModifyPhotoRequest: ProfileModifyPhotoRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseProfileResult>(
    {
      url: `/m/member/profile/photo`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: profileModifyPhotoRequest,
    },
    options,
  );
};

export const getModifyPhotoMutationOptions = <
  TData = Awaited<ReturnType<typeof modifyPhoto>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: ProfileModifyPhotoRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['modifyPhoto'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof modifyPhoto>>, { data: ProfileModifyPhotoRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return modifyPhoto(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: ProfileModifyPhotoRequest },
    TContext
  >;
};

export type ModifyPhotoMutationResult = NonNullable<Awaited<ReturnType<typeof modifyPhoto>>>;
export type ModifyPhotoMutationBody = ProfileModifyPhotoRequest;
export type ModifyPhotoMutationError = unknown;

/**
 * @summary í”„ë¡œí•„ ì‚¬ì§„ ë“±ë¡(ë³€ê²½)
 */
export const useModifyPhoto = <
  TData = Awaited<ReturnType<typeof modifyPhoto>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: ProfileModifyPhotoRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: ProfileModifyPhotoRequest }, TContext> => {
  const mutationOptions = getModifyPhotoMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ì¸ì¦ë°›ì€ ì „í™”ë²ˆí˜¸ë¡œ ë¹„ë°€ë²ˆí˜¸ë¥¼ ë³€ê²½í•˜ëŠ” api ì…ë‹ˆë‹¤.
 * @summary ë¹„ë°€ë²ˆí˜¸ ì¬ì„¤ì •(ì°¾ê¸°ìš©)
 */
export const resetPassword = (
  mobileResetPasswordRequest: MobileResetPasswordRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseString>(
    {
      url: `/m/member/accounts/reset-password`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: mobileResetPasswordRequest,
    },
    options,
  );
};

export const getResetPasswordMutationOptions = <
  TData = Awaited<ReturnType<typeof resetPassword>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileResetPasswordRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['resetPassword'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof resetPassword>>,
    { data: MobileResetPasswordRequest }
  > = (props) => {
    const { data } = props ?? {};

    return resetPassword(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: MobileResetPasswordRequest },
    TContext
  >;
};

export type ResetPasswordMutationResult = NonNullable<Awaited<ReturnType<typeof resetPassword>>>;
export type ResetPasswordMutationBody = MobileResetPasswordRequest;
export type ResetPasswordMutationError = unknown;

/**
 * @summary ë¹„ë°€ë²ˆí˜¸ ì¬ì„¤ì •(ì°¾ê¸°ìš©)
 */
export const useResetPassword = <
  TData = Awaited<ReturnType<typeof resetPassword>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileResetPasswordRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: MobileResetPasswordRequest }, TContext> => {
  const mutationOptions = getResetPasswordMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * í† í°ìœ¼ë¡œ ì‚¬ìš©ìë¥¼ ì²´í¬í•´ì„œ ë¹„ë°€ë²ˆí˜¸ë¥¼ ë³€ê²½í•˜ëŠ” api ì…ë‹ˆë‹¤.
 * @summary ë¹„ë°€ë²ˆí˜¸ ë³€ê²½
 */
export const changePassword = (
  mobileChangeAccountPasswordRequest: MobileChangeAccountPasswordRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseString>(
    {
      url: `/m/member/accounts/change-password`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: mobileChangeAccountPasswordRequest,
    },
    options,
  );
};

export const getChangePasswordMutationOptions = <
  TData = Awaited<ReturnType<typeof changePassword>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileChangeAccountPasswordRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['changePassword'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof changePassword>>,
    { data: MobileChangeAccountPasswordRequest }
  > = (props) => {
    const { data } = props ?? {};

    return changePassword(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: MobileChangeAccountPasswordRequest },
    TContext
  >;
};

export type ChangePasswordMutationResult = NonNullable<Awaited<ReturnType<typeof changePassword>>>;
export type ChangePasswordMutationBody = MobileChangeAccountPasswordRequest;
export type ChangePasswordMutationError = unknown;

/**
 * @summary ë¹„ë°€ë²ˆí˜¸ ë³€ê²½
 */
export const useChangePassword = <
  TData = Awaited<ReturnType<typeof changePassword>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileChangeAccountPasswordRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: MobileChangeAccountPasswordRequest }, TContext> => {
  const mutationOptions = getChangePasswordMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * íšŒì› ë° í”„ë¡œí•„ ì •ë³´ë¥¼ ìˆ˜ì •í•©ë‹ˆë‹¤.
 * @summary íšŒì›+í”„ë¡œí•„ ì •ë³´ ìˆ˜ì •
 */
export const updateAccountInfo = (
  mobileAccountUpdateRequestV2: MobileAccountUpdateRequestV2,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseAccountResultV2>(
    {
      url: `/m/member/account`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: mobileAccountUpdateRequestV2,
    },
    options,
  );
};

export const getUpdateAccountInfoMutationOptions = <
  TData = Awaited<ReturnType<typeof updateAccountInfo>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileAccountUpdateRequestV2 }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['updateAccountInfo'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateAccountInfo>>,
    { data: MobileAccountUpdateRequestV2 }
  > = (props) => {
    const { data } = props ?? {};

    return updateAccountInfo(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: MobileAccountUpdateRequestV2 },
    TContext
  >;
};

export type UpdateAccountInfoMutationResult = NonNullable<Awaited<ReturnType<typeof updateAccountInfo>>>;
export type UpdateAccountInfoMutationBody = MobileAccountUpdateRequestV2;
export type UpdateAccountInfoMutationError = unknown;

/**
 * @summary íšŒì›+í”„ë¡œí•„ ì •ë³´ ìˆ˜ì •
 */
export const useUpdateAccountInfo = <
  TData = Awaited<ReturnType<typeof updateAccountInfo>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileAccountUpdateRequestV2 }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: MobileAccountUpdateRequestV2 }, TContext> => {
  const mutationOptions = getUpdateAccountInfoMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * S3ì— ì—…ë¡œë“œë¥¼ ì™„ë£Œí•˜ë©´ source : FILEì˜ idë¥¼ mainFileObjectIdì— ë³´ë‚´ì£¼ì‹œë©´ ë©ë‹ˆë‹¤. sourceê°€ THUMBNAILì´ë‚˜ PROFILEì¼ ê²½ìš° ë‹¨ìˆœ ì™„ë£Œì²˜ë¦¬ë¼ thumbnailObjectIdì— ë„£ì§€ë§ˆì‹œê³  mainFileObjectIdì— ì•„ì´ë”” ì „ë‹¬í•´ì£¼ì‹œë©´ ë˜ë©°, ë”ë¯¸ë°ì´í„°ê°€ ë‚´ë ¤ê°‘ë‹ˆë‹¤.
 * @summary [ì—…ë¡œë“œ ì™„ë£Œ] presigned urlì— ì—…ë¡œë“œ ì™„ë£Œí›„ ì½œë°± api
 */
export const uploadCompletedForUpload = (
  mobileUploadCompleteRequest: MobileUploadCompleteRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseDriveItemResult>(
    {
      url: `/m/file/upload-completed`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: mobileUploadCompleteRequest,
    },
    options,
  );
};

export const getUploadCompletedForUploadMutationOptions = <
  TData = Awaited<ReturnType<typeof uploadCompletedForUpload>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileUploadCompleteRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['uploadCompletedForUpload'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof uploadCompletedForUpload>>,
    { data: MobileUploadCompleteRequest }
  > = (props) => {
    const { data } = props ?? {};

    return uploadCompletedForUpload(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: MobileUploadCompleteRequest },
    TContext
  >;
};

export type UploadCompletedForUploadMutationResult = NonNullable<Awaited<ReturnType<typeof uploadCompletedForUpload>>>;
export type UploadCompletedForUploadMutationBody = MobileUploadCompleteRequest;
export type UploadCompletedForUploadMutationError = unknown;

/**
 * @summary [ì—…ë¡œë“œ ì™„ë£Œ] presigned urlì— ì—…ë¡œë“œ ì™„ë£Œí›„ ì½œë°± api
 */
export const useUploadCompletedForUpload = <
  TData = Awaited<ReturnType<typeof uploadCompletedForUpload>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileUploadCompleteRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: MobileUploadCompleteRequest }, TContext> => {
  const mutationOptions = getUploadCompletedForUploadMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ë©”ëª¨ íŒŒì¼ì„ ìˆ˜ì •í•©ë‹ˆë‹¤.
 * @summary ë©”ëª¨ íŒŒì¼ì„ ìˆ˜ì •í•˜ëŠ” api
 */
export const updateMemoFile = (
  mobileMemoFileUpdateRequest: MobileMemoFileUpdateRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseSmartFolderItemResult>(
    {
      url: `/m/file/update-memo-file`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: mobileMemoFileUpdateRequest,
    },
    options,
  );
};

export const getUpdateMemoFileMutationOptions = <
  TData = Awaited<ReturnType<typeof updateMemoFile>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileMemoFileUpdateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['updateMemoFile'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateMemoFile>>,
    { data: MobileMemoFileUpdateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return updateMemoFile(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: MobileMemoFileUpdateRequest },
    TContext
  >;
};

export type UpdateMemoFileMutationResult = NonNullable<Awaited<ReturnType<typeof updateMemoFile>>>;
export type UpdateMemoFileMutationBody = MobileMemoFileUpdateRequest;
export type UpdateMemoFileMutationError = unknown;

/**
 * @summary ë©”ëª¨ íŒŒì¼ì„ ìˆ˜ì •í•˜ëŠ” api
 */
export const useUpdateMemoFile = <
  TData = Awaited<ReturnType<typeof updateMemoFile>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileMemoFileUpdateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: MobileMemoFileUpdateRequest }, TContext> => {
  const mutationOptions = getUpdateMemoFileMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ìë£Œì— íƒœê¹…ëœ í•™ìƒ ì •ë³´ë¥¼ ìˆ˜ì •í•©ë‹ˆë‹¤.
 * @summary ìë£Œì— ì•„ì´ íƒœê·¸ ìˆ˜ì •
 */
export const updateTaggedStudent = (
  mobileUpdateTaggedStudentRequestDto: MobileUpdateTaggedStudentRequestDto,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseDriveItemResult>(
    {
      url: `/m/file/tagged-students`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: mobileUpdateTaggedStudentRequestDto,
    },
    options,
  );
};

export const getUpdateTaggedStudentMutationOptions = <
  TData = Awaited<ReturnType<typeof updateTaggedStudent>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileUpdateTaggedStudentRequestDto }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['updateTaggedStudent'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateTaggedStudent>>,
    { data: MobileUpdateTaggedStudentRequestDto }
  > = (props) => {
    const { data } = props ?? {};

    return updateTaggedStudent(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: MobileUpdateTaggedStudentRequestDto },
    TContext
  >;
};

export type UpdateTaggedStudentMutationResult = NonNullable<Awaited<ReturnType<typeof updateTaggedStudent>>>;
export type UpdateTaggedStudentMutationBody = MobileUpdateTaggedStudentRequestDto;
export type UpdateTaggedStudentMutationError = unknown;

/**
 * @summary ìë£Œì— ì•„ì´ íƒœê·¸ ìˆ˜ì •
 */
export const useUpdateTaggedStudent = <
  TData = Awaited<ReturnType<typeof updateTaggedStudent>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileUpdateTaggedStudentRequestDto }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: MobileUpdateTaggedStudentRequestDto }, TContext> => {
  const mutationOptions = getUpdateTaggedStudentMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ë°˜ ì •ë³´ë¥¼ ì•„ì´ë””ë¡œ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary ë°˜ ì•„ì´ë””ë¡œ ì¡°íšŒ
 */
export const getEducationalClassById = (
  educationalClassId: number,
  params?: GetEducationalClassByIdParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseEducationalClassResult>(
    { url: `/m/educational-class/${educationalClassId}`, method: 'GET', params, signal },
    options,
  );
};

export const getGetEducationalClassByIdQueryKey = (
  educationalClassId: number,
  params?: GetEducationalClassByIdParams,
) => {
  return [`/m/educational-class/${educationalClassId}`, ...(params ? [params] : [])] as const;
};

export const getGetEducationalClassByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getEducationalClassById>>,
  TError = unknown,
>(
  educationalClassId: number,
  params?: GetEducationalClassByIdParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getEducationalClassById>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetEducationalClassByIdQueryKey(educationalClassId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getEducationalClassById>>> = ({ signal }) =>
    getEducationalClassById(educationalClassId, params, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!educationalClassId, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getEducationalClassById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetEducationalClassByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getEducationalClassById>>>;
export type GetEducationalClassByIdQueryError = unknown;

export function useGetEducationalClassById<
  TData = Awaited<ReturnType<typeof getEducationalClassById>>,
  TError = unknown,
>(
  educationalClassId: number,
  params: undefined | GetEducationalClassByIdParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getEducationalClassById>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getEducationalClassById>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetEducationalClassById<
  TData = Awaited<ReturnType<typeof getEducationalClassById>>,
  TError = unknown,
>(
  educationalClassId: number,
  params?: GetEducationalClassByIdParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getEducationalClassById>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getEducationalClassById>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetEducationalClassById<
  TData = Awaited<ReturnType<typeof getEducationalClassById>>,
  TError = unknown,
>(
  educationalClassId: number,
  params?: GetEducationalClassByIdParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getEducationalClassById>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ë°˜ ì•„ì´ë””ë¡œ ì¡°íšŒ
 */

export function useGetEducationalClassById<
  TData = Awaited<ReturnType<typeof getEducationalClassById>>,
  TError = unknown,
>(
  educationalClassId: number,
  params?: GetEducationalClassByIdParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getEducationalClassById>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetEducationalClassByIdQueryOptions(educationalClassId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ë°˜ ì •ë³´ë¥¼ ìˆ˜ì •í•©ë‹ˆë‹¤. ë³€ê²½í•  ê°’ë§Œ ì „ì†¡í•˜ë©´ ë©ë‹ˆë‹¤.
 * @summary ë°˜ ì •ë³´ ìˆ˜ì •
 */
export const updateEducationalClassById = (
  educationalClassId: number,
  educationalClassUpdateRequest: EducationalClassUpdateRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseEducationalClassResult>(
    {
      url: `/m/educational-class/${educationalClassId}`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: educationalClassUpdateRequest,
    },
    options,
  );
};

export const getUpdateEducationalClassByIdMutationOptions = <
  TData = Awaited<ReturnType<typeof updateEducationalClassById>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { educationalClassId: number; data: EducationalClassUpdateRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['updateEducationalClassById'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateEducationalClassById>>,
    { educationalClassId: number; data: EducationalClassUpdateRequest }
  > = (props) => {
    const { educationalClassId, data } = props ?? {};

    return updateEducationalClassById(educationalClassId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { educationalClassId: number; data: EducationalClassUpdateRequest },
    TContext
  >;
};

export type UpdateEducationalClassByIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateEducationalClassById>>
>;
export type UpdateEducationalClassByIdMutationBody = EducationalClassUpdateRequest;
export type UpdateEducationalClassByIdMutationError = unknown;

/**
 * @summary ë°˜ ì •ë³´ ìˆ˜ì •
 */
export const useUpdateEducationalClassById = <
  TData = Awaited<ReturnType<typeof updateEducationalClassById>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { educationalClassId: number; data: EducationalClassUpdateRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { educationalClassId: number; data: EducationalClassUpdateRequest }, TContext> => {
  const mutationOptions = getUpdateEducationalClassByIdMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ë“±ë¡ëœ ë°˜ ì •ë³´ë¥¼ ì‚­ì œí•©ë‹ˆë‹¤.
 * @summary ë°˜ ì‚­ì œ
 */
export const deleteEducationalClassById = (
  educationalClassId: number,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseString>(
    { url: `/m/educational-class/${educationalClassId}`, method: 'DELETE' },
    options,
  );
};

export const getDeleteEducationalClassByIdMutationOptions = <
  TData = Awaited<ReturnType<typeof deleteEducationalClassById>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { educationalClassId: number }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['deleteEducationalClassById'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteEducationalClassById>>,
    { educationalClassId: number }
  > = (props) => {
    const { educationalClassId } = props ?? {};

    return deleteEducationalClassById(educationalClassId, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { educationalClassId: number },
    TContext
  >;
};

export type DeleteEducationalClassByIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteEducationalClassById>>
>;

export type DeleteEducationalClassByIdMutationError = unknown;

/**
 * @summary ë°˜ ì‚­ì œ
 */
export const useDeleteEducationalClassById = <
  TData = Awaited<ReturnType<typeof deleteEducationalClassById>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { educationalClassId: number }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { educationalClassId: number }, TContext> => {
  const mutationOptions = getDeleteEducationalClassByIdMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * í•™ìƒ ì•„ì´ë””ë¡œ ì •ë³´ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary í•™ìƒì •ë³´ ì¡°íšŒ
 */
export const getStudent = (
  studentId: number,
  params?: GetStudentParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseStudentResult>(
    { url: `/m/educational-class/student/${studentId}`, method: 'GET', params, signal },
    options,
  );
};

export const getGetStudentQueryKey = (studentId: number, params?: GetStudentParams) => {
  return [`/m/educational-class/student/${studentId}`, ...(params ? [params] : [])] as const;
};

export const getGetStudentQueryOptions = <TData = Awaited<ReturnType<typeof getStudent>>, TError = unknown>(
  studentId: number,
  params?: GetStudentParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudent>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStudentQueryKey(studentId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getStudent>>> = ({ signal }) =>
    getStudent(studentId, params, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!studentId, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getStudent>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetStudentQueryResult = NonNullable<Awaited<ReturnType<typeof getStudent>>>;
export type GetStudentQueryError = unknown;

export function useGetStudent<TData = Awaited<ReturnType<typeof getStudent>>, TError = unknown>(
  studentId: number,
  params: undefined | GetStudentParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudent>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getStudent>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetStudent<TData = Awaited<ReturnType<typeof getStudent>>, TError = unknown>(
  studentId: number,
  params?: GetStudentParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudent>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getStudent>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetStudent<TData = Awaited<ReturnType<typeof getStudent>>, TError = unknown>(
  studentId: number,
  params?: GetStudentParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudent>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary í•™ìƒì •ë³´ ì¡°íšŒ
 */

export function useGetStudent<TData = Awaited<ReturnType<typeof getStudent>>, TError = unknown>(
  studentId: number,
  params?: GetStudentParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudent>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetStudentQueryOptions(studentId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * í•™ìƒ ì •ë³´ë¥¼ ìˆ˜ì •í•©ë‹ˆë‹¤.
 * @summary í•™ìƒì •ë³´ ìˆ˜ì •
 */
export const updateStudent = (
  studentId: number,
  studentUpdateRequest: StudentUpdateRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseStudentResult>(
    {
      url: `/m/educational-class/student/${studentId}`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: studentUpdateRequest,
    },
    options,
  );
};

export const getUpdateStudentMutationOptions = <
  TData = Awaited<ReturnType<typeof updateStudent>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { studentId: number; data: StudentUpdateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['updateStudent'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateStudent>>,
    { studentId: number; data: StudentUpdateRequest }
  > = (props) => {
    const { studentId, data } = props ?? {};

    return updateStudent(studentId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { studentId: number; data: StudentUpdateRequest },
    TContext
  >;
};

export type UpdateStudentMutationResult = NonNullable<Awaited<ReturnType<typeof updateStudent>>>;
export type UpdateStudentMutationBody = StudentUpdateRequest;
export type UpdateStudentMutationError = unknown;

/**
 * @summary í•™ìƒì •ë³´ ìˆ˜ì •
 */
export const useUpdateStudent = <
  TData = Awaited<ReturnType<typeof updateStudent>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { studentId: number; data: StudentUpdateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { studentId: number; data: StudentUpdateRequest }, TContext> => {
  const mutationOptions = getUpdateStudentMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * í•™ìƒ ì •ë³´ë¥¼ ì‚­ì œí•©ë‹ˆë‹¤.
 * @summary í•™ìƒì •ë³´ ì‚­ì œ
 */
export const deleteStudent = (studentId: number, options?: SecondParameter<typeof customFetcher>) => {
  return customFetcher<ApiResponseString>(
    { url: `/m/educational-class/student/${studentId}`, method: 'DELETE' },
    options,
  );
};

export const getDeleteStudentMutationOptions = <
  TData = Awaited<ReturnType<typeof deleteStudent>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { studentId: number }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['deleteStudent'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteStudent>>, { studentId: number }> = (props) => {
    const { studentId } = props ?? {};

    return deleteStudent(studentId, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError, { studentId: number }, TContext>;
};

export type DeleteStudentMutationResult = NonNullable<Awaited<ReturnType<typeof deleteStudent>>>;

export type DeleteStudentMutationError = unknown;

/**
 * @summary í•™ìƒì •ë³´ ì‚­ì œ
 */
export const useDeleteStudent = <
  TData = Awaited<ReturnType<typeof deleteStudent>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { studentId: number }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { studentId: number }, TContext> => {
  const mutationOptions = getDeleteStudentMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * í•™ìƒì„ ë‹¤ë¥¸ ë°˜ìœ¼ë¡œ ì´ë™ì‹œí‚µë‹ˆë‹¤.
 * @summary í•™ìƒì •ë³´ ì´ë™
 */
export const moveStudent = (
  studentId: number,
  studentMoveRequest: StudentMoveRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseEducationalClassResult>(
    {
      url: `/m/educational-class/student/${studentId}/move-class`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: studentMoveRequest,
    },
    options,
  );
};

export const getMoveStudentMutationOptions = <
  TData = Awaited<ReturnType<typeof moveStudent>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { studentId: number; data: StudentMoveRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['moveStudent'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof moveStudent>>,
    { studentId: number; data: StudentMoveRequest }
  > = (props) => {
    const { studentId, data } = props ?? {};

    return moveStudent(studentId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { studentId: number; data: StudentMoveRequest },
    TContext
  >;
};

export type MoveStudentMutationResult = NonNullable<Awaited<ReturnType<typeof moveStudent>>>;
export type MoveStudentMutationBody = StudentMoveRequest;
export type MoveStudentMutationError = unknown;

/**
 * @summary í•™ìƒì •ë³´ ì´ë™
 */
export const useMoveStudent = <
  TData = Awaited<ReturnType<typeof moveStudent>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { studentId: number; data: StudentMoveRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { studentId: number; data: StudentMoveRequest }, TContext> => {
  const mutationOptions = getMoveStudentMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * í•™ìƒì˜ ë²¡í„° ì •ë³´ë¥¼ ìˆ˜ì •í•©ë‹ˆë‹¤.<br>ìˆ˜ì •í•  í•„ë“œë§Œ ì „ì†¡í•˜ì‹œê³ , ìˆ˜ì •ì´ í•„ìš”í•˜ì§€ ì•Šì€ í•„ë“œëŠ” nullì´ë‚˜ ì•„ì˜ˆ ì…ë ¥ jsonì—ì„œ ì „ì†¡í•˜ì§€ ì•Šìœ¼ì…”ë„ ë©ë‹ˆë‹¤,<br>ì˜ˆ) ì´ë¦„ë§Œ ìˆ˜ì • : {
  "id": 2,
  "name": "í…ŒìŠ¤íŠ¸2(ìˆ˜ì •í…ŒìŠ¤íŠ¸-ì´ë¦„ë§Œ)",
  "studentId": -2
} 
 * @summary ë²¡í„° ì •ë³´ ìˆ˜ì •
 */
export const updateStudent1 = (
  studentVectorUpdateRequest: StudentVectorUpdateRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseStudentFaceVectorResult>(
    {
      url: `/api/student-feature-vector/`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: studentVectorUpdateRequest,
    },
    options,
  );
};

export const getUpdateStudent1MutationOptions = <
  TData = Awaited<ReturnType<typeof updateStudent1>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: StudentVectorUpdateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['updateStudent1'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateStudent1>>,
    { data: StudentVectorUpdateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return updateStudent1(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: StudentVectorUpdateRequest },
    TContext
  >;
};

export type UpdateStudent1MutationResult = NonNullable<Awaited<ReturnType<typeof updateStudent1>>>;
export type UpdateStudent1MutationBody = StudentVectorUpdateRequest;
export type UpdateStudent1MutationError = unknown;

/**
 * @summary ë²¡í„° ì •ë³´ ìˆ˜ì •
 */
export const useUpdateStudent1 = <
  TData = Awaited<ReturnType<typeof updateStudent1>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: StudentVectorUpdateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: StudentVectorUpdateRequest }, TContext> => {
  const mutationOptions = getUpdateStudent1MutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ë²¡í„°ì •ë³´ë¥¼ ìƒˆë¡œ ë“±ë¡í•©ë‹ˆë‹¤. idëŠ” ìë™ìœ¼ë¡œ ìƒì„±í•´ì„œ ë°˜í™˜í•©ë‹ˆë‹¤. <br>í‚¨ë”ë³´ë“œì—ì„œ ì•„ì´ë¥¼ ìƒì„±í•˜ì§€ ì•Šê³  ë‹¨ìˆœ í…ŒìŠ¤íŠ¸ìš©ìœ¼ë¡œ ì‚¬ìš©í•˜ì‹¤ ë• studentIdë¥¼ ìŒìˆ˜ë¡œ ë„£ì–´ì£¼ì‹œê¸° ë°”ëë‹ˆë‹¤.
 * @summary ë²¡í„° ì •ë³´ ë“±ë¡
 */
export const createVector = (
  studentVectorAddRequest: StudentVectorAddRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseStudentFaceVectorResult>(
    {
      url: `/api/student-feature-vector/`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: studentVectorAddRequest,
      signal,
    },
    options,
  );
};

export const getCreateVectorMutationOptions = <
  TData = Awaited<ReturnType<typeof createVector>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: StudentVectorAddRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['createVector'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof createVector>>, { data: StudentVectorAddRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return createVector(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: StudentVectorAddRequest },
    TContext
  >;
};

export type CreateVectorMutationResult = NonNullable<Awaited<ReturnType<typeof createVector>>>;
export type CreateVectorMutationBody = StudentVectorAddRequest;
export type CreateVectorMutationError = unknown;

/**
 * @summary ë²¡í„° ì •ë³´ ë“±ë¡
 */
export const useCreateVector = <
  TData = Awaited<ReturnType<typeof createVector>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: StudentVectorAddRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: StudentVectorAddRequest }, TContext> => {
  const mutationOptions = getCreateVectorMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * í•™ìƒ ì •ë³´ë¥¼ ì‚­ì œí•©ë‹ˆë‹¤.
 * @summary í•™ìƒì •ë³´ ì‚­ì œ
 */
export const deleteStudent1 = (
  studentVectorDeleteRequest: StudentVectorDeleteRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseBoolean>(
    {
      url: `/api/student-feature-vector/`,
      method: 'DELETE',
      headers: { 'Content-Type': 'application/json' },
      data: studentVectorDeleteRequest,
    },
    options,
  );
};

export const getDeleteStudent1MutationOptions = <
  TData = Awaited<ReturnType<typeof deleteStudent1>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: StudentVectorDeleteRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['deleteStudent1'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteStudent1>>,
    { data: StudentVectorDeleteRequest }
  > = (props) => {
    const { data } = props ?? {};

    return deleteStudent1(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: StudentVectorDeleteRequest },
    TContext
  >;
};

export type DeleteStudent1MutationResult = NonNullable<Awaited<ReturnType<typeof deleteStudent1>>>;
export type DeleteStudent1MutationBody = StudentVectorDeleteRequest;
export type DeleteStudent1MutationError = unknown;

/**
 * @summary í•™ìƒì •ë³´ ì‚­ì œ
 */
export const useDeleteStudent1 = <
  TData = Awaited<ReturnType<typeof deleteStudent1>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: StudentVectorDeleteRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: StudentVectorDeleteRequest }, TContext> => {
  const mutationOptions = getDeleteStudent1MutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * smsë¡œ ì¸ì¦ì½”ë“œë¥¼ ë°œì†¡í•©ë‹ˆë‹¤. (ì „í™”ë²ˆí˜¸ëŠ” ì•”í˜¸í™”í•´ì„œ, ipëŠ” ì•„ë¬´ê±°ë‚˜ ë³´ë‚´ì…”ë„ ë©ë‹ˆë‹¤.)
 * @summary ì¸ì¦ì½”ë“œ ë°œì†¡ ìš”ì²­
 */
export const requestValidate = (
  smsUserValidateSendRequest: SmsUserValidateSendRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseSmsUserValidateSendResponse>(
    {
      url: `/m/member/validation/request`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: smsUserValidateSendRequest,
      signal,
    },
    options,
  );
};

export const getRequestValidateMutationOptions = <
  TData = Awaited<ReturnType<typeof requestValidate>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: SmsUserValidateSendRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['requestValidate'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof requestValidate>>,
    { data: SmsUserValidateSendRequest }
  > = (props) => {
    const { data } = props ?? {};

    return requestValidate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: SmsUserValidateSendRequest },
    TContext
  >;
};

export type RequestValidateMutationResult = NonNullable<Awaited<ReturnType<typeof requestValidate>>>;
export type RequestValidateMutationBody = SmsUserValidateSendRequest;
export type RequestValidateMutationError = unknown;

/**
 * @summary ì¸ì¦ì½”ë“œ ë°œì†¡ ìš”ì²­
 */
export const useRequestValidate = <
  TData = Awaited<ReturnType<typeof requestValidate>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: SmsUserValidateSendRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: SmsUserValidateSendRequest }, TContext> => {
  const mutationOptions = getRequestValidateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * (ì „í™”ë²ˆí˜¸ëŠ” ì•”í˜¸í™”í•´ì„œ) ì¸ì¦ì½”ë“œì™€ ë°œì†¡í•œ ë²ˆí˜¸ë¡œ ê²€ì¦ì„ ì§„í–‰í•©ë‹ˆë‹¤.
 * @summary ì¸ì¦ì½”ë“œ ë°œì†¡ëœ ì¸ì¦ì½”ë“œë¥¼ ê²€ì¦í•˜ëŠ” api
 */
export const validateCode = (
  smsUserValidateRequest: SmsUserValidateRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseUserValidationCodeState>(
    {
      url: `/m/member/validation/code`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: smsUserValidateRequest,
      signal,
    },
    options,
  );
};

export const getValidateCodeMutationOptions = <
  TData = Awaited<ReturnType<typeof validateCode>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: SmsUserValidateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['validateCode'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof validateCode>>, { data: SmsUserValidateRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return validateCode(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: SmsUserValidateRequest },
    TContext
  >;
};

export type ValidateCodeMutationResult = NonNullable<Awaited<ReturnType<typeof validateCode>>>;
export type ValidateCodeMutationBody = SmsUserValidateRequest;
export type ValidateCodeMutationError = unknown;

/**
 * @summary ì¸ì¦ì½”ë“œ ë°œì†¡ëœ ì¸ì¦ì½”ë“œë¥¼ ê²€ì¦í•˜ëŠ” api
 */
export const useValidateCode = <
  TData = Awaited<ReturnType<typeof validateCode>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: SmsUserValidateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: SmsUserValidateRequest }, TContext> => {
  const mutationOptions = getValidateCodeMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * í•¸ë“œí° ë²ˆí˜¸ë¡œ íšŒì›ê°€ì…ì„ ì§„í–‰í•©ë‹ˆë‹¤.
 * @summary íšŒì›ê°€ì…
 */
export const joinWithPhone = (
  mobileAccountJoinWithPhoneRequest: MobileAccountJoinWithPhoneRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseAccountResultV2>(
    {
      url: `/m/member/sign-up`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: mobileAccountJoinWithPhoneRequest,
      signal,
    },
    options,
  );
};

export const getJoinWithPhoneMutationOptions = <
  TData = Awaited<ReturnType<typeof joinWithPhone>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileAccountJoinWithPhoneRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['joinWithPhone'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof joinWithPhone>>,
    { data: MobileAccountJoinWithPhoneRequest }
  > = (props) => {
    const { data } = props ?? {};

    return joinWithPhone(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: MobileAccountJoinWithPhoneRequest },
    TContext
  >;
};

export type JoinWithPhoneMutationResult = NonNullable<Awaited<ReturnType<typeof joinWithPhone>>>;
export type JoinWithPhoneMutationBody = MobileAccountJoinWithPhoneRequest;
export type JoinWithPhoneMutationError = unknown;

/**
 * @summary íšŒì›ê°€ì…
 */
export const useJoinWithPhone = <
  TData = Awaited<ReturnType<typeof joinWithPhone>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileAccountJoinWithPhoneRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: MobileAccountJoinWithPhoneRequest }, TContext> => {
  const mutationOptions = getJoinWithPhoneMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ë²ˆí˜¸ì™€ ë¹„ë°€ë²ˆí˜¸ë¡œ ë¡œê·¸ì¸í•˜ê³  í† í°ì„ ì–»ëŠ” apiì…ë‹ˆë‹¤.1ê°œ ê³„ì •ìœ¼ë¡œ ìµœëŒ€ 3ê°œì˜ ì„œë¡œ ë‹¤ë¥¸ ë””ë°”ì´ìŠ¤ì—ì„œ ì¸ì¦ ì„¸ì…˜ì„ ìœ ì§€í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ 4ë²ˆì§¸ ë¡œê·¸ì¸ë¶€í„°ëŠ” ë‹¤ìŒ ìˆœì„œë¡œ ì„¸ì…˜ì´ ì¢…ë£Œëœë‹¤.
  1. ì¸ì¦ ì„¸ì…˜ì´ ë§Œë£Œëœ ê²ƒ
  2. ë§Œë£Œëœ ì„¸ì…˜ì´ ì—¬ëŸ¬ ê°œë¼ë©´, ë§Œë£Œ ì‹œì ì´ ì˜¤ë˜ëœ ìˆœì„œë¡œ
  3. ë§Œë£Œëœ ì„¸ì…˜ì´ ì—†ë‹¤ë©´ ë§Œë£Œ ì‹œì ì´ ê°€ê¹Œìš´ ìˆœì„œë¡œ
 * @summary ë²ˆí˜¸ë¡œ ë¡œê·¸ì¸ í•˜ëŠ” api
 */
export const signin = (
  mobileSignInWithPhoneRequest: MobileSignInWithPhoneRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseAuthSessionResult>(
    {
      url: `/m/member/sign-in`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: mobileSignInWithPhoneRequest,
      signal,
    },
    options,
  );
};

export const getSigninMutationOptions = <
  TData = Awaited<ReturnType<typeof signin>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileSignInWithPhoneRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['signin'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof signin>>, { data: MobileSignInWithPhoneRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return signin(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: MobileSignInWithPhoneRequest },
    TContext
  >;
};

export type SigninMutationResult = NonNullable<Awaited<ReturnType<typeof signin>>>;
export type SigninMutationBody = MobileSignInWithPhoneRequest;
export type SigninMutationError = unknown;

/**
 * @summary ë²ˆí˜¸ë¡œ ë¡œê·¸ì¸ í•˜ëŠ” api
 */
export const useSignin = <TData = Awaited<ReturnType<typeof signin>>, TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileSignInWithPhoneRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: MobileSignInWithPhoneRequest }, TContext> => {
  const mutationOptions = getSigninMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * íƒˆí‡´ ìš”ì²­í•˜ëŠ” api ì…ë‹ˆë‹¤. í† í°ê³¼ ì…ë ¥í•œ í”„ë¡œí•„ idë¡œ 1ì°¨ ìœ íš¨ì„± ê²€ì‚¬ë¥¼ í•©ë‹ˆë‹¤.
 * @summary íƒˆí‡´ ìš”ì²­(ì¼ë‹¨ ë¡œê·¸ë§Œ ìŒ“ê¸°)
 */
export const requestWithdraw = (
  accountWithdrawRequest: AccountWithdrawRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseString>(
    {
      url: `/m/member/accounts/withdraw`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: accountWithdrawRequest,
      signal,
    },
    options,
  );
};

export const getRequestWithdrawMutationOptions = <
  TData = Awaited<ReturnType<typeof requestWithdraw>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: AccountWithdrawRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['requestWithdraw'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof requestWithdraw>>, { data: AccountWithdrawRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return requestWithdraw(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: AccountWithdrawRequest },
    TContext
  >;
};

export type RequestWithdrawMutationResult = NonNullable<Awaited<ReturnType<typeof requestWithdraw>>>;
export type RequestWithdrawMutationBody = AccountWithdrawRequest;
export type RequestWithdrawMutationError = unknown;

/**
 * @summary íƒˆí‡´ ìš”ì²­(ì¼ë‹¨ ë¡œê·¸ë§Œ ìŒ“ê¸°)
 */
export const useRequestWithdraw = <
  TData = Awaited<ReturnType<typeof requestWithdraw>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: AccountWithdrawRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: AccountWithdrawRequest }, TContext> => {
  const mutationOptions = getRequestWithdrawMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ëª¨ë°”ì¼ì—ì„œ ì—…ë¡œë“œí•œ ìë£Œ ë¦¬ìŠ¤íŠ¸ë¥¼ ì¡°íšŒí•˜ëŠ” api ì…ë‹ˆë‹¤.
 * @summary ê¸°ë¡ë³´ê¸° api (ëª¨ë°”ì¼ì—ì„œ ì˜¬ë¦° ìë£Œë“¤ ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ)
 */
export const getUploadedFiles = (
  params?: GetUploadedFilesParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/m/file/uploaded-items`, method: 'GET', params, signal },
    options,
  );
};

export const getGetUploadedFilesQueryKey = (params?: GetUploadedFilesParams) => {
  return [`/m/file/uploaded-items`, ...(params ? [params] : [])] as const;
};

export const getGetUploadedFilesQueryOptions = <TData = Awaited<ReturnType<typeof getUploadedFiles>>, TError = unknown>(
  params?: GetUploadedFilesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUploadedFiles>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUploadedFilesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUploadedFiles>>> = ({ signal }) =>
    getUploadedFiles(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUploadedFiles>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetUploadedFilesQueryResult = NonNullable<Awaited<ReturnType<typeof getUploadedFiles>>>;
export type GetUploadedFilesQueryError = unknown;

export function useGetUploadedFiles<TData = Awaited<ReturnType<typeof getUploadedFiles>>, TError = unknown>(
  params: undefined | GetUploadedFilesParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUploadedFiles>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getUploadedFiles>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetUploadedFiles<TData = Awaited<ReturnType<typeof getUploadedFiles>>, TError = unknown>(
  params?: GetUploadedFilesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUploadedFiles>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getUploadedFiles>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetUploadedFiles<TData = Awaited<ReturnType<typeof getUploadedFiles>>, TError = unknown>(
  params?: GetUploadedFilesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUploadedFiles>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ê¸°ë¡ë³´ê¸° api (ëª¨ë°”ì¼ì—ì„œ ì˜¬ë¦° ìë£Œë“¤ ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ)
 */

export function useGetUploadedFiles<TData = Awaited<ReturnType<typeof getUploadedFiles>>, TError = unknown>(
  params?: GetUploadedFilesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUploadedFiles>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetUploadedFilesQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ëª¨ë°”ì¼ì—ì„œ ì—…ë¡œë“œí•œ ìë£Œ ë¦¬ìŠ¤íŠ¸ë¥¼ ì¡°íšŒí•˜ëŠ” api ì…ë‹ˆë‹¤.
 * @summary [ì‚­ì œì˜ˆì •]ê¸°ë¡ë³´ê¸° api (ëª¨ë°”ì¼ì—ì„œ ì˜¬ë¦° ìë£Œë“¤ ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ)
 */
export const getUploadedFileDeprecated = (
  params?: GetUploadedFileDeprecatedParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/m/file/uploaded-items`, method: 'POST', params, signal },
    options,
  );
};

export const getGetUploadedFileDeprecatedMutationOptions = <
  TData = Awaited<ReturnType<typeof getUploadedFileDeprecated>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { params?: GetUploadedFileDeprecatedParams }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['getUploadedFileDeprecated'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof getUploadedFileDeprecated>>,
    { params?: GetUploadedFileDeprecatedParams }
  > = (props) => {
    const { params } = props ?? {};

    return getUploadedFileDeprecated(params, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { params?: GetUploadedFileDeprecatedParams },
    TContext
  >;
};

export type GetUploadedFileDeprecatedMutationResult = NonNullable<
  Awaited<ReturnType<typeof getUploadedFileDeprecated>>
>;

export type GetUploadedFileDeprecatedMutationError = unknown;

/**
 * @summary [ì‚­ì œì˜ˆì •]ê¸°ë¡ë³´ê¸° api (ëª¨ë°”ì¼ì—ì„œ ì˜¬ë¦° ìë£Œë“¤ ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ)
 */
export const useGetUploadedFileDeprecated = <
  TData = Awaited<ReturnType<typeof getUploadedFileDeprecated>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { params?: GetUploadedFileDeprecatedParams }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { params?: GetUploadedFileDeprecatedParams }, TContext> => {
  const mutationOptions = getGetUploadedFileDeprecatedMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ì—…ë¡œë“œ í•˜ê¸°ìœ„í•´ì„œ urlì„ ìš”ì²­í•©ë‹ˆë‹¤. resultë¡œ ì˜¨ source : FILEì˜ idë¥¼ ì—…ë¡œë“œ ì™„ë£Œ ìš”ì²­ì— ë³´ë‚´ì£¼ì…”ì•¼í•˜ê³ , presignedUrlì— ì—…ë¡œë“œí•˜ì‹œë©´ ë©ë‹ˆë‹¤.
 * @summary [ì—…ë¡œë“œ ì „]s3ì— ì—…ë¡œë“œí•  presigned url ìš”ì²­ api
 */
export const uploadPrepareForApi = (
  fileObjectUploadRequestDto: FileObjectUploadRequestDto[],
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListFileObjectResult>(
    {
      url: `/m/file/request-presinged-url`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: fileObjectUploadRequestDto,
      signal,
    },
    options,
  );
};

export const getUploadPrepareForApiMutationOptions = <
  TData = Awaited<ReturnType<typeof uploadPrepareForApi>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: FileObjectUploadRequestDto[] }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['uploadPrepareForApi'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof uploadPrepareForApi>>,
    { data: FileObjectUploadRequestDto[] }
  > = (props) => {
    const { data } = props ?? {};

    return uploadPrepareForApi(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: FileObjectUploadRequestDto[] },
    TContext
  >;
};

export type UploadPrepareForApiMutationResult = NonNullable<Awaited<ReturnType<typeof uploadPrepareForApi>>>;
export type UploadPrepareForApiMutationBody = FileObjectUploadRequestDto[];
export type UploadPrepareForApiMutationError = unknown;

/**
 * @summary [ì—…ë¡œë“œ ì „]s3ì— ì—…ë¡œë“œí•  presigned url ìš”ì²­ api
 */
export const useUploadPrepareForApi = <
  TData = Awaited<ReturnType<typeof uploadPrepareForApi>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: FileObjectUploadRequestDto[] }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: FileObjectUploadRequestDto[] }, TContext> => {
  const mutationOptions = getUploadPrepareForApiMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ì›ë³¸ ë¯¸ë¦¬ë³´ê¸°ì— ì‚¬ìš©í•  presigned urlë¥¼ ìš”ì²­í•˜ëŠ” api ì…ë‹ˆë‹¤.
 * @summary ìë£Œì˜ í”„ë¦¬ë·°ìš© ë§í¬ ìš”ì²­
 */
export const getCdnFilesForPreviewV2 = (
  mobileCdnFileDownloadRequest: MobileCdnFileDownloadRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListCdnFileResult>(
    {
      url: `/m/file/preview-presigned-urls`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: mobileCdnFileDownloadRequest,
      signal,
    },
    options,
  );
};

export const getGetCdnFilesForPreviewV2MutationOptions = <
  TData = Awaited<ReturnType<typeof getCdnFilesForPreviewV2>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileCdnFileDownloadRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['getCdnFilesForPreviewV2'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof getCdnFilesForPreviewV2>>,
    { data: MobileCdnFileDownloadRequest }
  > = (props) => {
    const { data } = props ?? {};

    return getCdnFilesForPreviewV2(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: MobileCdnFileDownloadRequest },
    TContext
  >;
};

export type GetCdnFilesForPreviewV2MutationResult = NonNullable<Awaited<ReturnType<typeof getCdnFilesForPreviewV2>>>;
export type GetCdnFilesForPreviewV2MutationBody = MobileCdnFileDownloadRequest;
export type GetCdnFilesForPreviewV2MutationError = unknown;

/**
 * @summary ìë£Œì˜ í”„ë¦¬ë·°ìš© ë§í¬ ìš”ì²­
 */
export const useGetCdnFilesForPreviewV2 = <
  TData = Awaited<ReturnType<typeof getCdnFilesForPreviewV2>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileCdnFileDownloadRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: MobileCdnFileDownloadRequest }, TContext> => {
  const mutationOptions = getGetCdnFilesForPreviewV2MutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ì›ë³¸ ìë£Œë¥¼ ë‹¤ìš´ ë°›ì„ ìˆ˜ ìˆëŠ” presigned urlë¥¼ ìš”ì²­í•˜ëŠ” api ì…ë‹ˆë‹¤.
 * @summary (ê³µê°œìë£Œìš©)ìë£Œì˜ ë‹¤ìš´ë¡œë“œ ë§í¬ ìš”ì²­
 */
export const getCdnFilesForDownloadV2 = (
  mobileCdnFileDownloadRequest: MobileCdnFileDownloadRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListCdnFileResult>(
    {
      url: `/m/file/download-presigned-urls`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: mobileCdnFileDownloadRequest,
      signal,
    },
    options,
  );
};

export const getGetCdnFilesForDownloadV2MutationOptions = <
  TData = Awaited<ReturnType<typeof getCdnFilesForDownloadV2>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileCdnFileDownloadRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['getCdnFilesForDownloadV2'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof getCdnFilesForDownloadV2>>,
    { data: MobileCdnFileDownloadRequest }
  > = (props) => {
    const { data } = props ?? {};

    return getCdnFilesForDownloadV2(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: MobileCdnFileDownloadRequest },
    TContext
  >;
};

export type GetCdnFilesForDownloadV2MutationResult = NonNullable<Awaited<ReturnType<typeof getCdnFilesForDownloadV2>>>;
export type GetCdnFilesForDownloadV2MutationBody = MobileCdnFileDownloadRequest;
export type GetCdnFilesForDownloadV2MutationError = unknown;

/**
 * @summary (ê³µê°œìë£Œìš©)ìë£Œì˜ ë‹¤ìš´ë¡œë“œ ë§í¬ ìš”ì²­
 */
export const useGetCdnFilesForDownloadV2 = <
  TData = Awaited<ReturnType<typeof getCdnFilesForDownloadV2>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileCdnFileDownloadRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: MobileCdnFileDownloadRequest }, TContext> => {
  const mutationOptions = getGetCdnFilesForDownloadV2MutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ìƒˆ ë©”ëª¨ íŒŒì¼ì„ ë“±ë¡í•©ë‹ˆë‹¤.
 * @summary ë©”ëª¨ íŒŒì¼ì„ ìƒì„±í•˜ëŠ” api
 */
export const createMemoFile = (
  mobileMemoFileCreateRequest: MobileMemoFileCreateRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseSmartFolderItemResult>(
    {
      url: `/m/file/create-memo-file`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: mobileMemoFileCreateRequest,
      signal,
    },
    options,
  );
};

export const getCreateMemoFileMutationOptions = <
  TData = Awaited<ReturnType<typeof createMemoFile>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileMemoFileCreateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['createMemoFile'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createMemoFile>>,
    { data: MobileMemoFileCreateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createMemoFile(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: MobileMemoFileCreateRequest },
    TContext
  >;
};

export type CreateMemoFileMutationResult = NonNullable<Awaited<ReturnType<typeof createMemoFile>>>;
export type CreateMemoFileMutationBody = MobileMemoFileCreateRequest;
export type CreateMemoFileMutationError = unknown;

/**
 * @summary ë©”ëª¨ íŒŒì¼ì„ ìƒì„±í•˜ëŠ” api
 */
export const useCreateMemoFile = <
  TData = Awaited<ReturnType<typeof createMemoFile>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileMemoFileCreateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: MobileMemoFileCreateRequest }, TContext> => {
  const mutationOptions = getCreateMemoFileMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ë°˜ì— ë“±ë¡ëœ í•™ìƒë“¤ì„ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary ë°˜ì— ë“±ë¡ëœ í•™ìƒë“¤ ì¡°íšŒ.
 */
export const getStudents = (
  educationalClassId: number,
  params?: GetStudentsParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListStudentResult>(
    { url: `/m/educational-class/${educationalClassId}/students`, method: 'GET', params, signal },
    options,
  );
};

export const getGetStudentsQueryKey = (educationalClassId: number, params?: GetStudentsParams) => {
  return [`/m/educational-class/${educationalClassId}/students`, ...(params ? [params] : [])] as const;
};

export const getGetStudentsQueryOptions = <TData = Awaited<ReturnType<typeof getStudents>>, TError = unknown>(
  educationalClassId: number,
  params?: GetStudentsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudents>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStudentsQueryKey(educationalClassId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getStudents>>> = ({ signal }) =>
    getStudents(educationalClassId, params, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!educationalClassId, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getStudents>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetStudentsQueryResult = NonNullable<Awaited<ReturnType<typeof getStudents>>>;
export type GetStudentsQueryError = unknown;

export function useGetStudents<TData = Awaited<ReturnType<typeof getStudents>>, TError = unknown>(
  educationalClassId: number,
  params: undefined | GetStudentsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudents>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getStudents>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetStudents<TData = Awaited<ReturnType<typeof getStudents>>, TError = unknown>(
  educationalClassId: number,
  params?: GetStudentsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudents>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getStudents>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetStudents<TData = Awaited<ReturnType<typeof getStudents>>, TError = unknown>(
  educationalClassId: number,
  params?: GetStudentsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudents>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ë°˜ì— ë“±ë¡ëœ í•™ìƒë“¤ ì¡°íšŒ.
 */

export function useGetStudents<TData = Awaited<ReturnType<typeof getStudents>>, TError = unknown>(
  educationalClassId: number,
  params?: GetStudentsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudents>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetStudentsQueryOptions(educationalClassId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ë°˜ì— ìƒˆë¡œìš´ í•™ìƒì„ ë“±ë¡í•©ë‹ˆë‹¤.ë“±ë¡ ì™„ë£Œì‹œ ì „ë‹¬ë°›ì€ idë¡œì™€ í•™ìƒ ì´ë¦„ìœ¼ë¡œ [POST] /file/v1/smart-folder/photo/student/add-folder ë¥¼ í˜¸ì¶œí•´ì£¼ì…”ì•¼ í•©ë‹ˆë‹¤.
 * @summary ë°˜ì— ì•„ì´/í•™ìƒì„ ì¶”ê°€í•©ë‹ˆë‹¤.
 */
export const addStudent = (
  educationalClassId: number,
  studentAddRequest: StudentAddRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseStudentResult>(
    {
      url: `/m/educational-class/${educationalClassId}/students`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: studentAddRequest,
      signal,
    },
    options,
  );
};

export const getAddStudentMutationOptions = <
  TData = Awaited<ReturnType<typeof addStudent>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { educationalClassId: number; data: StudentAddRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['addStudent'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addStudent>>,
    { educationalClassId: number; data: StudentAddRequest }
  > = (props) => {
    const { educationalClassId, data } = props ?? {};

    return addStudent(educationalClassId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { educationalClassId: number; data: StudentAddRequest },
    TContext
  >;
};

export type AddStudentMutationResult = NonNullable<Awaited<ReturnType<typeof addStudent>>>;
export type AddStudentMutationBody = StudentAddRequest;
export type AddStudentMutationError = unknown;

/**
 * @summary ë°˜ì— ì•„ì´/í•™ìƒì„ ì¶”ê°€í•©ë‹ˆë‹¤.
 */
export const useAddStudent = <
  TData = Awaited<ReturnType<typeof addStudent>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { educationalClassId: number; data: StudentAddRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { educationalClassId: number; data: StudentAddRequest }, TContext> => {
  const mutationOptions = getAddStudentMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ë°˜ ì •ë³´ë¥¼ ì‹ ê·œë¡œ ë“±ë¡í•©ë‹ˆë‹¤.
 * @summary ë°˜ ì‹ ê·œ ë“±ë¡
 */
export const addEducationalClass = (
  mobileEducationalClassAddRequest: MobileEducationalClassAddRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseEducationalClassResult>(
    {
      url: `/m/educational-class/add-educational-class`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: mobileEducationalClassAddRequest,
      signal,
    },
    options,
  );
};

export const getAddEducationalClassMutationOptions = <
  TData = Awaited<ReturnType<typeof addEducationalClass>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileEducationalClassAddRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['addEducationalClass'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addEducationalClass>>,
    { data: MobileEducationalClassAddRequest }
  > = (props) => {
    const { data } = props ?? {};

    return addEducationalClass(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: MobileEducationalClassAddRequest },
    TContext
  >;
};

export type AddEducationalClassMutationResult = NonNullable<Awaited<ReturnType<typeof addEducationalClass>>>;
export type AddEducationalClassMutationBody = MobileEducationalClassAddRequest;
export type AddEducationalClassMutationError = unknown;

/**
 * @summary ë°˜ ì‹ ê·œ ë“±ë¡
 */
export const useAddEducationalClass = <
  TData = Awaited<ReturnType<typeof addEducationalClass>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileEducationalClassAddRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: MobileEducationalClassAddRequest }, TContext> => {
  const mutationOptions = getAddEducationalClassMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ë‘ ì´ë¯¸ì§€ì—ì„œ ì–¼êµ´ì˜ ìœ ì‚¬ë„ë¥¼ í™•ì¸
 * @summary [í…ŒìŠ¤íŠ¸]ì´ë¯¸ì§€ ì–¼êµ´ ìœ ì‚¬ë„ ì²´í¬
 */
export const testSimilarity = (
  testTwoDriveItemKeysReqeust: TestTwoDriveItemKeysReqeust,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseSimilarityResult>(
    {
      url: `/ai/v1/test/similarity`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: testTwoDriveItemKeysReqeust,
      signal,
    },
    options,
  );
};

export const getTestSimilarityMutationOptions = <
  TData = Awaited<ReturnType<typeof testSimilarity>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: TestTwoDriveItemKeysReqeust }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['testSimilarity'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof testSimilarity>>,
    { data: TestTwoDriveItemKeysReqeust }
  > = (props) => {
    const { data } = props ?? {};

    return testSimilarity(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: TestTwoDriveItemKeysReqeust },
    TContext
  >;
};

export type TestSimilarityMutationResult = NonNullable<Awaited<ReturnType<typeof testSimilarity>>>;
export type TestSimilarityMutationBody = TestTwoDriveItemKeysReqeust;
export type TestSimilarityMutationError = unknown;

/**
 * @summary [í…ŒìŠ¤íŠ¸]ì´ë¯¸ì§€ ì–¼êµ´ ìœ ì‚¬ë„ ì²´í¬
 */
export const useTestSimilarity = <
  TData = Awaited<ReturnType<typeof testSimilarity>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: TestTwoDriveItemKeysReqeust }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: TestTwoDriveItemKeysReqeust }, TContext> => {
  const mutationOptions = getTestSimilarityMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ì‚¬ì§„ì— ë‹¬ë¦° ë‚´ìš©ë“¤ê³¼ ì£¼ì œ í‚¤ì›Œë“œë¡œ ì£¼ì œ, ëª©í‘œ, êµì‚¬ì§€ì› ë‚´ìš©ì„ ìƒì„±í•©ë‹ˆë‹¤. í…ŒìŠ¤íŠ¸ë¡œ ìºì‹œë¥¼ ì‘ë‹µí•  ì‹œ, 10ì´ˆ ì´ë‚´ë¡œ ì‘ë‹µí•©ë‹ˆë‹¤.(ëœë¤)
 * @summary ë†€ì´ë³´ê³  ë‚´ìš© ìƒì„±(ì£¼ì œ, ëª©í‘œ, êµì‚¬ì§€ì›)
 */
export const createReport = (
  lecturePlanReportCreateSubjectAndEtcWithAiRequest: LecturePlanReportCreateSubjectAndEtcWithAiRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseLecturePlanReportCreateSubjectAndEtcWithAiResponse>(
    {
      url: `/ai/v1/report`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: lecturePlanReportCreateSubjectAndEtcWithAiRequest,
      signal,
    },
    options,
  );
};

export const getCreateReportMutationOptions = <
  TData = Awaited<ReturnType<typeof createReport>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: LecturePlanReportCreateSubjectAndEtcWithAiRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['createReport'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createReport>>,
    { data: LecturePlanReportCreateSubjectAndEtcWithAiRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createReport(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: LecturePlanReportCreateSubjectAndEtcWithAiRequest },
    TContext
  >;
};

export type CreateReportMutationResult = NonNullable<Awaited<ReturnType<typeof createReport>>>;
export type CreateReportMutationBody = LecturePlanReportCreateSubjectAndEtcWithAiRequest;
export type CreateReportMutationError = unknown;

/**
 * @summary ë†€ì´ë³´ê³  ë‚´ìš© ìƒì„±(ì£¼ì œ, ëª©í‘œ, êµì‚¬ì§€ì›)
 */
export const useCreateReport = <
  TData = Awaited<ReturnType<typeof createReport>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: LecturePlanReportCreateSubjectAndEtcWithAiRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: LecturePlanReportCreateSubjectAndEtcWithAiRequest }, TContext> => {
  const mutationOptions = getCreateReportMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ì‚¬ì§„ì— ë„£ì„ ìº¡ì…˜ì„ ìƒì„±í•©ë‹ˆë‹¤. í…ŒìŠ¤íŠ¸ë¡œ ìºì‹œë¥¼ ì‘ë‹µí•  ì‹œ, 10ì´ˆ ì´ë‚´ë¡œ ì‘ë‹µí•©ë‹ˆë‹¤.(ëœë¤)
 * @summary ë†€ì´ë³´ê³  ì‚¬ì§„ì˜ ìº¡ì…˜ ìƒì„±
 */
export const createPhotoCaption = (
  lecturePlanReportCreatePhotoCaptionWithAiRequest: LecturePlanReportCreatePhotoCaptionWithAiRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseTitleAndContents>(
    {
      url: `/ai/v1/report/photo-caption`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: lecturePlanReportCreatePhotoCaptionWithAiRequest,
      signal,
    },
    options,
  );
};

export const getCreatePhotoCaptionMutationOptions = <
  TData = Awaited<ReturnType<typeof createPhotoCaption>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: LecturePlanReportCreatePhotoCaptionWithAiRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['createPhotoCaption'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createPhotoCaption>>,
    { data: LecturePlanReportCreatePhotoCaptionWithAiRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createPhotoCaption(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: LecturePlanReportCreatePhotoCaptionWithAiRequest },
    TContext
  >;
};

export type CreatePhotoCaptionMutationResult = NonNullable<Awaited<ReturnType<typeof createPhotoCaption>>>;
export type CreatePhotoCaptionMutationBody = LecturePlanReportCreatePhotoCaptionWithAiRequest;
export type CreatePhotoCaptionMutationError = unknown;

/**
 * @summary ë†€ì´ë³´ê³  ì‚¬ì§„ì˜ ìº¡ì…˜ ìƒì„±
 */
export const useCreatePhotoCaption = <
  TData = Awaited<ReturnType<typeof createPhotoCaption>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: LecturePlanReportCreatePhotoCaptionWithAiRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: LecturePlanReportCreatePhotoCaptionWithAiRequest }, TContext> => {
  const mutationOptions = getCreatePhotoCaptionMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ì „ë‹¬ëœ ìë£Œ í‚¤ë“¤ë¡œ ë°°ê²½ì„ ì œê±°í•˜ê³  ì²˜ë¦¬ëœ ìë£Œ ë¦¬ìŠ¤íŠ¸ë¥¼ ì‘ë‹µìœ¼ë¡œ ì „ë‹¬í•©ë‹ˆë‹¤.
 * @summary ë°°ê²½ì§€ìš°ê¸° ì²˜ë¦¬
 */
export const removeBackground = (
  aiBlurReqeust: AiBlurReqeust,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    {
      url: `/ai/v1/remove-background`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: aiBlurReqeust,
      signal,
    },
    options,
  );
};

export const getRemoveBackgroundMutationOptions = <
  TData = Awaited<ReturnType<typeof removeBackground>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: AiBlurReqeust }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['removeBackground'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeBackground>>, { data: AiBlurReqeust }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return removeBackground(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError, { data: AiBlurReqeust }, TContext>;
};

export type RemoveBackgroundMutationResult = NonNullable<Awaited<ReturnType<typeof removeBackground>>>;
export type RemoveBackgroundMutationBody = AiBlurReqeust;
export type RemoveBackgroundMutationError = unknown;

/**
 * @summary ë°°ê²½ì§€ìš°ê¸° ì²˜ë¦¬
 */
export const useRemoveBackground = <
  TData = Awaited<ReturnType<typeof removeBackground>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: AiBlurReqeust }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: AiBlurReqeust }, TContext> => {
  const mutationOptions = getRemoveBackgroundMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * í‰ê°€í•œ ì ìˆ˜ë¡œ ê´€ì°°ê¸°ë¡ë‚´ìš©ì„ ìƒì„±í•©ë‹ˆë‹¤. í…ŒìŠ¤íŠ¸ë¡œ ìºì‹œë¥¼ ì‘ë‹µí•  ì‹œ, 10ì´ˆ ì´ë‚´ë¡œ ì‘ë‹µí•©ë‹ˆë‹¤.(ëœë¤)
 * @summary ê´€ì°°ê¸°ë¡ ë‚´ìš© ìƒì„±
 */
export const createObservation = (
  studentRecordCreateAiObservationRequest: StudentRecordCreateAiObservationRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseStudentRecordCreateAiObservationResult>(
    {
      url: `/ai/v1/observation`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: studentRecordCreateAiObservationRequest,
      signal,
    },
    options,
  );
};

export const getCreateObservationMutationOptions = <
  TData = Awaited<ReturnType<typeof createObservation>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: StudentRecordCreateAiObservationRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['createObservation'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createObservation>>,
    { data: StudentRecordCreateAiObservationRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createObservation(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: StudentRecordCreateAiObservationRequest },
    TContext
  >;
};

export type CreateObservationMutationResult = NonNullable<Awaited<ReturnType<typeof createObservation>>>;
export type CreateObservationMutationBody = StudentRecordCreateAiObservationRequest;
export type CreateObservationMutationError = unknown;

/**
 * @summary ê´€ì°°ê¸°ë¡ ë‚´ìš© ìƒì„±
 */
export const useCreateObservation = <
  TData = Awaited<ReturnType<typeof createObservation>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: StudentRecordCreateAiObservationRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: StudentRecordCreateAiObservationRequest }, TContext> => {
  const mutationOptions = getCreateObservationMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ê¸°ì¡´ë‚´ìš©ìœ¼ë¡œ ìƒˆ ê´€ì°°ê¸°ë¡ì„ ìƒì„±í•œë‹¤.
 * @summary ê´€ì°°ê¸°ë¡ ë‚´ìš© ì¬ìƒì„±
 */
export const recreateObservation = (
  studentRecordAiRecreateRequest: StudentRecordAiRecreateRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseAiEvaluationContentsResult>(
    {
      url: `/ai/v1/observation/recreate`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: studentRecordAiRecreateRequest,
      signal,
    },
    options,
  );
};

export const getRecreateObservationMutationOptions = <
  TData = Awaited<ReturnType<typeof recreateObservation>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: StudentRecordAiRecreateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['recreateObservation'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof recreateObservation>>,
    { data: StudentRecordAiRecreateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return recreateObservation(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: StudentRecordAiRecreateRequest },
    TContext
  >;
};

export type RecreateObservationMutationResult = NonNullable<Awaited<ReturnType<typeof recreateObservation>>>;
export type RecreateObservationMutationBody = StudentRecordAiRecreateRequest;
export type RecreateObservationMutationError = unknown;

/**
 * @summary ê´€ì°°ê¸°ë¡ ë‚´ìš© ì¬ìƒì„±
 */
export const useRecreateObservation = <
  TData = Awaited<ReturnType<typeof recreateObservation>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: StudentRecordAiRecreateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: StudentRecordAiRecreateRequest }, TContext> => {
  const mutationOptions = getRecreateObservationMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ì „ë‹¬ëœ ìë£Œ í‚¤ë“¤ë¡œ ë§ˆìŠ¤í‚¹ì²˜ë¦¬ë¥¼í•˜ê³  ì²˜ë¦¬ëœ ìë£Œ ë¦¬ìŠ¤íŠ¸ë¥¼ ì‘ë‹µìœ¼ë¡œ ì „ë‹¬í•©ë‹ˆë‹¤.
 * @summary ì‚¬ì§„ ìŠ¤ë§ˆì¼ ë§ˆìŠ¤í‚¹ ì²˜ë¦¬
 */
export const maskingFaces = (
  aIMaskingReqeust: AIMaskingReqeust,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    {
      url: `/ai/v1/masking/all`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: aIMaskingReqeust,
      signal,
    },
    options,
  );
};

export const getMaskingFacesMutationOptions = <
  TData = Awaited<ReturnType<typeof maskingFaces>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: AIMaskingReqeust }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['maskingFaces'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof maskingFaces>>, { data: AIMaskingReqeust }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return maskingFaces(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError, { data: AIMaskingReqeust }, TContext>;
};

export type MaskingFacesMutationResult = NonNullable<Awaited<ReturnType<typeof maskingFaces>>>;
export type MaskingFacesMutationBody = AIMaskingReqeust;
export type MaskingFacesMutationError = unknown;

/**
 * @summary ì‚¬ì§„ ìŠ¤ë§ˆì¼ ë§ˆìŠ¤í‚¹ ì²˜ë¦¬
 */
export const useMaskingFaces = <
  TData = Awaited<ReturnType<typeof maskingFaces>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: AIMaskingReqeust }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: AIMaskingReqeust }, TContext> => {
  const mutationOptions = getMaskingFacesMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * aiê°€ ë†€ì´ì¹´ë“œë¥¼ ìƒì„±í•´ì¤ë‹ˆë‹¤.
 * @summary ë†€ì´ê³„íš(ë†€ì´ì¹´ë“œ) ìƒì„±
 */
export const createLecturePlan = (
  lecturePlanCreateWithAiRequest: LecturePlanCreateWithAiRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListLecturePlanResult>(
    {
      url: `/ai/v1/lecturePlan`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: lecturePlanCreateWithAiRequest,
      signal,
    },
    options,
  );
};

export const getCreateLecturePlanMutationOptions = <
  TData = Awaited<ReturnType<typeof createLecturePlan>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: LecturePlanCreateWithAiRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['createLecturePlan'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createLecturePlan>>,
    { data: LecturePlanCreateWithAiRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createLecturePlan(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: LecturePlanCreateWithAiRequest },
    TContext
  >;
};

export type CreateLecturePlanMutationResult = NonNullable<Awaited<ReturnType<typeof createLecturePlan>>>;
export type CreateLecturePlanMutationBody = LecturePlanCreateWithAiRequest;
export type CreateLecturePlanMutationError = unknown;

/**
 * @summary ë†€ì´ê³„íš(ë†€ì´ì¹´ë“œ) ìƒì„±
 */
export const useCreateLecturePlan = <
  TData = Awaited<ReturnType<typeof createLecturePlan>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: LecturePlanCreateWithAiRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: LecturePlanCreateWithAiRequest }, TContext> => {
  const mutationOptions = getCreateLecturePlanMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ì…ë ¥í•œ ì‚¬ì§„ì—ì„œ ì–¼êµ´ ë²¡í„°ë¥¼ ì–»ìŠµë‹ˆë‹¤.
 * @summary ì´ë¯¸ì§€ ì–¼êµ´ ë²¡í„° ì¡°íšŒ
 */
export const getFaceVector = (
  params: GetFaceVectorParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListDouble>({ url: `/ai/v1/face-vector`, method: 'POST', params, signal }, options);
};

export const getGetFaceVectorMutationOptions = <
  TData = Awaited<ReturnType<typeof getFaceVector>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { params: GetFaceVectorParams }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['getFaceVector'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof getFaceVector>>, { params: GetFaceVectorParams }> = (
    props,
  ) => {
    const { params } = props ?? {};

    return getFaceVector(params, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { params: GetFaceVectorParams },
    TContext
  >;
};

export type GetFaceVectorMutationResult = NonNullable<Awaited<ReturnType<typeof getFaceVector>>>;

export type GetFaceVectorMutationError = unknown;

/**
 * @summary ì´ë¯¸ì§€ ì–¼êµ´ ë²¡í„° ì¡°íšŒ
 */
export const useGetFaceVector = <
  TData = Awaited<ReturnType<typeof getFaceVector>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { params: GetFaceVectorParams }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { params: GetFaceVectorParams }, TContext> => {
  const mutationOptions = getGetFaceVectorMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ì „ë‹¬ëœ ìë£Œ í‚¤ë“¤ë¡œ ì–¼êµ´ë¶„ë¦¬ë¥¼í•˜ê³  ì²˜ë¦¬ëœ ìë£Œ ë¦¬ìŠ¤íŠ¸ë¥¼ ì‘ë‹µìœ¼ë¡œ ì „ë‹¬í•©ë‹ˆë‹¤.
 * @summary ì–¼êµ´ ë¶„ë¦¬ ì²˜ë¦¬
 */
export const extractFace = (
  aiBlurReqeust: AiBlurReqeust,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    {
      url: `/ai/v1/extract-face`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: aiBlurReqeust,
      signal,
    },
    options,
  );
};

export const getExtractFaceMutationOptions = <
  TData = Awaited<ReturnType<typeof extractFace>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: AiBlurReqeust }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['extractFace'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof extractFace>>, { data: AiBlurReqeust }> = (props) => {
    const { data } = props ?? {};

    return extractFace(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError, { data: AiBlurReqeust }, TContext>;
};

export type ExtractFaceMutationResult = NonNullable<Awaited<ReturnType<typeof extractFace>>>;
export type ExtractFaceMutationBody = AiBlurReqeust;
export type ExtractFaceMutationError = unknown;

/**
 * @summary ì–¼êµ´ ë¶„ë¦¬ ì²˜ë¦¬
 */
export const useExtractFace = <
  TData = Awaited<ReturnType<typeof extractFace>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: AiBlurReqeust }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: AiBlurReqeust }, TContext> => {
  const mutationOptions = getExtractFaceMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ì „ë‹¬ëœ ìë£Œ í‚¤ë“¤ë¡œ ì•„ì´ ë¶„ë¥˜ë¥¼ ì§„í–‰í•˜ê³  ë¶„ë¥˜ëœ í´ë”ë¥¼ ì‘ë‹µìœ¼ë¡œ ì „ë‹¬í•©ë‹ˆë‹¤.
 * @summary ì•„ì´ ì‚¬ì§„ ë¶„ë¥˜(ë¦¬ìŠ¤íŠ¸)
 */
export const classifyStudentWithList = (
  driveItemKeysReqeust: DriveItemKeysReqeust,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderResult>(
    {
      url: `/ai/v1/classify/students`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: driveItemKeysReqeust,
      signal,
    },
    options,
  );
};

export const getClassifyStudentWithListMutationOptions = <
  TData = Awaited<ReturnType<typeof classifyStudentWithList>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: DriveItemKeysReqeust }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['classifyStudentWithList'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof classifyStudentWithList>>,
    { data: DriveItemKeysReqeust }
  > = (props) => {
    const { data } = props ?? {};

    return classifyStudentWithList(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: DriveItemKeysReqeust },
    TContext
  >;
};

export type ClassifyStudentWithListMutationResult = NonNullable<Awaited<ReturnType<typeof classifyStudentWithList>>>;
export type ClassifyStudentWithListMutationBody = DriveItemKeysReqeust;
export type ClassifyStudentWithListMutationError = unknown;

/**
 * @summary ì•„ì´ ì‚¬ì§„ ë¶„ë¥˜(ë¦¬ìŠ¤íŠ¸)
 */
export const useClassifyStudentWithList = <
  TData = Awaited<ReturnType<typeof classifyStudentWithList>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: DriveItemKeysReqeust }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: DriveItemKeysReqeust }, TContext> => {
  const mutationOptions = getClassifyStudentWithListMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * (í…ŒìŠ¤íŠ¸ìƒíƒœì¼ë•ŒëŠ” ëœë¤ìœ¼ë¡œ í´ë”ë¥¼ ì‘ë‹µí•©ë‹ˆë‹¤.)ì „ë‹¬ëœ ìë£Œ í‚¤ë“¤ë¡œ í™œë™ì‚¬ì§„ì„ ë¶„ë¥˜ë¥¼ ì§„í–‰í•˜ê³  ë¶„ë¥˜ëœ í´ë”ë¥¼ ì‘ë‹µìœ¼ë¡œ ì „ë‹¬í•©ë‹ˆë‹¤.
 * @summary í™œë™ ì‚¬ì§„ ë¶„ë¥˜(ë¦¬ìŠ¤íŠ¸)
 */
export const classifyActivityPhotoWithList = (
  driveItemKeysReqeust: DriveItemKeysReqeust,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderResult>(
    {
      url: `/ai/v1/classify/activityPhotos`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: driveItemKeysReqeust,
      signal,
    },
    options,
  );
};

export const getClassifyActivityPhotoWithListMutationOptions = <
  TData = Awaited<ReturnType<typeof classifyActivityPhotoWithList>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: DriveItemKeysReqeust }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['classifyActivityPhotoWithList'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof classifyActivityPhotoWithList>>,
    { data: DriveItemKeysReqeust }
  > = (props) => {
    const { data } = props ?? {};

    return classifyActivityPhotoWithList(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: DriveItemKeysReqeust },
    TContext
  >;
};

export type ClassifyActivityPhotoWithListMutationResult = NonNullable<
  Awaited<ReturnType<typeof classifyActivityPhotoWithList>>
>;
export type ClassifyActivityPhotoWithListMutationBody = DriveItemKeysReqeust;
export type ClassifyActivityPhotoWithListMutationError = unknown;

/**
 * @summary í™œë™ ì‚¬ì§„ ë¶„ë¥˜(ë¦¬ìŠ¤íŠ¸)
 */
export const useClassifyActivityPhotoWithList = <
  TData = Awaited<ReturnType<typeof classifyActivityPhotoWithList>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: DriveItemKeysReqeust }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: DriveItemKeysReqeust }, TContext> => {
  const mutationOptions = getClassifyActivityPhotoWithListMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ì „ë‹¬ëœ ìë£Œ í‚¤ë“¤ë¡œ ë¸”ëŸ¬ì²˜ë¦¬ë¥¼í•˜ê³  ë¸”ëŸ¬ì²˜ë¦¬ëœ ìë£Œ ë¦¬ìŠ¤íŠ¸ë¥¼ ì‘ë‹µìœ¼ë¡œ ì „ë‹¬í•©ë‹ˆë‹¤.
 * @summary ì‚¬ì§„ ë¸”ëŸ¬ ì²˜ë¦¬
 */
export const blurFaces = (
  aiBlurReqeust: AiBlurReqeust,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    {
      url: `/ai/v1/blur/all`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: aiBlurReqeust,
      signal,
    },
    options,
  );
};

export const getBlurFacesMutationOptions = <
  TData = Awaited<ReturnType<typeof blurFaces>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: AiBlurReqeust }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['blurFaces'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof blurFaces>>, { data: AiBlurReqeust }> = (props) => {
    const { data } = props ?? {};

    return blurFaces(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError, { data: AiBlurReqeust }, TContext>;
};

export type BlurFacesMutationResult = NonNullable<Awaited<ReturnType<typeof blurFaces>>>;
export type BlurFacesMutationBody = AiBlurReqeust;
export type BlurFacesMutationError = unknown;

/**
 * @summary ì‚¬ì§„ ë¸”ëŸ¬ ì²˜ë¦¬
 */
export const useBlurFaces = <
  TData = Awaited<ReturnType<typeof blurFaces>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: AiBlurReqeust }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: AiBlurReqeust }, TContext> => {
  const mutationOptions = getBlurFacesMutationOptions(options);

  return useMutation(mutationOptions);
};

export const timeEncode = (
  params?: TimeEncodeParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseString>({ url: `/m/test/time`, method: 'GET', params, signal }, options);
};

export const getTimeEncodeQueryKey = (params?: TimeEncodeParams) => {
  return [`/m/test/time`, ...(params ? [params] : [])] as const;
};

export const getTimeEncodeQueryOptions = <TData = Awaited<ReturnType<typeof timeEncode>>, TError = unknown>(
  params?: TimeEncodeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof timeEncode>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getTimeEncodeQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof timeEncode>>> = ({ signal }) =>
    timeEncode(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof timeEncode>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type TimeEncodeQueryResult = NonNullable<Awaited<ReturnType<typeof timeEncode>>>;
export type TimeEncodeQueryError = unknown;

export function useTimeEncode<TData = Awaited<ReturnType<typeof timeEncode>>, TError = unknown>(
  params: undefined | TimeEncodeParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof timeEncode>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof timeEncode>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useTimeEncode<TData = Awaited<ReturnType<typeof timeEncode>>, TError = unknown>(
  params?: TimeEncodeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof timeEncode>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof timeEncode>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useTimeEncode<TData = Awaited<ReturnType<typeof timeEncode>>, TError = unknown>(
  params?: TimeEncodeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof timeEncode>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

export function useTimeEncode<TData = Awaited<ReturnType<typeof timeEncode>>, TError = unknown>(
  params?: TimeEncodeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof timeEncode>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getTimeEncodeQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAllKeywords = (options?: SecondParameter<typeof customFetcher>, signal?: AbortSignal) => {
  return customFetcher<ApiResponseListString>({ url: `/m/test/non-auth-check`, method: 'GET', signal }, options);
};

export const getGetAllKeywordsQueryKey = () => {
  return [`/m/test/non-auth-check`] as const;
};

export const getGetAllKeywordsQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllKeywords>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllKeywords>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllKeywordsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllKeywords>>> = ({ signal }) =>
    getAllKeywords(requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllKeywords>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetAllKeywordsQueryResult = NonNullable<Awaited<ReturnType<typeof getAllKeywords>>>;
export type GetAllKeywordsQueryError = unknown;

export function useGetAllKeywords<TData = Awaited<ReturnType<typeof getAllKeywords>>, TError = unknown>(options: {
  query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllKeywords>>, TError, TData>> &
    Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getAllKeywords>>, TError, TData>, 'initialData'>;
  request?: SecondParameter<typeof customFetcher>;
}): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetAllKeywords<TData = Awaited<ReturnType<typeof getAllKeywords>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllKeywords>>, TError, TData>> &
    Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getAllKeywords>>, TError, TData>, 'initialData'>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetAllKeywords<TData = Awaited<ReturnType<typeof getAllKeywords>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllKeywords>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

export function useGetAllKeywords<TData = Awaited<ReturnType<typeof getAllKeywords>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllKeywords>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetAllKeywordsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ì•”í˜¸í™” ë° ë³µí˜¸í™”ë¥¼ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤. ê°œë°œì„œë²„ì—ì„œëŠ” ì¶”ê°€ ì„¤ëª…ì´ ì‘ë‹µìœ¼ë¡œ ë‚´ë ¤ê°‘ë‹ˆë‹¤.
 * @summary (í…ŒìŠ¤íŠ¸ ì¢…ë£Œì‹œ ì‚­ì œ ì˜ˆì •) ì•”í˜¸í™” ë³µí˜¸í™” í…ŒìŠ¤íŠ¸
 */
export const encodeTest = (
  params: EncodeTestParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseString>({ url: `/m/test/encode-decode`, method: 'GET', params, signal }, options);
};

export const getEncodeTestQueryKey = (params: EncodeTestParams) => {
  return [`/m/test/encode-decode`, ...(params ? [params] : [])] as const;
};

export const getEncodeTestQueryOptions = <TData = Awaited<ReturnType<typeof encodeTest>>, TError = unknown>(
  params: EncodeTestParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof encodeTest>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getEncodeTestQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof encodeTest>>> = ({ signal }) =>
    encodeTest(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof encodeTest>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type EncodeTestQueryResult = NonNullable<Awaited<ReturnType<typeof encodeTest>>>;
export type EncodeTestQueryError = unknown;

export function useEncodeTest<TData = Awaited<ReturnType<typeof encodeTest>>, TError = unknown>(
  params: EncodeTestParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof encodeTest>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof encodeTest>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useEncodeTest<TData = Awaited<ReturnType<typeof encodeTest>>, TError = unknown>(
  params: EncodeTestParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof encodeTest>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof encodeTest>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useEncodeTest<TData = Awaited<ReturnType<typeof encodeTest>>, TError = unknown>(
  params: EncodeTestParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof encodeTest>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary (í…ŒìŠ¤íŠ¸ ì¢…ë£Œì‹œ ì‚­ì œ ì˜ˆì •) ì•”í˜¸í™” ë³µí˜¸í™” í…ŒìŠ¤íŠ¸
 */

export function useEncodeTest<TData = Awaited<ReturnType<typeof encodeTest>>, TError = unknown>(
  params: EncodeTestParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof encodeTest>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getEncodeTestQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAllOptions = (
  params?: GetAllOptionsParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListAbusingReportOptionResult>(
    { url: `/m/test/auth-check`, method: 'GET', params, signal },
    options,
  );
};

export const getGetAllOptionsQueryKey = (params?: GetAllOptionsParams) => {
  return [`/m/test/auth-check`, ...(params ? [params] : [])] as const;
};

export const getGetAllOptionsQueryOptions = <TData = Awaited<ReturnType<typeof getAllOptions>>, TError = unknown>(
  params?: GetAllOptionsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllOptions>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllOptionsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllOptions>>> = ({ signal }) =>
    getAllOptions(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllOptions>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetAllOptionsQueryResult = NonNullable<Awaited<ReturnType<typeof getAllOptions>>>;
export type GetAllOptionsQueryError = unknown;

export function useGetAllOptions<TData = Awaited<ReturnType<typeof getAllOptions>>, TError = unknown>(
  params: undefined | GetAllOptionsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllOptions>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getAllOptions>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetAllOptions<TData = Awaited<ReturnType<typeof getAllOptions>>, TError = unknown>(
  params?: GetAllOptionsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllOptions>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getAllOptions>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetAllOptions<TData = Awaited<ReturnType<typeof getAllOptions>>, TError = unknown>(
  params?: GetAllOptionsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllOptions>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

export function useGetAllOptions<TData = Awaited<ReturnType<typeof getAllOptions>>, TError = unknown>(
  params?: GetAllOptionsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllOptions>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetAllOptionsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * í—¤ë”ë¡œ ì „ë‹¬ ëœ í† í°ìœ¼ë¡œ ì‚¬ìš©ìì˜ ì •ë³´ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary ê³„ì • ë° í”„ë¡œí•„ ì •ë³´ ì¡°íšŒ
 */
export const getProfile = (options?: SecondParameter<typeof customFetcher>, signal?: AbortSignal) => {
  return customFetcher<ApiResponseAccountResultV2>({ url: `/m/member/info`, method: 'GET', signal }, options);
};

export const getGetProfileQueryKey = () => {
  return [`/m/member/info`] as const;
};

export const getGetProfileQueryOptions = <TData = Awaited<ReturnType<typeof getProfile>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetProfileQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProfile>>> = ({ signal }) =>
    getProfile(requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getProfile>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetProfileQueryResult = NonNullable<Awaited<ReturnType<typeof getProfile>>>;
export type GetProfileQueryError = unknown;

export function useGetProfile<TData = Awaited<ReturnType<typeof getProfile>>, TError = unknown>(options: {
  query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>> &
    Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>, 'initialData'>;
  request?: SecondParameter<typeof customFetcher>;
}): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetProfile<TData = Awaited<ReturnType<typeof getProfile>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>> &
    Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>, 'initialData'>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetProfile<TData = Awaited<ReturnType<typeof getProfile>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ê³„ì • ë° í”„ë¡œí•„ ì •ë³´ ì¡°íšŒ
 */

export function useGetProfile<TData = Awaited<ReturnType<typeof getProfile>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetProfileQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * í”„ë¡œí•„ëª…ìœ¼ë¡œ ì´ë¦„ì„ ì‚¬ìš©í•  ìˆ˜ ìˆì„ì§€ í™•ì¸í•©ë‹ˆë‹¤. ì‘ë‹µì´ 404ë©´ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤.
 * @summary (ê°€ì…ìš©)í”„ë¡œí•„ëª… ì¡°íšŒ
 */
export const existedByName = (name: string, options?: SecondParameter<typeof customFetcher>, signal?: AbortSignal) => {
  return customFetcher<ApiResponseString>(
    { url: `/m/member/existed-by-profile-name/${name}`, method: 'GET', signal },
    options,
  );
};

export const getExistedByNameQueryKey = (name: string) => {
  return [`/m/member/existed-by-profile-name/${name}`] as const;
};

export const getExistedByNameQueryOptions = <TData = Awaited<ReturnType<typeof existedByName>>, TError = unknown>(
  name: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof existedByName>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getExistedByNameQueryKey(name);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof existedByName>>> = ({ signal }) =>
    existedByName(name, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!name, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof existedByName>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type ExistedByNameQueryResult = NonNullable<Awaited<ReturnType<typeof existedByName>>>;
export type ExistedByNameQueryError = unknown;

export function useExistedByName<TData = Awaited<ReturnType<typeof existedByName>>, TError = unknown>(
  name: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof existedByName>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof existedByName>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useExistedByName<TData = Awaited<ReturnType<typeof existedByName>>, TError = unknown>(
  name: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof existedByName>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof existedByName>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useExistedByName<TData = Awaited<ReturnType<typeof existedByName>>, TError = unknown>(
  name: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof existedByName>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary (ê°€ì…ìš©)í”„ë¡œí•„ëª… ì¡°íšŒ
 */

export function useExistedByName<TData = Awaited<ReturnType<typeof existedByName>>, TError = unknown>(
  name: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof existedByName>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getExistedByNameQueryOptions(name, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * í”„ë¡œí•„ëª…ì„ ê²€ìƒ‰í•´ì„œ ì´ë¯¸ ì‚¬ìš©ì¤‘ì´ë©´ true, ì—†ëŠ” í”„ë¡œí•„ëª…ì´ë©´ falseë¡œ ì‘ë‹µí•©ë‹ˆë‹¤.
 * @summary (ê°€ì…ìš©)í”„ë¡œí•„ëª… ì¡°íšŒ
 */
export const existedByNameV2 = (
  name: string,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseBoolean>(
    { url: `/m/member/existed-by-profile-name-v2/${name}`, method: 'GET', signal },
    options,
  );
};

export const getExistedByNameV2QueryKey = (name: string) => {
  return [`/m/member/existed-by-profile-name-v2/${name}`] as const;
};

export const getExistedByNameV2QueryOptions = <TData = Awaited<ReturnType<typeof existedByNameV2>>, TError = unknown>(
  name: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof existedByNameV2>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getExistedByNameV2QueryKey(name);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof existedByNameV2>>> = ({ signal }) =>
    existedByNameV2(name, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!name, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof existedByNameV2>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type ExistedByNameV2QueryResult = NonNullable<Awaited<ReturnType<typeof existedByNameV2>>>;
export type ExistedByNameV2QueryError = unknown;

export function useExistedByNameV2<TData = Awaited<ReturnType<typeof existedByNameV2>>, TError = unknown>(
  name: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof existedByNameV2>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof existedByNameV2>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useExistedByNameV2<TData = Awaited<ReturnType<typeof existedByNameV2>>, TError = unknown>(
  name: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof existedByNameV2>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof existedByNameV2>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useExistedByNameV2<TData = Awaited<ReturnType<typeof existedByNameV2>>, TError = unknown>(
  name: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof existedByNameV2>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary (ê°€ì…ìš©)í”„ë¡œí•„ëª… ì¡°íšŒ
 */

export function useExistedByNameV2<TData = Awaited<ReturnType<typeof existedByNameV2>>, TError = unknown>(
  name: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof existedByNameV2>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getExistedByNameV2QueryOptions(name, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ì„œë²„ì—ì„œ ì„¤ì •í•œ ê¸°ë³¸ ì‚¬ì§„ë“¤ì„ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary ê¸°ë³¸ í”„ë¡œí•„ ì‚¬ì§„ ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ
 */
export const getAllPhotos = (options?: SecondParameter<typeof customFetcher>, signal?: AbortSignal) => {
  return customFetcher<ApiResponseListBasicProfilePhotoResult>(
    { url: `/m/member/basic-profile-photo`, method: 'GET', signal },
    options,
  );
};

export const getGetAllPhotosQueryKey = () => {
  return [`/m/member/basic-profile-photo`] as const;
};

export const getGetAllPhotosQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllPhotos>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllPhotos>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllPhotosQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllPhotos>>> = ({ signal }) =>
    getAllPhotos(requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllPhotos>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetAllPhotosQueryResult = NonNullable<Awaited<ReturnType<typeof getAllPhotos>>>;
export type GetAllPhotosQueryError = unknown;

export function useGetAllPhotos<TData = Awaited<ReturnType<typeof getAllPhotos>>, TError = unknown>(options: {
  query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllPhotos>>, TError, TData>> &
    Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getAllPhotos>>, TError, TData>, 'initialData'>;
  request?: SecondParameter<typeof customFetcher>;
}): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetAllPhotos<TData = Awaited<ReturnType<typeof getAllPhotos>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllPhotos>>, TError, TData>> &
    Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getAllPhotos>>, TError, TData>, 'initialData'>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetAllPhotos<TData = Awaited<ReturnType<typeof getAllPhotos>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllPhotos>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ê¸°ë³¸ í”„ë¡œí•„ ì‚¬ì§„ ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ
 */

export function useGetAllPhotos<TData = Awaited<ReturnType<typeof getAllPhotos>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllPhotos>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetAllPhotosQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ë†€ì´ê³„íšì„ idë¡œ ì¡°íšŒ í•©ë‹ˆë‹¤.
 * @summary ë†€ì´ê³„íš ì¡°íšŒ
 */
export const getLecturePlan = (
  lecturePlanId: number,
  params?: GetLecturePlanParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseLecturePlanResult>(
    { url: `/m/lecture-plan/${lecturePlanId}`, method: 'GET', params, signal },
    options,
  );
};

export const getGetLecturePlanQueryKey = (lecturePlanId: number, params?: GetLecturePlanParams) => {
  return [`/m/lecture-plan/${lecturePlanId}`, ...(params ? [params] : [])] as const;
};

export const getGetLecturePlanQueryOptions = <TData = Awaited<ReturnType<typeof getLecturePlan>>, TError = unknown>(
  lecturePlanId: number,
  params?: GetLecturePlanParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlan>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetLecturePlanQueryKey(lecturePlanId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLecturePlan>>> = ({ signal }) =>
    getLecturePlan(lecturePlanId, params, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!lecturePlanId, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getLecturePlan>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetLecturePlanQueryResult = NonNullable<Awaited<ReturnType<typeof getLecturePlan>>>;
export type GetLecturePlanQueryError = unknown;

export function useGetLecturePlan<TData = Awaited<ReturnType<typeof getLecturePlan>>, TError = unknown>(
  lecturePlanId: number,
  params: undefined | GetLecturePlanParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlan>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getLecturePlan>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetLecturePlan<TData = Awaited<ReturnType<typeof getLecturePlan>>, TError = unknown>(
  lecturePlanId: number,
  params?: GetLecturePlanParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlan>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getLecturePlan>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetLecturePlan<TData = Awaited<ReturnType<typeof getLecturePlan>>, TError = unknown>(
  lecturePlanId: number,
  params?: GetLecturePlanParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlan>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ë†€ì´ê³„íš ì¡°íšŒ
 */

export function useGetLecturePlan<TData = Awaited<ReturnType<typeof getLecturePlan>>, TError = unknown>(
  lecturePlanId: number,
  params?: GetLecturePlanParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlan>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetLecturePlanQueryOptions(lecturePlanId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ì‹œìŠ¤í…œì—ì„œ ì„¤ì •í•œ ì¶”ì²œí‚¤ì›Œë“œë‚˜ ê¸°ê°„ë³„ ìƒíƒœì— ë”°ë¼ì„œ ìì‹ ì˜ ìë£Œì¤‘ì—ì„œ ì¶”ì²œí•  ìë£Œë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary (ë†€ì´ ê³„íš)í•˜ë‹¨ ë‚´ ìë£Œ ì¶”ì²œ ì¡°íšŒ.
 */
export const getRecommendPlansFromMyItems = (
  lecturePlanId: number,
  params?: GetRecommendPlansFromMyItemsParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/m/lecture-plan/${lecturePlanId}/recommend/user-items`, method: 'GET', params, signal },
    options,
  );
};

export const getGetRecommendPlansFromMyItemsQueryKey = (
  lecturePlanId: number,
  params?: GetRecommendPlansFromMyItemsParams,
) => {
  return [`/m/lecture-plan/${lecturePlanId}/recommend/user-items`, ...(params ? [params] : [])] as const;
};

export const getGetRecommendPlansFromMyItemsQueryOptions = <
  TData = Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>,
  TError = unknown,
>(
  lecturePlanId: number,
  params?: GetRecommendPlansFromMyItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRecommendPlansFromMyItemsQueryKey(lecturePlanId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>> = ({ signal }) =>
    getRecommendPlansFromMyItems(lecturePlanId, params, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!lecturePlanId, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetRecommendPlansFromMyItemsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>
>;
export type GetRecommendPlansFromMyItemsQueryError = unknown;

export function useGetRecommendPlansFromMyItems<
  TData = Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>,
  TError = unknown,
>(
  lecturePlanId: number,
  params: undefined | GetRecommendPlansFromMyItemsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetRecommendPlansFromMyItems<
  TData = Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>,
  TError = unknown,
>(
  lecturePlanId: number,
  params?: GetRecommendPlansFromMyItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetRecommendPlansFromMyItems<
  TData = Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>,
  TError = unknown,
>(
  lecturePlanId: number,
  params?: GetRecommendPlansFromMyItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary (ë†€ì´ ê³„íš)í•˜ë‹¨ ë‚´ ìë£Œ ì¶”ì²œ ì¡°íšŒ.
 */

export function useGetRecommendPlansFromMyItems<
  TData = Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>,
  TError = unknown,
>(
  lecturePlanId: number,
  params?: GetRecommendPlansFromMyItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetRecommendPlansFromMyItemsQueryOptions(lecturePlanId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ì‚¬ìš©ìì˜ í”„ë¡œí•„ idë¡œ ë†€ì´ê³„íšëª©ë¡ì„ ì¡°íšŒ í•©ë‹ˆë‹¤.
 * @summary ì‚¬ìš©ì í”„ë¡œí•„ idë¡œ ë†€ì´ê³„íš ëª©ë¡ ì¡°íšŒ
 */
export const getLecturePlanList = (
  params?: GetLecturePlanListParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListLecturePlanResult>(
    { url: `/m/lecture-plan/list`, method: 'GET', params, signal },
    options,
  );
};

export const getGetLecturePlanListQueryKey = (params?: GetLecturePlanListParams) => {
  return [`/m/lecture-plan/list`, ...(params ? [params] : [])] as const;
};

export const getGetLecturePlanListQueryOptions = <
  TData = Awaited<ReturnType<typeof getLecturePlanList>>,
  TError = unknown,
>(
  params?: GetLecturePlanListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlanList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetLecturePlanListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLecturePlanList>>> = ({ signal }) =>
    getLecturePlanList(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getLecturePlanList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetLecturePlanListQueryResult = NonNullable<Awaited<ReturnType<typeof getLecturePlanList>>>;
export type GetLecturePlanListQueryError = unknown;

export function useGetLecturePlanList<TData = Awaited<ReturnType<typeof getLecturePlanList>>, TError = unknown>(
  params: undefined | GetLecturePlanListParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlanList>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getLecturePlanList>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetLecturePlanList<TData = Awaited<ReturnType<typeof getLecturePlanList>>, TError = unknown>(
  params?: GetLecturePlanListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlanList>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getLecturePlanList>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetLecturePlanList<TData = Awaited<ReturnType<typeof getLecturePlanList>>, TError = unknown>(
  params?: GetLecturePlanListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlanList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ì‚¬ìš©ì í”„ë¡œí•„ idë¡œ ë†€ì´ê³„íš ëª©ë¡ ì¡°íšŒ
 */

export function useGetLecturePlanList<TData = Awaited<ReturnType<typeof getLecturePlanList>>, TError = unknown>(
  params?: GetLecturePlanListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlanList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetLecturePlanListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ìë£Œë³´ë“œì˜ ìë£Œ idë¥¼ ì´ìš©í•´ì„œ ìë£Œì˜ ì„¸ë¶€ì •ë³´ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary íŒŒì¼ì˜ ìƒì„¸ë³´ê¸° êµ¬í˜„ì„ ìœ„í•´ ì¡°íšŒí•˜ëŠ” api
 */
export const getSmartFolderItemInfo = (
  params: GetSmartFolderItemInfoParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseSmartFolderItemDetailedResult>(
    { url: `/m/file/detailed-info`, method: 'GET', params, signal },
    options,
  );
};

export const getGetSmartFolderItemInfoQueryKey = (params: GetSmartFolderItemInfoParams) => {
  return [`/m/file/detailed-info`, ...(params ? [params] : [])] as const;
};

export const getGetSmartFolderItemInfoQueryOptions = <
  TData = Awaited<ReturnType<typeof getSmartFolderItemInfo>>,
  TError = unknown,
>(
  params: GetSmartFolderItemInfoParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItemInfo>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSmartFolderItemInfoQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSmartFolderItemInfo>>> = ({ signal }) =>
    getSmartFolderItemInfo(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSmartFolderItemInfo>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetSmartFolderItemInfoQueryResult = NonNullable<Awaited<ReturnType<typeof getSmartFolderItemInfo>>>;
export type GetSmartFolderItemInfoQueryError = unknown;

export function useGetSmartFolderItemInfo<TData = Awaited<ReturnType<typeof getSmartFolderItemInfo>>, TError = unknown>(
  params: GetSmartFolderItemInfoParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItemInfo>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getSmartFolderItemInfo>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetSmartFolderItemInfo<TData = Awaited<ReturnType<typeof getSmartFolderItemInfo>>, TError = unknown>(
  params: GetSmartFolderItemInfoParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItemInfo>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getSmartFolderItemInfo>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetSmartFolderItemInfo<TData = Awaited<ReturnType<typeof getSmartFolderItemInfo>>, TError = unknown>(
  params: GetSmartFolderItemInfoParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItemInfo>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary íŒŒì¼ì˜ ìƒì„¸ë³´ê¸° êµ¬í˜„ì„ ìœ„í•´ ì¡°íšŒí•˜ëŠ” api
 */

export function useGetSmartFolderItemInfo<TData = Awaited<ReturnType<typeof getSmartFolderItemInfo>>, TError = unknown>(
  params: GetSmartFolderItemInfoParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItemInfo>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetSmartFolderItemInfoQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ì‚¬ìš©ìì˜ idë‚˜ ì½”ë“œë¡œ ë“±ë¡ëœ ë°˜ ë¦¬ìŠ¤íŠ¸ë¥¼ ì–»ìŠµë‹ˆë‹¤.
 * @summary ì‚¬ìš©ìì˜ ë°˜ ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ
 */
export const getEducationalClasses = (
  params?: GetEducationalClassesParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListEducationalClassResult>(
    { url: `/m/educational-class/educational-classes`, method: 'GET', params, signal },
    options,
  );
};

export const getGetEducationalClassesQueryKey = (params?: GetEducationalClassesParams) => {
  return [`/m/educational-class/educational-classes`, ...(params ? [params] : [])] as const;
};

export const getGetEducationalClassesQueryOptions = <
  TData = Awaited<ReturnType<typeof getEducationalClasses>>,
  TError = unknown,
>(
  params?: GetEducationalClassesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getEducationalClasses>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetEducationalClassesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getEducationalClasses>>> = ({ signal }) =>
    getEducationalClasses(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getEducationalClasses>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetEducationalClassesQueryResult = NonNullable<Awaited<ReturnType<typeof getEducationalClasses>>>;
export type GetEducationalClassesQueryError = unknown;

export function useGetEducationalClasses<TData = Awaited<ReturnType<typeof getEducationalClasses>>, TError = unknown>(
  params: undefined | GetEducationalClassesParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getEducationalClasses>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getEducationalClasses>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetEducationalClasses<TData = Awaited<ReturnType<typeof getEducationalClasses>>, TError = unknown>(
  params?: GetEducationalClassesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getEducationalClasses>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getEducationalClasses>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetEducationalClasses<TData = Awaited<ReturnType<typeof getEducationalClasses>>, TError = unknown>(
  params?: GetEducationalClassesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getEducationalClasses>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ì‚¬ìš©ìì˜ ë°˜ ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ
 */

export function useGetEducationalClasses<TData = Awaited<ReturnType<typeof getEducationalClasses>>, TError = unknown>(
  params?: GetEducationalClassesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getEducationalClasses>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetEducationalClassesQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ì‚¬ìš©ìì˜ idë‚˜ ì½”ë“œë¡œ ë“±ë¡ëœ ê¸°ë³¸ë°˜ ì •ë³´ë¥¼ ì–»ìŠµë‹ˆë‹¤.
 * @summary ì‚¬ìš©ìì˜ ê¸°ë³¸ë°˜ ì •ë³´ ì¡°íšŒ
 */
export const getBasicEducationalClass = (
  params?: GetBasicEducationalClassParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseEducationalClassResult>(
    { url: `/m/educational-class/basic-educational-class`, method: 'GET', params, signal },
    options,
  );
};

export const getGetBasicEducationalClassQueryKey = (params?: GetBasicEducationalClassParams) => {
  return [`/m/educational-class/basic-educational-class`, ...(params ? [params] : [])] as const;
};

export const getGetBasicEducationalClassQueryOptions = <
  TData = Awaited<ReturnType<typeof getBasicEducationalClass>>,
  TError = unknown,
>(
  params?: GetBasicEducationalClassParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getBasicEducationalClass>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetBasicEducationalClassQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getBasicEducationalClass>>> = ({ signal }) =>
    getBasicEducationalClass(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getBasicEducationalClass>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetBasicEducationalClassQueryResult = NonNullable<Awaited<ReturnType<typeof getBasicEducationalClass>>>;
export type GetBasicEducationalClassQueryError = unknown;

export function useGetBasicEducationalClass<
  TData = Awaited<ReturnType<typeof getBasicEducationalClass>>,
  TError = unknown,
>(
  params: undefined | GetBasicEducationalClassParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getBasicEducationalClass>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getBasicEducationalClass>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetBasicEducationalClass<
  TData = Awaited<ReturnType<typeof getBasicEducationalClass>>,
  TError = unknown,
>(
  params?: GetBasicEducationalClassParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getBasicEducationalClass>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getBasicEducationalClass>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetBasicEducationalClass<
  TData = Awaited<ReturnType<typeof getBasicEducationalClass>>,
  TError = unknown,
>(
  params?: GetBasicEducationalClassParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getBasicEducationalClass>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ì‚¬ìš©ìì˜ ê¸°ë³¸ë°˜ ì •ë³´ ì¡°íšŒ
 */

export function useGetBasicEducationalClass<
  TData = Awaited<ReturnType<typeof getBasicEducationalClass>>,
  TError = unknown,
>(
  params?: GetBasicEducationalClassParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getBasicEducationalClass>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetBasicEducationalClassQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * idë¡œ ë²¡í„° ì •ë³´ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary idë¡œ ì¡°íšŒ
 */
export const getStudentFaceVector = (
  id: number,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseStudentFaceVectorResult>(
    { url: `/api/student-feature-vector/${id}`, method: 'GET', signal },
    options,
  );
};

export const getGetStudentFaceVectorQueryKey = (id: number) => {
  return [`/api/student-feature-vector/${id}`] as const;
};

export const getGetStudentFaceVectorQueryOptions = <
  TData = Awaited<ReturnType<typeof getStudentFaceVector>>,
  TError = unknown,
>(
  id: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentFaceVector>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStudentFaceVectorQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getStudentFaceVector>>> = ({ signal }) =>
    getStudentFaceVector(id, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!id, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getStudentFaceVector>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetStudentFaceVectorQueryResult = NonNullable<Awaited<ReturnType<typeof getStudentFaceVector>>>;
export type GetStudentFaceVectorQueryError = unknown;

export function useGetStudentFaceVector<TData = Awaited<ReturnType<typeof getStudentFaceVector>>, TError = unknown>(
  id: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentFaceVector>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getStudentFaceVector>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetStudentFaceVector<TData = Awaited<ReturnType<typeof getStudentFaceVector>>, TError = unknown>(
  id: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentFaceVector>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getStudentFaceVector>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetStudentFaceVector<TData = Awaited<ReturnType<typeof getStudentFaceVector>>, TError = unknown>(
  id: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentFaceVector>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary idë¡œ ì¡°íšŒ
 */

export function useGetStudentFaceVector<TData = Awaited<ReturnType<typeof getStudentFaceVector>>, TError = unknown>(
  id: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentFaceVector>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetStudentFaceVectorQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ì „ì²´ ì •ë³´ë¥¼ ì–»ê±°ë‚˜ ì•„ì´ ë¶„ë¥˜ìš”ì²­ì‹œ ì „ë‹¬í•˜ëŠ” profileCodeë¡œ ì‚¬ìš©ìê°€ ë“±ë¡í•œ ì•„ì´ ë¦¬ìŠ¤íŠ¸ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary ì•„ì´ ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ
 */
export const getStudentFaceVectorList = (
  params?: GetStudentFaceVectorListParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListStudentFaceVectorResult>(
    { url: `/api/student-feature-vector/list`, method: 'GET', params, signal },
    options,
  );
};

export const getGetStudentFaceVectorListQueryKey = (params?: GetStudentFaceVectorListParams) => {
  return [`/api/student-feature-vector/list`, ...(params ? [params] : [])] as const;
};

export const getGetStudentFaceVectorListQueryOptions = <
  TData = Awaited<ReturnType<typeof getStudentFaceVectorList>>,
  TError = unknown,
>(
  params?: GetStudentFaceVectorListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentFaceVectorList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStudentFaceVectorListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getStudentFaceVectorList>>> = ({ signal }) =>
    getStudentFaceVectorList(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getStudentFaceVectorList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetStudentFaceVectorListQueryResult = NonNullable<Awaited<ReturnType<typeof getStudentFaceVectorList>>>;
export type GetStudentFaceVectorListQueryError = unknown;

export function useGetStudentFaceVectorList<
  TData = Awaited<ReturnType<typeof getStudentFaceVectorList>>,
  TError = unknown,
>(
  params: undefined | GetStudentFaceVectorListParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentFaceVectorList>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getStudentFaceVectorList>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetStudentFaceVectorList<
  TData = Awaited<ReturnType<typeof getStudentFaceVectorList>>,
  TError = unknown,
>(
  params?: GetStudentFaceVectorListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentFaceVectorList>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getStudentFaceVectorList>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetStudentFaceVectorList<
  TData = Awaited<ReturnType<typeof getStudentFaceVectorList>>,
  TError = unknown,
>(
  params?: GetStudentFaceVectorListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentFaceVectorList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary ì•„ì´ ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ
 */

export function useGetStudentFaceVectorList<
  TData = Awaited<ReturnType<typeof getStudentFaceVectorList>>,
  TError = unknown,
>(
  params?: GetStudentFaceVectorListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentFaceVectorList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetStudentFaceVectorListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}
