/**
 * Generated by orval v7.4.1 🍺
 * Do not edit manually.
 * Ai and Proxy API
 * isd / kinder board api doc
 * OpenAPI spec version: v1.1.0
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';
import type {
  AIMaskingReqeust,
  AccountWithdrawRequest,
  AiBlurReqeust,
  ApiResponseAccountResultV2,
  ApiResponseAiEvaluationContentsResult,
  ApiResponseAuthSessionResult,
  ApiResponseBoolean,
  ApiResponseDriveItemResult,
  ApiResponseEducationalClassResult,
  ApiResponseLecturePlanReportCreateSubjectAndEtcWithAiResponse,
  ApiResponseLecturePlanResult,
  ApiResponseListAbusingReportOptionResult,
  ApiResponseListBasicProfilePhotoResult,
  ApiResponseListCdnFileResult,
  ApiResponseListDouble,
  ApiResponseListEducationalClassResult,
  ApiResponseListFileObjectResult,
  ApiResponseListLecturePlanResult,
  ApiResponseListSmartFolderItemResult,
  ApiResponseListSmartFolderResult,
  ApiResponseListString,
  ApiResponseListStudentFaceVectorResult,
  ApiResponseListStudentResult,
  ApiResponseProfileResult,
  ApiResponseSimilarityResult,
  ApiResponseSmartFolderItemDetailedResult,
  ApiResponseSmartFolderItemResult,
  ApiResponseSmsUserValidateSendResponse,
  ApiResponseString,
  ApiResponseStudentFaceVectorResult,
  ApiResponseStudentRecordCreateAiObservationResult,
  ApiResponseStudentResult,
  ApiResponseTitleAndContents,
  ApiResponseUserValidationCodeState,
  DriveItemKeysReqeust,
  EducationalClassUpdateRequest,
  EncodeTestParams,
  FileObjectUploadRequestDto,
  GetAllOptionsParams,
  GetBasicEducationalClassParams,
  GetEducationalClassByIdParams,
  GetEducationalClassesParams,
  GetFaceVectorParams,
  GetLecturePlanListParams,
  GetLecturePlanParams,
  GetRecommendPlansFromMyItemsParams,
  GetSmartFolderItemInfoParams,
  GetStudentFaceVectorListParams,
  GetStudentParams,
  GetStudentsParams,
  GetUploadedFileDeprecatedParams,
  GetUploadedFilesParams,
  LecturePlanCreateWithAiRequest,
  LecturePlanReportCreatePhotoCaptionWithAiRequest,
  LecturePlanReportCreateSubjectAndEtcWithAiRequest,
  MobileAccountJoinWithPhoneRequest,
  MobileAccountUpdateRequestV2,
  MobileCdnFileDownloadRequest,
  MobileChangeAccountPasswordRequest,
  MobileEducationalClassAddRequest,
  MobileMemoFileCreateRequest,
  MobileMemoFileUpdateRequest,
  MobileResetPasswordRequest,
  MobileSignInWithPhoneRequest,
  MobileUpdateTaggedStudentRequestDto,
  MobileUploadCompleteRequest,
  ProfileModifyPhotoRequest,
  SmsUserValidateRequest,
  SmsUserValidateSendRequest,
  StudentAddRequest,
  StudentMoveRequest,
  StudentRecordAiRecreateRequest,
  StudentRecordCreateAiObservationRequest,
  StudentUpdateRequest,
  StudentVectorAddRequest,
  StudentVectorDeleteRequest,
  StudentVectorUpdateRequest,
  TestTwoDriveItemKeysReqeust,
  TimeEncodeParams,
} from './schemas';
import { customFetcher } from '../custom-fetcher';

type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1];

/**
 * 토큰을 갱신하거나, 현재 토큰을 사용할 수 있는지 확인합니다.
 * @summary 토큰 조회 or 갱신
 */
export const refreshToken = (token: string, options?: SecondParameter<typeof customFetcher>) => {
  return customFetcher<ApiResponseAuthSessionResult>(
    { url: `/m/member/refresh-token/${token}`, method: 'PUT' },
    options,
  );
};

export const getRefreshTokenMutationOptions = <
  TData = Awaited<ReturnType<typeof refreshToken>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { token: string }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['refreshToken'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof refreshToken>>, { token: string }> = (props) => {
    const { token } = props ?? {};

    return refreshToken(token, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError, { token: string }, TContext>;
};

export type RefreshTokenMutationResult = NonNullable<Awaited<ReturnType<typeof refreshToken>>>;

export type RefreshTokenMutationError = unknown;

/**
 * @summary 토큰 조회 or 갱신
 */
export const useRefreshToken = <
  TData = Awaited<ReturnType<typeof refreshToken>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { token: string }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { token: string }, TContext> => {
  const mutationOptions = getRefreshTokenMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * 사진을 업로드하고, 업로드 완료한 fileObject의 id로 프로필 사진을 변경합니다.
 * @summary 프로필 사진 등록(변경)
 */
export const modifyPhoto = (
  profileModifyPhotoRequest: ProfileModifyPhotoRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseProfileResult>(
    {
      url: `/m/member/profile/photo`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: profileModifyPhotoRequest,
    },
    options,
  );
};

export const getModifyPhotoMutationOptions = <
  TData = Awaited<ReturnType<typeof modifyPhoto>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: ProfileModifyPhotoRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['modifyPhoto'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof modifyPhoto>>, { data: ProfileModifyPhotoRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return modifyPhoto(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: ProfileModifyPhotoRequest },
    TContext
  >;
};

export type ModifyPhotoMutationResult = NonNullable<Awaited<ReturnType<typeof modifyPhoto>>>;
export type ModifyPhotoMutationBody = ProfileModifyPhotoRequest;
export type ModifyPhotoMutationError = unknown;

/**
 * @summary 프로필 사진 등록(변경)
 */
export const useModifyPhoto = <
  TData = Awaited<ReturnType<typeof modifyPhoto>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: ProfileModifyPhotoRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: ProfileModifyPhotoRequest }, TContext> => {
  const mutationOptions = getModifyPhotoMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * 인증받은 전화번호로 비밀번호를 변경하는 api 입니다.
 * @summary 비밀번호 재설정(찾기용)
 */
export const resetPassword = (
  mobileResetPasswordRequest: MobileResetPasswordRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseString>(
    {
      url: `/m/member/accounts/reset-password`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: mobileResetPasswordRequest,
    },
    options,
  );
};

export const getResetPasswordMutationOptions = <
  TData = Awaited<ReturnType<typeof resetPassword>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileResetPasswordRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['resetPassword'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof resetPassword>>,
    { data: MobileResetPasswordRequest }
  > = (props) => {
    const { data } = props ?? {};

    return resetPassword(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: MobileResetPasswordRequest },
    TContext
  >;
};

export type ResetPasswordMutationResult = NonNullable<Awaited<ReturnType<typeof resetPassword>>>;
export type ResetPasswordMutationBody = MobileResetPasswordRequest;
export type ResetPasswordMutationError = unknown;

/**
 * @summary 비밀번호 재설정(찾기용)
 */
export const useResetPassword = <
  TData = Awaited<ReturnType<typeof resetPassword>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileResetPasswordRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: MobileResetPasswordRequest }, TContext> => {
  const mutationOptions = getResetPasswordMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * 토큰으로 사용자를 체크해서 비밀번호를 변경하는 api 입니다.
 * @summary 비밀번호 변경
 */
export const changePassword = (
  mobileChangeAccountPasswordRequest: MobileChangeAccountPasswordRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseString>(
    {
      url: `/m/member/accounts/change-password`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: mobileChangeAccountPasswordRequest,
    },
    options,
  );
};

export const getChangePasswordMutationOptions = <
  TData = Awaited<ReturnType<typeof changePassword>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileChangeAccountPasswordRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['changePassword'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof changePassword>>,
    { data: MobileChangeAccountPasswordRequest }
  > = (props) => {
    const { data } = props ?? {};

    return changePassword(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: MobileChangeAccountPasswordRequest },
    TContext
  >;
};

export type ChangePasswordMutationResult = NonNullable<Awaited<ReturnType<typeof changePassword>>>;
export type ChangePasswordMutationBody = MobileChangeAccountPasswordRequest;
export type ChangePasswordMutationError = unknown;

/**
 * @summary 비밀번호 변경
 */
export const useChangePassword = <
  TData = Awaited<ReturnType<typeof changePassword>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileChangeAccountPasswordRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: MobileChangeAccountPasswordRequest }, TContext> => {
  const mutationOptions = getChangePasswordMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * 회원 및 프로필 정보를 수정합니다.
 * @summary 회원+프로필 정보 수정
 */
export const updateAccountInfo = (
  mobileAccountUpdateRequestV2: MobileAccountUpdateRequestV2,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseAccountResultV2>(
    {
      url: `/m/member/account`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: mobileAccountUpdateRequestV2,
    },
    options,
  );
};

export const getUpdateAccountInfoMutationOptions = <
  TData = Awaited<ReturnType<typeof updateAccountInfo>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileAccountUpdateRequestV2 }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['updateAccountInfo'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateAccountInfo>>,
    { data: MobileAccountUpdateRequestV2 }
  > = (props) => {
    const { data } = props ?? {};

    return updateAccountInfo(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: MobileAccountUpdateRequestV2 },
    TContext
  >;
};

export type UpdateAccountInfoMutationResult = NonNullable<Awaited<ReturnType<typeof updateAccountInfo>>>;
export type UpdateAccountInfoMutationBody = MobileAccountUpdateRequestV2;
export type UpdateAccountInfoMutationError = unknown;

/**
 * @summary 회원+프로필 정보 수정
 */
export const useUpdateAccountInfo = <
  TData = Awaited<ReturnType<typeof updateAccountInfo>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileAccountUpdateRequestV2 }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: MobileAccountUpdateRequestV2 }, TContext> => {
  const mutationOptions = getUpdateAccountInfoMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * S3에 업로드를 완료하면 source : FILE의 id를 mainFileObjectId에 보내주시면 됩니다. source가 THUMBNAIL이나 PROFILE일 경우 단순 완료처리라 thumbnailObjectId에 넣지마시고 mainFileObjectId에 아이디 전달해주시면 되며, 더미데이터가 내려갑니다.
 * @summary [업로드 완료] presigned url에 업로드 완료후 콜백 api
 */
export const uploadCompletedForUpload = (
  mobileUploadCompleteRequest: MobileUploadCompleteRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseDriveItemResult>(
    {
      url: `/m/file/upload-completed`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: mobileUploadCompleteRequest,
    },
    options,
  );
};

export const getUploadCompletedForUploadMutationOptions = <
  TData = Awaited<ReturnType<typeof uploadCompletedForUpload>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileUploadCompleteRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['uploadCompletedForUpload'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof uploadCompletedForUpload>>,
    { data: MobileUploadCompleteRequest }
  > = (props) => {
    const { data } = props ?? {};

    return uploadCompletedForUpload(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: MobileUploadCompleteRequest },
    TContext
  >;
};

export type UploadCompletedForUploadMutationResult = NonNullable<Awaited<ReturnType<typeof uploadCompletedForUpload>>>;
export type UploadCompletedForUploadMutationBody = MobileUploadCompleteRequest;
export type UploadCompletedForUploadMutationError = unknown;

/**
 * @summary [업로드 완료] presigned url에 업로드 완료후 콜백 api
 */
export const useUploadCompletedForUpload = <
  TData = Awaited<ReturnType<typeof uploadCompletedForUpload>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileUploadCompleteRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: MobileUploadCompleteRequest }, TContext> => {
  const mutationOptions = getUploadCompletedForUploadMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * 메모 파일을 수정합니다.
 * @summary 메모 파일을 수정하는 api
 */
export const updateMemoFile = (
  mobileMemoFileUpdateRequest: MobileMemoFileUpdateRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseSmartFolderItemResult>(
    {
      url: `/m/file/update-memo-file`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: mobileMemoFileUpdateRequest,
    },
    options,
  );
};

export const getUpdateMemoFileMutationOptions = <
  TData = Awaited<ReturnType<typeof updateMemoFile>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileMemoFileUpdateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['updateMemoFile'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateMemoFile>>,
    { data: MobileMemoFileUpdateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return updateMemoFile(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: MobileMemoFileUpdateRequest },
    TContext
  >;
};

export type UpdateMemoFileMutationResult = NonNullable<Awaited<ReturnType<typeof updateMemoFile>>>;
export type UpdateMemoFileMutationBody = MobileMemoFileUpdateRequest;
export type UpdateMemoFileMutationError = unknown;

/**
 * @summary 메모 파일을 수정하는 api
 */
export const useUpdateMemoFile = <
  TData = Awaited<ReturnType<typeof updateMemoFile>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileMemoFileUpdateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: MobileMemoFileUpdateRequest }, TContext> => {
  const mutationOptions = getUpdateMemoFileMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * 자료에 태깅된 학생 정보를 수정합니다.
 * @summary 자료에 아이 태그 수정
 */
export const updateTaggedStudent = (
  mobileUpdateTaggedStudentRequestDto: MobileUpdateTaggedStudentRequestDto,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseDriveItemResult>(
    {
      url: `/m/file/tagged-students`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: mobileUpdateTaggedStudentRequestDto,
    },
    options,
  );
};

export const getUpdateTaggedStudentMutationOptions = <
  TData = Awaited<ReturnType<typeof updateTaggedStudent>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileUpdateTaggedStudentRequestDto }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['updateTaggedStudent'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateTaggedStudent>>,
    { data: MobileUpdateTaggedStudentRequestDto }
  > = (props) => {
    const { data } = props ?? {};

    return updateTaggedStudent(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: MobileUpdateTaggedStudentRequestDto },
    TContext
  >;
};

export type UpdateTaggedStudentMutationResult = NonNullable<Awaited<ReturnType<typeof updateTaggedStudent>>>;
export type UpdateTaggedStudentMutationBody = MobileUpdateTaggedStudentRequestDto;
export type UpdateTaggedStudentMutationError = unknown;

/**
 * @summary 자료에 아이 태그 수정
 */
export const useUpdateTaggedStudent = <
  TData = Awaited<ReturnType<typeof updateTaggedStudent>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileUpdateTaggedStudentRequestDto }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: MobileUpdateTaggedStudentRequestDto }, TContext> => {
  const mutationOptions = getUpdateTaggedStudentMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * 반 정보를 아이디로 조회합니다.
 * @summary 반 아이디로 조회
 */
export const getEducationalClassById = (
  educationalClassId: number,
  params?: GetEducationalClassByIdParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseEducationalClassResult>(
    { url: `/m/educational-class/${educationalClassId}`, method: 'GET', params, signal },
    options,
  );
};

export const getGetEducationalClassByIdQueryKey = (
  educationalClassId: number,
  params?: GetEducationalClassByIdParams,
) => {
  return [`/m/educational-class/${educationalClassId}`, ...(params ? [params] : [])] as const;
};

export const getGetEducationalClassByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getEducationalClassById>>,
  TError = unknown,
>(
  educationalClassId: number,
  params?: GetEducationalClassByIdParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getEducationalClassById>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetEducationalClassByIdQueryKey(educationalClassId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getEducationalClassById>>> = ({ signal }) =>
    getEducationalClassById(educationalClassId, params, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!educationalClassId, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getEducationalClassById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetEducationalClassByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getEducationalClassById>>>;
export type GetEducationalClassByIdQueryError = unknown;

export function useGetEducationalClassById<
  TData = Awaited<ReturnType<typeof getEducationalClassById>>,
  TError = unknown,
>(
  educationalClassId: number,
  params: undefined | GetEducationalClassByIdParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getEducationalClassById>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getEducationalClassById>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetEducationalClassById<
  TData = Awaited<ReturnType<typeof getEducationalClassById>>,
  TError = unknown,
>(
  educationalClassId: number,
  params?: GetEducationalClassByIdParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getEducationalClassById>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getEducationalClassById>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetEducationalClassById<
  TData = Awaited<ReturnType<typeof getEducationalClassById>>,
  TError = unknown,
>(
  educationalClassId: number,
  params?: GetEducationalClassByIdParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getEducationalClassById>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary 반 아이디로 조회
 */

export function useGetEducationalClassById<
  TData = Awaited<ReturnType<typeof getEducationalClassById>>,
  TError = unknown,
>(
  educationalClassId: number,
  params?: GetEducationalClassByIdParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getEducationalClassById>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetEducationalClassByIdQueryOptions(educationalClassId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 반 정보를 수정합니다. 변경할 값만 전송하면 됩니다.
 * @summary 반 정보 수정
 */
export const updateEducationalClassById = (
  educationalClassId: number,
  educationalClassUpdateRequest: EducationalClassUpdateRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseEducationalClassResult>(
    {
      url: `/m/educational-class/${educationalClassId}`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: educationalClassUpdateRequest,
    },
    options,
  );
};

export const getUpdateEducationalClassByIdMutationOptions = <
  TData = Awaited<ReturnType<typeof updateEducationalClassById>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { educationalClassId: number; data: EducationalClassUpdateRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['updateEducationalClassById'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateEducationalClassById>>,
    { educationalClassId: number; data: EducationalClassUpdateRequest }
  > = (props) => {
    const { educationalClassId, data } = props ?? {};

    return updateEducationalClassById(educationalClassId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { educationalClassId: number; data: EducationalClassUpdateRequest },
    TContext
  >;
};

export type UpdateEducationalClassByIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateEducationalClassById>>
>;
export type UpdateEducationalClassByIdMutationBody = EducationalClassUpdateRequest;
export type UpdateEducationalClassByIdMutationError = unknown;

/**
 * @summary 반 정보 수정
 */
export const useUpdateEducationalClassById = <
  TData = Awaited<ReturnType<typeof updateEducationalClassById>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    TData,
    TError,
    { educationalClassId: number; data: EducationalClassUpdateRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { educationalClassId: number; data: EducationalClassUpdateRequest }, TContext> => {
  const mutationOptions = getUpdateEducationalClassByIdMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * 등록된 반 정보를 삭제합니다.
 * @summary 반 삭제
 */
export const deleteEducationalClassById = (
  educationalClassId: number,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseString>(
    { url: `/m/educational-class/${educationalClassId}`, method: 'DELETE' },
    options,
  );
};

export const getDeleteEducationalClassByIdMutationOptions = <
  TData = Awaited<ReturnType<typeof deleteEducationalClassById>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { educationalClassId: number }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['deleteEducationalClassById'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteEducationalClassById>>,
    { educationalClassId: number }
  > = (props) => {
    const { educationalClassId } = props ?? {};

    return deleteEducationalClassById(educationalClassId, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { educationalClassId: number },
    TContext
  >;
};

export type DeleteEducationalClassByIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteEducationalClassById>>
>;

export type DeleteEducationalClassByIdMutationError = unknown;

/**
 * @summary 반 삭제
 */
export const useDeleteEducationalClassById = <
  TData = Awaited<ReturnType<typeof deleteEducationalClassById>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { educationalClassId: number }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { educationalClassId: number }, TContext> => {
  const mutationOptions = getDeleteEducationalClassByIdMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * 학생 아이디로 정보를 조회합니다.
 * @summary 학생정보 조회
 */
export const getStudent = (
  studentId: number,
  params?: GetStudentParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseStudentResult>(
    { url: `/m/educational-class/student/${studentId}`, method: 'GET', params, signal },
    options,
  );
};

export const getGetStudentQueryKey = (studentId: number, params?: GetStudentParams) => {
  return [`/m/educational-class/student/${studentId}`, ...(params ? [params] : [])] as const;
};

export const getGetStudentQueryOptions = <TData = Awaited<ReturnType<typeof getStudent>>, TError = unknown>(
  studentId: number,
  params?: GetStudentParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudent>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStudentQueryKey(studentId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getStudent>>> = ({ signal }) =>
    getStudent(studentId, params, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!studentId, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getStudent>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetStudentQueryResult = NonNullable<Awaited<ReturnType<typeof getStudent>>>;
export type GetStudentQueryError = unknown;

export function useGetStudent<TData = Awaited<ReturnType<typeof getStudent>>, TError = unknown>(
  studentId: number,
  params: undefined | GetStudentParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudent>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getStudent>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetStudent<TData = Awaited<ReturnType<typeof getStudent>>, TError = unknown>(
  studentId: number,
  params?: GetStudentParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudent>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getStudent>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetStudent<TData = Awaited<ReturnType<typeof getStudent>>, TError = unknown>(
  studentId: number,
  params?: GetStudentParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudent>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary 학생정보 조회
 */

export function useGetStudent<TData = Awaited<ReturnType<typeof getStudent>>, TError = unknown>(
  studentId: number,
  params?: GetStudentParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudent>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetStudentQueryOptions(studentId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 학생 정보를 수정합니다.
 * @summary 학생정보 수정
 */
export const updateStudent = (
  studentId: number,
  studentUpdateRequest: StudentUpdateRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseStudentResult>(
    {
      url: `/m/educational-class/student/${studentId}`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: studentUpdateRequest,
    },
    options,
  );
};

export const getUpdateStudentMutationOptions = <
  TData = Awaited<ReturnType<typeof updateStudent>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { studentId: number; data: StudentUpdateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['updateStudent'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateStudent>>,
    { studentId: number; data: StudentUpdateRequest }
  > = (props) => {
    const { studentId, data } = props ?? {};

    return updateStudent(studentId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { studentId: number; data: StudentUpdateRequest },
    TContext
  >;
};

export type UpdateStudentMutationResult = NonNullable<Awaited<ReturnType<typeof updateStudent>>>;
export type UpdateStudentMutationBody = StudentUpdateRequest;
export type UpdateStudentMutationError = unknown;

/**
 * @summary 학생정보 수정
 */
export const useUpdateStudent = <
  TData = Awaited<ReturnType<typeof updateStudent>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { studentId: number; data: StudentUpdateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { studentId: number; data: StudentUpdateRequest }, TContext> => {
  const mutationOptions = getUpdateStudentMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * 학생 정보를 삭제합니다.
 * @summary 학생정보 삭제
 */
export const deleteStudent = (studentId: number, options?: SecondParameter<typeof customFetcher>) => {
  return customFetcher<ApiResponseString>(
    { url: `/m/educational-class/student/${studentId}`, method: 'DELETE' },
    options,
  );
};

export const getDeleteStudentMutationOptions = <
  TData = Awaited<ReturnType<typeof deleteStudent>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { studentId: number }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['deleteStudent'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteStudent>>, { studentId: number }> = (props) => {
    const { studentId } = props ?? {};

    return deleteStudent(studentId, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError, { studentId: number }, TContext>;
};

export type DeleteStudentMutationResult = NonNullable<Awaited<ReturnType<typeof deleteStudent>>>;

export type DeleteStudentMutationError = unknown;

/**
 * @summary 학생정보 삭제
 */
export const useDeleteStudent = <
  TData = Awaited<ReturnType<typeof deleteStudent>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { studentId: number }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { studentId: number }, TContext> => {
  const mutationOptions = getDeleteStudentMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * 학생을 다른 반으로 이동시킵니다.
 * @summary 학생정보 이동
 */
export const moveStudent = (
  studentId: number,
  studentMoveRequest: StudentMoveRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseEducationalClassResult>(
    {
      url: `/m/educational-class/student/${studentId}/move-class`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: studentMoveRequest,
    },
    options,
  );
};

export const getMoveStudentMutationOptions = <
  TData = Awaited<ReturnType<typeof moveStudent>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { studentId: number; data: StudentMoveRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['moveStudent'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof moveStudent>>,
    { studentId: number; data: StudentMoveRequest }
  > = (props) => {
    const { studentId, data } = props ?? {};

    return moveStudent(studentId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { studentId: number; data: StudentMoveRequest },
    TContext
  >;
};

export type MoveStudentMutationResult = NonNullable<Awaited<ReturnType<typeof moveStudent>>>;
export type MoveStudentMutationBody = StudentMoveRequest;
export type MoveStudentMutationError = unknown;

/**
 * @summary 학생정보 이동
 */
export const useMoveStudent = <
  TData = Awaited<ReturnType<typeof moveStudent>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { studentId: number; data: StudentMoveRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { studentId: number; data: StudentMoveRequest }, TContext> => {
  const mutationOptions = getMoveStudentMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * 학생의 벡터 정보를 수정합니다.<br>수정할 필드만 전송하시고, 수정이 필요하지 않은 필드는 null이나 아예 입력 json에서 전송하지 않으셔도 됩니다,<br>예) 이름만 수정 : {
  "id": 2,
  "name": "테스트2(수정테스트-이름만)",
  "studentId": -2
} 
 * @summary 벡터 정보 수정
 */
export const updateStudent1 = (
  studentVectorUpdateRequest: StudentVectorUpdateRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseStudentFaceVectorResult>(
    {
      url: `/api/student-feature-vector/`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: studentVectorUpdateRequest,
    },
    options,
  );
};

export const getUpdateStudent1MutationOptions = <
  TData = Awaited<ReturnType<typeof updateStudent1>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: StudentVectorUpdateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['updateStudent1'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateStudent1>>,
    { data: StudentVectorUpdateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return updateStudent1(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: StudentVectorUpdateRequest },
    TContext
  >;
};

export type UpdateStudent1MutationResult = NonNullable<Awaited<ReturnType<typeof updateStudent1>>>;
export type UpdateStudent1MutationBody = StudentVectorUpdateRequest;
export type UpdateStudent1MutationError = unknown;

/**
 * @summary 벡터 정보 수정
 */
export const useUpdateStudent1 = <
  TData = Awaited<ReturnType<typeof updateStudent1>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: StudentVectorUpdateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: StudentVectorUpdateRequest }, TContext> => {
  const mutationOptions = getUpdateStudent1MutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * 벡터정보를 새로 등록합니다. id는 자동으로 생성해서 반환합니다. <br>킨더보드에서 아이를 생성하지 않고 단순 테스트용으로 사용하실 땐 studentId를 음수로 넣어주시기 바랍니다.
 * @summary 벡터 정보 등록
 */
export const createVector = (
  studentVectorAddRequest: StudentVectorAddRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseStudentFaceVectorResult>(
    {
      url: `/api/student-feature-vector/`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: studentVectorAddRequest,
      signal,
    },
    options,
  );
};

export const getCreateVectorMutationOptions = <
  TData = Awaited<ReturnType<typeof createVector>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: StudentVectorAddRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['createVector'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof createVector>>, { data: StudentVectorAddRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return createVector(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: StudentVectorAddRequest },
    TContext
  >;
};

export type CreateVectorMutationResult = NonNullable<Awaited<ReturnType<typeof createVector>>>;
export type CreateVectorMutationBody = StudentVectorAddRequest;
export type CreateVectorMutationError = unknown;

/**
 * @summary 벡터 정보 등록
 */
export const useCreateVector = <
  TData = Awaited<ReturnType<typeof createVector>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: StudentVectorAddRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: StudentVectorAddRequest }, TContext> => {
  const mutationOptions = getCreateVectorMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * 학생 정보를 삭제합니다.
 * @summary 학생정보 삭제
 */
export const deleteStudent1 = (
  studentVectorDeleteRequest: StudentVectorDeleteRequest,
  options?: SecondParameter<typeof customFetcher>,
) => {
  return customFetcher<ApiResponseBoolean>(
    {
      url: `/api/student-feature-vector/`,
      method: 'DELETE',
      headers: { 'Content-Type': 'application/json' },
      data: studentVectorDeleteRequest,
    },
    options,
  );
};

export const getDeleteStudent1MutationOptions = <
  TData = Awaited<ReturnType<typeof deleteStudent1>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: StudentVectorDeleteRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['deleteStudent1'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteStudent1>>,
    { data: StudentVectorDeleteRequest }
  > = (props) => {
    const { data } = props ?? {};

    return deleteStudent1(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: StudentVectorDeleteRequest },
    TContext
  >;
};

export type DeleteStudent1MutationResult = NonNullable<Awaited<ReturnType<typeof deleteStudent1>>>;
export type DeleteStudent1MutationBody = StudentVectorDeleteRequest;
export type DeleteStudent1MutationError = unknown;

/**
 * @summary 학생정보 삭제
 */
export const useDeleteStudent1 = <
  TData = Awaited<ReturnType<typeof deleteStudent1>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: StudentVectorDeleteRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: StudentVectorDeleteRequest }, TContext> => {
  const mutationOptions = getDeleteStudent1MutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * sms로 인증코드를 발송합니다. (전화번호는 암호화해서, ip는 아무거나 보내셔도 됩니다.)
 * @summary 인증코드 발송 요청
 */
export const requestValidate = (
  smsUserValidateSendRequest: SmsUserValidateSendRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseSmsUserValidateSendResponse>(
    {
      url: `/m/member/validation/request`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: smsUserValidateSendRequest,
      signal,
    },
    options,
  );
};

export const getRequestValidateMutationOptions = <
  TData = Awaited<ReturnType<typeof requestValidate>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: SmsUserValidateSendRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['requestValidate'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof requestValidate>>,
    { data: SmsUserValidateSendRequest }
  > = (props) => {
    const { data } = props ?? {};

    return requestValidate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: SmsUserValidateSendRequest },
    TContext
  >;
};

export type RequestValidateMutationResult = NonNullable<Awaited<ReturnType<typeof requestValidate>>>;
export type RequestValidateMutationBody = SmsUserValidateSendRequest;
export type RequestValidateMutationError = unknown;

/**
 * @summary 인증코드 발송 요청
 */
export const useRequestValidate = <
  TData = Awaited<ReturnType<typeof requestValidate>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: SmsUserValidateSendRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: SmsUserValidateSendRequest }, TContext> => {
  const mutationOptions = getRequestValidateMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * (전화번호는 암호화해서) 인증코드와 발송한 번호로 검증을 진행합니다.
 * @summary 인증코드 발송된 인증코드를 검증하는 api
 */
export const validateCode = (
  smsUserValidateRequest: SmsUserValidateRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseUserValidationCodeState>(
    {
      url: `/m/member/validation/code`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: smsUserValidateRequest,
      signal,
    },
    options,
  );
};

export const getValidateCodeMutationOptions = <
  TData = Awaited<ReturnType<typeof validateCode>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: SmsUserValidateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['validateCode'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof validateCode>>, { data: SmsUserValidateRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return validateCode(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: SmsUserValidateRequest },
    TContext
  >;
};

export type ValidateCodeMutationResult = NonNullable<Awaited<ReturnType<typeof validateCode>>>;
export type ValidateCodeMutationBody = SmsUserValidateRequest;
export type ValidateCodeMutationError = unknown;

/**
 * @summary 인증코드 발송된 인증코드를 검증하는 api
 */
export const useValidateCode = <
  TData = Awaited<ReturnType<typeof validateCode>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: SmsUserValidateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: SmsUserValidateRequest }, TContext> => {
  const mutationOptions = getValidateCodeMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * 핸드폰 번호로 회원가입을 진행합니다.
 * @summary 회원가입
 */
export const joinWithPhone = (
  mobileAccountJoinWithPhoneRequest: MobileAccountJoinWithPhoneRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseAccountResultV2>(
    {
      url: `/m/member/sign-up`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: mobileAccountJoinWithPhoneRequest,
      signal,
    },
    options,
  );
};

export const getJoinWithPhoneMutationOptions = <
  TData = Awaited<ReturnType<typeof joinWithPhone>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileAccountJoinWithPhoneRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['joinWithPhone'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof joinWithPhone>>,
    { data: MobileAccountJoinWithPhoneRequest }
  > = (props) => {
    const { data } = props ?? {};

    return joinWithPhone(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: MobileAccountJoinWithPhoneRequest },
    TContext
  >;
};

export type JoinWithPhoneMutationResult = NonNullable<Awaited<ReturnType<typeof joinWithPhone>>>;
export type JoinWithPhoneMutationBody = MobileAccountJoinWithPhoneRequest;
export type JoinWithPhoneMutationError = unknown;

/**
 * @summary 회원가입
 */
export const useJoinWithPhone = <
  TData = Awaited<ReturnType<typeof joinWithPhone>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileAccountJoinWithPhoneRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: MobileAccountJoinWithPhoneRequest }, TContext> => {
  const mutationOptions = getJoinWithPhoneMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * 번호와 비밀번호로 로그인하고 토큰을 얻는 api입니다.1개 계정으로 최대 3개의 서로 다른 디바이스에서 인증 세션을 유지할 수 있으므로 4번째 로그인부터는 다음 순서로 세션이 종료된다.
  1. 인증 세션이 만료된 것
  2. 만료된 세션이 여러 개라면, 만료 시점이 오래된 순서로
  3. 만료된 세션이 없다면 만료 시점이 가까운 순서로
 * @summary 번호로 로그인 하는 api
 */
export const signin = (
  mobileSignInWithPhoneRequest: MobileSignInWithPhoneRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseAuthSessionResult>(
    {
      url: `/m/member/sign-in`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: mobileSignInWithPhoneRequest,
      signal,
    },
    options,
  );
};

export const getSigninMutationOptions = <
  TData = Awaited<ReturnType<typeof signin>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileSignInWithPhoneRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['signin'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof signin>>, { data: MobileSignInWithPhoneRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return signin(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: MobileSignInWithPhoneRequest },
    TContext
  >;
};

export type SigninMutationResult = NonNullable<Awaited<ReturnType<typeof signin>>>;
export type SigninMutationBody = MobileSignInWithPhoneRequest;
export type SigninMutationError = unknown;

/**
 * @summary 번호로 로그인 하는 api
 */
export const useSignin = <TData = Awaited<ReturnType<typeof signin>>, TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileSignInWithPhoneRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: MobileSignInWithPhoneRequest }, TContext> => {
  const mutationOptions = getSigninMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * 탈퇴 요청하는 api 입니다. 토큰과 입력한 프로필 id로 1차 유효성 검사를 합니다.
 * @summary 탈퇴 요청(일단 로그만 쌓기)
 */
export const requestWithdraw = (
  accountWithdrawRequest: AccountWithdrawRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseString>(
    {
      url: `/m/member/accounts/withdraw`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: accountWithdrawRequest,
      signal,
    },
    options,
  );
};

export const getRequestWithdrawMutationOptions = <
  TData = Awaited<ReturnType<typeof requestWithdraw>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: AccountWithdrawRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['requestWithdraw'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof requestWithdraw>>, { data: AccountWithdrawRequest }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return requestWithdraw(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: AccountWithdrawRequest },
    TContext
  >;
};

export type RequestWithdrawMutationResult = NonNullable<Awaited<ReturnType<typeof requestWithdraw>>>;
export type RequestWithdrawMutationBody = AccountWithdrawRequest;
export type RequestWithdrawMutationError = unknown;

/**
 * @summary 탈퇴 요청(일단 로그만 쌓기)
 */
export const useRequestWithdraw = <
  TData = Awaited<ReturnType<typeof requestWithdraw>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: AccountWithdrawRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: AccountWithdrawRequest }, TContext> => {
  const mutationOptions = getRequestWithdrawMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * 모바일에서 업로드한 자료 리스트를 조회하는 api 입니다.
 * @summary 기록보기 api (모바일에서 올린 자료들 리스트 조회)
 */
export const getUploadedFiles = (
  params?: GetUploadedFilesParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/m/file/uploaded-items`, method: 'GET', params, signal },
    options,
  );
};

export const getGetUploadedFilesQueryKey = (params?: GetUploadedFilesParams) => {
  return [`/m/file/uploaded-items`, ...(params ? [params] : [])] as const;
};

export const getGetUploadedFilesQueryOptions = <TData = Awaited<ReturnType<typeof getUploadedFiles>>, TError = unknown>(
  params?: GetUploadedFilesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUploadedFiles>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUploadedFilesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUploadedFiles>>> = ({ signal }) =>
    getUploadedFiles(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUploadedFiles>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetUploadedFilesQueryResult = NonNullable<Awaited<ReturnType<typeof getUploadedFiles>>>;
export type GetUploadedFilesQueryError = unknown;

export function useGetUploadedFiles<TData = Awaited<ReturnType<typeof getUploadedFiles>>, TError = unknown>(
  params: undefined | GetUploadedFilesParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUploadedFiles>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getUploadedFiles>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetUploadedFiles<TData = Awaited<ReturnType<typeof getUploadedFiles>>, TError = unknown>(
  params?: GetUploadedFilesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUploadedFiles>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getUploadedFiles>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetUploadedFiles<TData = Awaited<ReturnType<typeof getUploadedFiles>>, TError = unknown>(
  params?: GetUploadedFilesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUploadedFiles>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary 기록보기 api (모바일에서 올린 자료들 리스트 조회)
 */

export function useGetUploadedFiles<TData = Awaited<ReturnType<typeof getUploadedFiles>>, TError = unknown>(
  params?: GetUploadedFilesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUploadedFiles>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetUploadedFilesQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 모바일에서 업로드한 자료 리스트를 조회하는 api 입니다.
 * @summary [삭제예정]기록보기 api (모바일에서 올린 자료들 리스트 조회)
 */
export const getUploadedFileDeprecated = (
  params?: GetUploadedFileDeprecatedParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/m/file/uploaded-items`, method: 'POST', params, signal },
    options,
  );
};

export const getGetUploadedFileDeprecatedMutationOptions = <
  TData = Awaited<ReturnType<typeof getUploadedFileDeprecated>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { params?: GetUploadedFileDeprecatedParams }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['getUploadedFileDeprecated'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof getUploadedFileDeprecated>>,
    { params?: GetUploadedFileDeprecatedParams }
  > = (props) => {
    const { params } = props ?? {};

    return getUploadedFileDeprecated(params, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { params?: GetUploadedFileDeprecatedParams },
    TContext
  >;
};

export type GetUploadedFileDeprecatedMutationResult = NonNullable<
  Awaited<ReturnType<typeof getUploadedFileDeprecated>>
>;

export type GetUploadedFileDeprecatedMutationError = unknown;

/**
 * @summary [삭제예정]기록보기 api (모바일에서 올린 자료들 리스트 조회)
 */
export const useGetUploadedFileDeprecated = <
  TData = Awaited<ReturnType<typeof getUploadedFileDeprecated>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { params?: GetUploadedFileDeprecatedParams }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { params?: GetUploadedFileDeprecatedParams }, TContext> => {
  const mutationOptions = getGetUploadedFileDeprecatedMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * 업로드 하기위해서 url을 요청합니다. result로 온 source : FILE의 id를 업로드 완료 요청에 보내주셔야하고, presignedUrl에 업로드하시면 됩니다.
 * @summary [업로드 전]s3에 업로드할 presigned url 요청 api
 */
export const uploadPrepareForApi = (
  fileObjectUploadRequestDto: FileObjectUploadRequestDto[],
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListFileObjectResult>(
    {
      url: `/m/file/request-presinged-url`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: fileObjectUploadRequestDto,
      signal,
    },
    options,
  );
};

export const getUploadPrepareForApiMutationOptions = <
  TData = Awaited<ReturnType<typeof uploadPrepareForApi>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: FileObjectUploadRequestDto[] }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['uploadPrepareForApi'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof uploadPrepareForApi>>,
    { data: FileObjectUploadRequestDto[] }
  > = (props) => {
    const { data } = props ?? {};

    return uploadPrepareForApi(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: FileObjectUploadRequestDto[] },
    TContext
  >;
};

export type UploadPrepareForApiMutationResult = NonNullable<Awaited<ReturnType<typeof uploadPrepareForApi>>>;
export type UploadPrepareForApiMutationBody = FileObjectUploadRequestDto[];
export type UploadPrepareForApiMutationError = unknown;

/**
 * @summary [업로드 전]s3에 업로드할 presigned url 요청 api
 */
export const useUploadPrepareForApi = <
  TData = Awaited<ReturnType<typeof uploadPrepareForApi>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: FileObjectUploadRequestDto[] }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: FileObjectUploadRequestDto[] }, TContext> => {
  const mutationOptions = getUploadPrepareForApiMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * 원본 미리보기에 사용할 presigned url를 요청하는 api 입니다.
 * @summary 자료의 프리뷰용 링크 요청
 */
export const getCdnFilesForPreviewV2 = (
  mobileCdnFileDownloadRequest: MobileCdnFileDownloadRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListCdnFileResult>(
    {
      url: `/m/file/preview-presigned-urls`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: mobileCdnFileDownloadRequest,
      signal,
    },
    options,
  );
};

export const getGetCdnFilesForPreviewV2MutationOptions = <
  TData = Awaited<ReturnType<typeof getCdnFilesForPreviewV2>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileCdnFileDownloadRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['getCdnFilesForPreviewV2'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof getCdnFilesForPreviewV2>>,
    { data: MobileCdnFileDownloadRequest }
  > = (props) => {
    const { data } = props ?? {};

    return getCdnFilesForPreviewV2(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: MobileCdnFileDownloadRequest },
    TContext
  >;
};

export type GetCdnFilesForPreviewV2MutationResult = NonNullable<Awaited<ReturnType<typeof getCdnFilesForPreviewV2>>>;
export type GetCdnFilesForPreviewV2MutationBody = MobileCdnFileDownloadRequest;
export type GetCdnFilesForPreviewV2MutationError = unknown;

/**
 * @summary 자료의 프리뷰용 링크 요청
 */
export const useGetCdnFilesForPreviewV2 = <
  TData = Awaited<ReturnType<typeof getCdnFilesForPreviewV2>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileCdnFileDownloadRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: MobileCdnFileDownloadRequest }, TContext> => {
  const mutationOptions = getGetCdnFilesForPreviewV2MutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * 원본 자료를 다운 받을 수 있는 presigned url를 요청하는 api 입니다.
 * @summary (공개자료용)자료의 다운로드 링크 요청
 */
export const getCdnFilesForDownloadV2 = (
  mobileCdnFileDownloadRequest: MobileCdnFileDownloadRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListCdnFileResult>(
    {
      url: `/m/file/download-presigned-urls`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: mobileCdnFileDownloadRequest,
      signal,
    },
    options,
  );
};

export const getGetCdnFilesForDownloadV2MutationOptions = <
  TData = Awaited<ReturnType<typeof getCdnFilesForDownloadV2>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileCdnFileDownloadRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['getCdnFilesForDownloadV2'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof getCdnFilesForDownloadV2>>,
    { data: MobileCdnFileDownloadRequest }
  > = (props) => {
    const { data } = props ?? {};

    return getCdnFilesForDownloadV2(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: MobileCdnFileDownloadRequest },
    TContext
  >;
};

export type GetCdnFilesForDownloadV2MutationResult = NonNullable<Awaited<ReturnType<typeof getCdnFilesForDownloadV2>>>;
export type GetCdnFilesForDownloadV2MutationBody = MobileCdnFileDownloadRequest;
export type GetCdnFilesForDownloadV2MutationError = unknown;

/**
 * @summary (공개자료용)자료의 다운로드 링크 요청
 */
export const useGetCdnFilesForDownloadV2 = <
  TData = Awaited<ReturnType<typeof getCdnFilesForDownloadV2>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileCdnFileDownloadRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: MobileCdnFileDownloadRequest }, TContext> => {
  const mutationOptions = getGetCdnFilesForDownloadV2MutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * 새 메모 파일을 등록합니다.
 * @summary 메모 파일을 생성하는 api
 */
export const createMemoFile = (
  mobileMemoFileCreateRequest: MobileMemoFileCreateRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseSmartFolderItemResult>(
    {
      url: `/m/file/create-memo-file`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: mobileMemoFileCreateRequest,
      signal,
    },
    options,
  );
};

export const getCreateMemoFileMutationOptions = <
  TData = Awaited<ReturnType<typeof createMemoFile>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileMemoFileCreateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['createMemoFile'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createMemoFile>>,
    { data: MobileMemoFileCreateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createMemoFile(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: MobileMemoFileCreateRequest },
    TContext
  >;
};

export type CreateMemoFileMutationResult = NonNullable<Awaited<ReturnType<typeof createMemoFile>>>;
export type CreateMemoFileMutationBody = MobileMemoFileCreateRequest;
export type CreateMemoFileMutationError = unknown;

/**
 * @summary 메모 파일을 생성하는 api
 */
export const useCreateMemoFile = <
  TData = Awaited<ReturnType<typeof createMemoFile>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileMemoFileCreateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: MobileMemoFileCreateRequest }, TContext> => {
  const mutationOptions = getCreateMemoFileMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * 반에 등록된 학생들을 조회합니다.
 * @summary 반에 등록된 학생들 조회.
 */
export const getStudents = (
  educationalClassId: number,
  params?: GetStudentsParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListStudentResult>(
    { url: `/m/educational-class/${educationalClassId}/students`, method: 'GET', params, signal },
    options,
  );
};

export const getGetStudentsQueryKey = (educationalClassId: number, params?: GetStudentsParams) => {
  return [`/m/educational-class/${educationalClassId}/students`, ...(params ? [params] : [])] as const;
};

export const getGetStudentsQueryOptions = <TData = Awaited<ReturnType<typeof getStudents>>, TError = unknown>(
  educationalClassId: number,
  params?: GetStudentsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudents>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStudentsQueryKey(educationalClassId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getStudents>>> = ({ signal }) =>
    getStudents(educationalClassId, params, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!educationalClassId, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getStudents>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetStudentsQueryResult = NonNullable<Awaited<ReturnType<typeof getStudents>>>;
export type GetStudentsQueryError = unknown;

export function useGetStudents<TData = Awaited<ReturnType<typeof getStudents>>, TError = unknown>(
  educationalClassId: number,
  params: undefined | GetStudentsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudents>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getStudents>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetStudents<TData = Awaited<ReturnType<typeof getStudents>>, TError = unknown>(
  educationalClassId: number,
  params?: GetStudentsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudents>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getStudents>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetStudents<TData = Awaited<ReturnType<typeof getStudents>>, TError = unknown>(
  educationalClassId: number,
  params?: GetStudentsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudents>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary 반에 등록된 학생들 조회.
 */

export function useGetStudents<TData = Awaited<ReturnType<typeof getStudents>>, TError = unknown>(
  educationalClassId: number,
  params?: GetStudentsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudents>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetStudentsQueryOptions(educationalClassId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 반에 새로운 학생을 등록합니다.등록 완료시 전달받은 id로와 학생 이름으로 [POST] /file/v1/smart-folder/photo/student/add-folder 를 호출해주셔야 합니다.
 * @summary 반에 아이/학생을 추가합니다.
 */
export const addStudent = (
  educationalClassId: number,
  studentAddRequest: StudentAddRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseStudentResult>(
    {
      url: `/m/educational-class/${educationalClassId}/students`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: studentAddRequest,
      signal,
    },
    options,
  );
};

export const getAddStudentMutationOptions = <
  TData = Awaited<ReturnType<typeof addStudent>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { educationalClassId: number; data: StudentAddRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['addStudent'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addStudent>>,
    { educationalClassId: number; data: StudentAddRequest }
  > = (props) => {
    const { educationalClassId, data } = props ?? {};

    return addStudent(educationalClassId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { educationalClassId: number; data: StudentAddRequest },
    TContext
  >;
};

export type AddStudentMutationResult = NonNullable<Awaited<ReturnType<typeof addStudent>>>;
export type AddStudentMutationBody = StudentAddRequest;
export type AddStudentMutationError = unknown;

/**
 * @summary 반에 아이/학생을 추가합니다.
 */
export const useAddStudent = <
  TData = Awaited<ReturnType<typeof addStudent>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { educationalClassId: number; data: StudentAddRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { educationalClassId: number; data: StudentAddRequest }, TContext> => {
  const mutationOptions = getAddStudentMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * 반 정보를 신규로 등록합니다.
 * @summary 반 신규 등록
 */
export const addEducationalClass = (
  mobileEducationalClassAddRequest: MobileEducationalClassAddRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseEducationalClassResult>(
    {
      url: `/m/educational-class/add-educational-class`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: mobileEducationalClassAddRequest,
      signal,
    },
    options,
  );
};

export const getAddEducationalClassMutationOptions = <
  TData = Awaited<ReturnType<typeof addEducationalClass>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileEducationalClassAddRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['addEducationalClass'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addEducationalClass>>,
    { data: MobileEducationalClassAddRequest }
  > = (props) => {
    const { data } = props ?? {};

    return addEducationalClass(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: MobileEducationalClassAddRequest },
    TContext
  >;
};

export type AddEducationalClassMutationResult = NonNullable<Awaited<ReturnType<typeof addEducationalClass>>>;
export type AddEducationalClassMutationBody = MobileEducationalClassAddRequest;
export type AddEducationalClassMutationError = unknown;

/**
 * @summary 반 신규 등록
 */
export const useAddEducationalClass = <
  TData = Awaited<ReturnType<typeof addEducationalClass>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: MobileEducationalClassAddRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: MobileEducationalClassAddRequest }, TContext> => {
  const mutationOptions = getAddEducationalClassMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * 두 이미지에서 얼굴의 유사도를 확인
 * @summary [테스트]이미지 얼굴 유사도 체크
 */
export const testSimilarity = (
  testTwoDriveItemKeysReqeust: TestTwoDriveItemKeysReqeust,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseSimilarityResult>(
    {
      url: `/ai/v1/test/similarity`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: testTwoDriveItemKeysReqeust,
      signal,
    },
    options,
  );
};

export const getTestSimilarityMutationOptions = <
  TData = Awaited<ReturnType<typeof testSimilarity>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: TestTwoDriveItemKeysReqeust }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['testSimilarity'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof testSimilarity>>,
    { data: TestTwoDriveItemKeysReqeust }
  > = (props) => {
    const { data } = props ?? {};

    return testSimilarity(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: TestTwoDriveItemKeysReqeust },
    TContext
  >;
};

export type TestSimilarityMutationResult = NonNullable<Awaited<ReturnType<typeof testSimilarity>>>;
export type TestSimilarityMutationBody = TestTwoDriveItemKeysReqeust;
export type TestSimilarityMutationError = unknown;

/**
 * @summary [테스트]이미지 얼굴 유사도 체크
 */
export const useTestSimilarity = <
  TData = Awaited<ReturnType<typeof testSimilarity>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: TestTwoDriveItemKeysReqeust }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: TestTwoDriveItemKeysReqeust }, TContext> => {
  const mutationOptions = getTestSimilarityMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * 사진에 달린 내용들과 주제 키워드로 주제, 목표, 교사지원 내용을 생성합니다. 테스트로 캐시를 응답할 시, 10초 이내로 응답합니다.(랜덤)
 * @summary 놀이보고 내용 생성(주제, 목표, 교사지원)
 */
export const createReport = (
  lecturePlanReportCreateSubjectAndEtcWithAiRequest: LecturePlanReportCreateSubjectAndEtcWithAiRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseLecturePlanReportCreateSubjectAndEtcWithAiResponse>(
    {
      url: `/ai/v1/report`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: lecturePlanReportCreateSubjectAndEtcWithAiRequest,
      signal,
    },
    options,
  );
};

export const getCreateReportMutationOptions = <
  TData = Awaited<ReturnType<typeof createReport>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: LecturePlanReportCreateSubjectAndEtcWithAiRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['createReport'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createReport>>,
    { data: LecturePlanReportCreateSubjectAndEtcWithAiRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createReport(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: LecturePlanReportCreateSubjectAndEtcWithAiRequest },
    TContext
  >;
};

export type CreateReportMutationResult = NonNullable<Awaited<ReturnType<typeof createReport>>>;
export type CreateReportMutationBody = LecturePlanReportCreateSubjectAndEtcWithAiRequest;
export type CreateReportMutationError = unknown;

/**
 * @summary 놀이보고 내용 생성(주제, 목표, 교사지원)
 */
export const useCreateReport = <
  TData = Awaited<ReturnType<typeof createReport>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: LecturePlanReportCreateSubjectAndEtcWithAiRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: LecturePlanReportCreateSubjectAndEtcWithAiRequest }, TContext> => {
  const mutationOptions = getCreateReportMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * 사진에 넣을 캡션을 생성합니다. 테스트로 캐시를 응답할 시, 10초 이내로 응답합니다.(랜덤)
 * @summary 놀이보고 사진의 캡션 생성
 */
export const createPhotoCaption = (
  lecturePlanReportCreatePhotoCaptionWithAiRequest: LecturePlanReportCreatePhotoCaptionWithAiRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseTitleAndContents>(
    {
      url: `/ai/v1/report/photo-caption`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: lecturePlanReportCreatePhotoCaptionWithAiRequest,
      signal,
    },
    options,
  );
};

export const getCreatePhotoCaptionMutationOptions = <
  TData = Awaited<ReturnType<typeof createPhotoCaption>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: LecturePlanReportCreatePhotoCaptionWithAiRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['createPhotoCaption'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createPhotoCaption>>,
    { data: LecturePlanReportCreatePhotoCaptionWithAiRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createPhotoCaption(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: LecturePlanReportCreatePhotoCaptionWithAiRequest },
    TContext
  >;
};

export type CreatePhotoCaptionMutationResult = NonNullable<Awaited<ReturnType<typeof createPhotoCaption>>>;
export type CreatePhotoCaptionMutationBody = LecturePlanReportCreatePhotoCaptionWithAiRequest;
export type CreatePhotoCaptionMutationError = unknown;

/**
 * @summary 놀이보고 사진의 캡션 생성
 */
export const useCreatePhotoCaption = <
  TData = Awaited<ReturnType<typeof createPhotoCaption>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: LecturePlanReportCreatePhotoCaptionWithAiRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: LecturePlanReportCreatePhotoCaptionWithAiRequest }, TContext> => {
  const mutationOptions = getCreatePhotoCaptionMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * 전달된 자료 키들로 배경을 제거하고 처리된 자료 리스트를 응답으로 전달합니다.
 * @summary 배경지우기 처리
 */
export const removeBackground = (
  aiBlurReqeust: AiBlurReqeust,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    {
      url: `/ai/v1/remove-background`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: aiBlurReqeust,
      signal,
    },
    options,
  );
};

export const getRemoveBackgroundMutationOptions = <
  TData = Awaited<ReturnType<typeof removeBackground>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: AiBlurReqeust }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['removeBackground'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeBackground>>, { data: AiBlurReqeust }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return removeBackground(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError, { data: AiBlurReqeust }, TContext>;
};

export type RemoveBackgroundMutationResult = NonNullable<Awaited<ReturnType<typeof removeBackground>>>;
export type RemoveBackgroundMutationBody = AiBlurReqeust;
export type RemoveBackgroundMutationError = unknown;

/**
 * @summary 배경지우기 처리
 */
export const useRemoveBackground = <
  TData = Awaited<ReturnType<typeof removeBackground>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: AiBlurReqeust }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: AiBlurReqeust }, TContext> => {
  const mutationOptions = getRemoveBackgroundMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * 평가한 점수로 관찰기록내용을 생성합니다. 테스트로 캐시를 응답할 시, 10초 이내로 응답합니다.(랜덤)
 * @summary 관찰기록 내용 생성
 */
export const createObservation = (
  studentRecordCreateAiObservationRequest: StudentRecordCreateAiObservationRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseStudentRecordCreateAiObservationResult>(
    {
      url: `/ai/v1/observation`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: studentRecordCreateAiObservationRequest,
      signal,
    },
    options,
  );
};

export const getCreateObservationMutationOptions = <
  TData = Awaited<ReturnType<typeof createObservation>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: StudentRecordCreateAiObservationRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['createObservation'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createObservation>>,
    { data: StudentRecordCreateAiObservationRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createObservation(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: StudentRecordCreateAiObservationRequest },
    TContext
  >;
};

export type CreateObservationMutationResult = NonNullable<Awaited<ReturnType<typeof createObservation>>>;
export type CreateObservationMutationBody = StudentRecordCreateAiObservationRequest;
export type CreateObservationMutationError = unknown;

/**
 * @summary 관찰기록 내용 생성
 */
export const useCreateObservation = <
  TData = Awaited<ReturnType<typeof createObservation>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: StudentRecordCreateAiObservationRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: StudentRecordCreateAiObservationRequest }, TContext> => {
  const mutationOptions = getCreateObservationMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * 기존내용으로 새 관찰기록을 생성한다.
 * @summary 관찰기록 내용 재생성
 */
export const recreateObservation = (
  studentRecordAiRecreateRequest: StudentRecordAiRecreateRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseAiEvaluationContentsResult>(
    {
      url: `/ai/v1/observation/recreate`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: studentRecordAiRecreateRequest,
      signal,
    },
    options,
  );
};

export const getRecreateObservationMutationOptions = <
  TData = Awaited<ReturnType<typeof recreateObservation>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: StudentRecordAiRecreateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['recreateObservation'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof recreateObservation>>,
    { data: StudentRecordAiRecreateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return recreateObservation(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: StudentRecordAiRecreateRequest },
    TContext
  >;
};

export type RecreateObservationMutationResult = NonNullable<Awaited<ReturnType<typeof recreateObservation>>>;
export type RecreateObservationMutationBody = StudentRecordAiRecreateRequest;
export type RecreateObservationMutationError = unknown;

/**
 * @summary 관찰기록 내용 재생성
 */
export const useRecreateObservation = <
  TData = Awaited<ReturnType<typeof recreateObservation>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: StudentRecordAiRecreateRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: StudentRecordAiRecreateRequest }, TContext> => {
  const mutationOptions = getRecreateObservationMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * 전달된 자료 키들로 마스킹처리를하고 처리된 자료 리스트를 응답으로 전달합니다.
 * @summary 사진 스마일 마스킹 처리
 */
export const maskingFaces = (
  aIMaskingReqeust: AIMaskingReqeust,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    {
      url: `/ai/v1/masking/all`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: aIMaskingReqeust,
      signal,
    },
    options,
  );
};

export const getMaskingFacesMutationOptions = <
  TData = Awaited<ReturnType<typeof maskingFaces>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: AIMaskingReqeust }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['maskingFaces'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof maskingFaces>>, { data: AIMaskingReqeust }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return maskingFaces(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError, { data: AIMaskingReqeust }, TContext>;
};

export type MaskingFacesMutationResult = NonNullable<Awaited<ReturnType<typeof maskingFaces>>>;
export type MaskingFacesMutationBody = AIMaskingReqeust;
export type MaskingFacesMutationError = unknown;

/**
 * @summary 사진 스마일 마스킹 처리
 */
export const useMaskingFaces = <
  TData = Awaited<ReturnType<typeof maskingFaces>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: AIMaskingReqeust }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: AIMaskingReqeust }, TContext> => {
  const mutationOptions = getMaskingFacesMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * ai가 놀이카드를 생성해줍니다.
 * @summary 놀이계획(놀이카드) 생성
 */
export const createLecturePlan = (
  lecturePlanCreateWithAiRequest: LecturePlanCreateWithAiRequest,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListLecturePlanResult>(
    {
      url: `/ai/v1/lecturePlan`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: lecturePlanCreateWithAiRequest,
      signal,
    },
    options,
  );
};

export const getCreateLecturePlanMutationOptions = <
  TData = Awaited<ReturnType<typeof createLecturePlan>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: LecturePlanCreateWithAiRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['createLecturePlan'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createLecturePlan>>,
    { data: LecturePlanCreateWithAiRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createLecturePlan(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: LecturePlanCreateWithAiRequest },
    TContext
  >;
};

export type CreateLecturePlanMutationResult = NonNullable<Awaited<ReturnType<typeof createLecturePlan>>>;
export type CreateLecturePlanMutationBody = LecturePlanCreateWithAiRequest;
export type CreateLecturePlanMutationError = unknown;

/**
 * @summary 놀이계획(놀이카드) 생성
 */
export const useCreateLecturePlan = <
  TData = Awaited<ReturnType<typeof createLecturePlan>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: LecturePlanCreateWithAiRequest }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: LecturePlanCreateWithAiRequest }, TContext> => {
  const mutationOptions = getCreateLecturePlanMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * 입력한 사진에서 얼굴 벡터를 얻습니다.
 * @summary 이미지 얼굴 벡터 조회
 */
export const getFaceVector = (
  params: GetFaceVectorParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListDouble>({ url: `/ai/v1/face-vector`, method: 'POST', params, signal }, options);
};

export const getGetFaceVectorMutationOptions = <
  TData = Awaited<ReturnType<typeof getFaceVector>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { params: GetFaceVectorParams }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['getFaceVector'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof getFaceVector>>, { params: GetFaceVectorParams }> = (
    props,
  ) => {
    const { params } = props ?? {};

    return getFaceVector(params, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { params: GetFaceVectorParams },
    TContext
  >;
};

export type GetFaceVectorMutationResult = NonNullable<Awaited<ReturnType<typeof getFaceVector>>>;

export type GetFaceVectorMutationError = unknown;

/**
 * @summary 이미지 얼굴 벡터 조회
 */
export const useGetFaceVector = <
  TData = Awaited<ReturnType<typeof getFaceVector>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { params: GetFaceVectorParams }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { params: GetFaceVectorParams }, TContext> => {
  const mutationOptions = getGetFaceVectorMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * 전달된 자료 키들로 얼굴분리를하고 처리된 자료 리스트를 응답으로 전달합니다.
 * @summary 얼굴 분리 처리
 */
export const extractFace = (
  aiBlurReqeust: AiBlurReqeust,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    {
      url: `/ai/v1/extract-face`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: aiBlurReqeust,
      signal,
    },
    options,
  );
};

export const getExtractFaceMutationOptions = <
  TData = Awaited<ReturnType<typeof extractFace>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: AiBlurReqeust }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['extractFace'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof extractFace>>, { data: AiBlurReqeust }> = (props) => {
    const { data } = props ?? {};

    return extractFace(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError, { data: AiBlurReqeust }, TContext>;
};

export type ExtractFaceMutationResult = NonNullable<Awaited<ReturnType<typeof extractFace>>>;
export type ExtractFaceMutationBody = AiBlurReqeust;
export type ExtractFaceMutationError = unknown;

/**
 * @summary 얼굴 분리 처리
 */
export const useExtractFace = <
  TData = Awaited<ReturnType<typeof extractFace>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: AiBlurReqeust }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: AiBlurReqeust }, TContext> => {
  const mutationOptions = getExtractFaceMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * 전달된 자료 키들로 아이 분류를 진행하고 분류된 폴더를 응답으로 전달합니다.
 * @summary 아이 사진 분류(리스트)
 */
export const classifyStudentWithList = (
  driveItemKeysReqeust: DriveItemKeysReqeust,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderResult>(
    {
      url: `/ai/v1/classify/students`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: driveItemKeysReqeust,
      signal,
    },
    options,
  );
};

export const getClassifyStudentWithListMutationOptions = <
  TData = Awaited<ReturnType<typeof classifyStudentWithList>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: DriveItemKeysReqeust }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['classifyStudentWithList'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof classifyStudentWithList>>,
    { data: DriveItemKeysReqeust }
  > = (props) => {
    const { data } = props ?? {};

    return classifyStudentWithList(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: DriveItemKeysReqeust },
    TContext
  >;
};

export type ClassifyStudentWithListMutationResult = NonNullable<Awaited<ReturnType<typeof classifyStudentWithList>>>;
export type ClassifyStudentWithListMutationBody = DriveItemKeysReqeust;
export type ClassifyStudentWithListMutationError = unknown;

/**
 * @summary 아이 사진 분류(리스트)
 */
export const useClassifyStudentWithList = <
  TData = Awaited<ReturnType<typeof classifyStudentWithList>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: DriveItemKeysReqeust }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: DriveItemKeysReqeust }, TContext> => {
  const mutationOptions = getClassifyStudentWithListMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * (테스트상태일때는 랜덤으로 폴더를 응답합니다.)전달된 자료 키들로 활동사진을 분류를 진행하고 분류된 폴더를 응답으로 전달합니다.
 * @summary 활동 사진 분류(리스트)
 */
export const classifyActivityPhotoWithList = (
  driveItemKeysReqeust: DriveItemKeysReqeust,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderResult>(
    {
      url: `/ai/v1/classify/activityPhotos`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: driveItemKeysReqeust,
      signal,
    },
    options,
  );
};

export const getClassifyActivityPhotoWithListMutationOptions = <
  TData = Awaited<ReturnType<typeof classifyActivityPhotoWithList>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: DriveItemKeysReqeust }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['classifyActivityPhotoWithList'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof classifyActivityPhotoWithList>>,
    { data: DriveItemKeysReqeust }
  > = (props) => {
    const { data } = props ?? {};

    return classifyActivityPhotoWithList(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<
    TData,
    TError,
    { data: DriveItemKeysReqeust },
    TContext
  >;
};

export type ClassifyActivityPhotoWithListMutationResult = NonNullable<
  Awaited<ReturnType<typeof classifyActivityPhotoWithList>>
>;
export type ClassifyActivityPhotoWithListMutationBody = DriveItemKeysReqeust;
export type ClassifyActivityPhotoWithListMutationError = unknown;

/**
 * @summary 활동 사진 분류(리스트)
 */
export const useClassifyActivityPhotoWithList = <
  TData = Awaited<ReturnType<typeof classifyActivityPhotoWithList>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: DriveItemKeysReqeust }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: DriveItemKeysReqeust }, TContext> => {
  const mutationOptions = getClassifyActivityPhotoWithListMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * 전달된 자료 키들로 블러처리를하고 블러처리된 자료 리스트를 응답으로 전달합니다.
 * @summary 사진 블러 처리
 */
export const blurFaces = (
  aiBlurReqeust: AiBlurReqeust,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    {
      url: `/ai/v1/blur/all`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: aiBlurReqeust,
      signal,
    },
    options,
  );
};

export const getBlurFacesMutationOptions = <
  TData = Awaited<ReturnType<typeof blurFaces>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: AiBlurReqeust }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const mutationKey = ['blurFaces'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof blurFaces>>, { data: AiBlurReqeust }> = (props) => {
    const { data } = props ?? {};

    return blurFaces(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError, { data: AiBlurReqeust }, TContext>;
};

export type BlurFacesMutationResult = NonNullable<Awaited<ReturnType<typeof blurFaces>>>;
export type BlurFacesMutationBody = AiBlurReqeust;
export type BlurFacesMutationError = unknown;

/**
 * @summary 사진 블러 처리
 */
export const useBlurFaces = <
  TData = Awaited<ReturnType<typeof blurFaces>>,
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<TData, TError, { data: AiBlurReqeust }, TContext>;
  request?: SecondParameter<typeof customFetcher>;
}): UseMutationResult<TData, TError, { data: AiBlurReqeust }, TContext> => {
  const mutationOptions = getBlurFacesMutationOptions(options);

  return useMutation(mutationOptions);
};

export const timeEncode = (
  params?: TimeEncodeParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseString>({ url: `/m/test/time`, method: 'GET', params, signal }, options);
};

export const getTimeEncodeQueryKey = (params?: TimeEncodeParams) => {
  return [`/m/test/time`, ...(params ? [params] : [])] as const;
};

export const getTimeEncodeQueryOptions = <TData = Awaited<ReturnType<typeof timeEncode>>, TError = unknown>(
  params?: TimeEncodeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof timeEncode>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getTimeEncodeQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof timeEncode>>> = ({ signal }) =>
    timeEncode(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof timeEncode>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type TimeEncodeQueryResult = NonNullable<Awaited<ReturnType<typeof timeEncode>>>;
export type TimeEncodeQueryError = unknown;

export function useTimeEncode<TData = Awaited<ReturnType<typeof timeEncode>>, TError = unknown>(
  params: undefined | TimeEncodeParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof timeEncode>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof timeEncode>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useTimeEncode<TData = Awaited<ReturnType<typeof timeEncode>>, TError = unknown>(
  params?: TimeEncodeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof timeEncode>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof timeEncode>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useTimeEncode<TData = Awaited<ReturnType<typeof timeEncode>>, TError = unknown>(
  params?: TimeEncodeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof timeEncode>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

export function useTimeEncode<TData = Awaited<ReturnType<typeof timeEncode>>, TError = unknown>(
  params?: TimeEncodeParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof timeEncode>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getTimeEncodeQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAllKeywords = (options?: SecondParameter<typeof customFetcher>, signal?: AbortSignal) => {
  return customFetcher<ApiResponseListString>({ url: `/m/test/non-auth-check`, method: 'GET', signal }, options);
};

export const getGetAllKeywordsQueryKey = () => {
  return [`/m/test/non-auth-check`] as const;
};

export const getGetAllKeywordsQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllKeywords>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllKeywords>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllKeywordsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllKeywords>>> = ({ signal }) =>
    getAllKeywords(requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllKeywords>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetAllKeywordsQueryResult = NonNullable<Awaited<ReturnType<typeof getAllKeywords>>>;
export type GetAllKeywordsQueryError = unknown;

export function useGetAllKeywords<TData = Awaited<ReturnType<typeof getAllKeywords>>, TError = unknown>(options: {
  query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllKeywords>>, TError, TData>> &
    Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getAllKeywords>>, TError, TData>, 'initialData'>;
  request?: SecondParameter<typeof customFetcher>;
}): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetAllKeywords<TData = Awaited<ReturnType<typeof getAllKeywords>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllKeywords>>, TError, TData>> &
    Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getAllKeywords>>, TError, TData>, 'initialData'>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetAllKeywords<TData = Awaited<ReturnType<typeof getAllKeywords>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllKeywords>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

export function useGetAllKeywords<TData = Awaited<ReturnType<typeof getAllKeywords>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllKeywords>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetAllKeywordsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 암호화 및 복호화를 테스트합니다. 개발서버에서는 추가 설명이 응답으로 내려갑니다.
 * @summary (테스트 종료시 삭제 예정) 암호화 복호화 테스트
 */
export const encodeTest = (
  params: EncodeTestParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseString>({ url: `/m/test/encode-decode`, method: 'GET', params, signal }, options);
};

export const getEncodeTestQueryKey = (params: EncodeTestParams) => {
  return [`/m/test/encode-decode`, ...(params ? [params] : [])] as const;
};

export const getEncodeTestQueryOptions = <TData = Awaited<ReturnType<typeof encodeTest>>, TError = unknown>(
  params: EncodeTestParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof encodeTest>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getEncodeTestQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof encodeTest>>> = ({ signal }) =>
    encodeTest(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof encodeTest>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type EncodeTestQueryResult = NonNullable<Awaited<ReturnType<typeof encodeTest>>>;
export type EncodeTestQueryError = unknown;

export function useEncodeTest<TData = Awaited<ReturnType<typeof encodeTest>>, TError = unknown>(
  params: EncodeTestParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof encodeTest>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof encodeTest>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useEncodeTest<TData = Awaited<ReturnType<typeof encodeTest>>, TError = unknown>(
  params: EncodeTestParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof encodeTest>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof encodeTest>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useEncodeTest<TData = Awaited<ReturnType<typeof encodeTest>>, TError = unknown>(
  params: EncodeTestParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof encodeTest>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary (테스트 종료시 삭제 예정) 암호화 복호화 테스트
 */

export function useEncodeTest<TData = Awaited<ReturnType<typeof encodeTest>>, TError = unknown>(
  params: EncodeTestParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof encodeTest>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getEncodeTestQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAllOptions = (
  params?: GetAllOptionsParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListAbusingReportOptionResult>(
    { url: `/m/test/auth-check`, method: 'GET', params, signal },
    options,
  );
};

export const getGetAllOptionsQueryKey = (params?: GetAllOptionsParams) => {
  return [`/m/test/auth-check`, ...(params ? [params] : [])] as const;
};

export const getGetAllOptionsQueryOptions = <TData = Awaited<ReturnType<typeof getAllOptions>>, TError = unknown>(
  params?: GetAllOptionsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllOptions>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllOptionsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllOptions>>> = ({ signal }) =>
    getAllOptions(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllOptions>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetAllOptionsQueryResult = NonNullable<Awaited<ReturnType<typeof getAllOptions>>>;
export type GetAllOptionsQueryError = unknown;

export function useGetAllOptions<TData = Awaited<ReturnType<typeof getAllOptions>>, TError = unknown>(
  params: undefined | GetAllOptionsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllOptions>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getAllOptions>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetAllOptions<TData = Awaited<ReturnType<typeof getAllOptions>>, TError = unknown>(
  params?: GetAllOptionsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllOptions>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getAllOptions>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetAllOptions<TData = Awaited<ReturnType<typeof getAllOptions>>, TError = unknown>(
  params?: GetAllOptionsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllOptions>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

export function useGetAllOptions<TData = Awaited<ReturnType<typeof getAllOptions>>, TError = unknown>(
  params?: GetAllOptionsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllOptions>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetAllOptionsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 헤더로 전달 된 토큰으로 사용자의 정보를 조회합니다.
 * @summary 계정 및 프로필 정보 조회
 */
export const getProfile = (options?: SecondParameter<typeof customFetcher>, signal?: AbortSignal) => {
  return customFetcher<ApiResponseAccountResultV2>({ url: `/m/member/info`, method: 'GET', signal }, options);
};

export const getGetProfileQueryKey = () => {
  return [`/m/member/info`] as const;
};

export const getGetProfileQueryOptions = <TData = Awaited<ReturnType<typeof getProfile>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetProfileQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProfile>>> = ({ signal }) =>
    getProfile(requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getProfile>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetProfileQueryResult = NonNullable<Awaited<ReturnType<typeof getProfile>>>;
export type GetProfileQueryError = unknown;

export function useGetProfile<TData = Awaited<ReturnType<typeof getProfile>>, TError = unknown>(options: {
  query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>> &
    Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>, 'initialData'>;
  request?: SecondParameter<typeof customFetcher>;
}): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetProfile<TData = Awaited<ReturnType<typeof getProfile>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>> &
    Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>, 'initialData'>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetProfile<TData = Awaited<ReturnType<typeof getProfile>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary 계정 및 프로필 정보 조회
 */

export function useGetProfile<TData = Awaited<ReturnType<typeof getProfile>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetProfileQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 프로필명으로 이름을 사용할 수 있을지 확인합니다. 응답이 404면 사용 가능합니다.
 * @summary (가입용)프로필명 조회
 */
export const existedByName = (name: string, options?: SecondParameter<typeof customFetcher>, signal?: AbortSignal) => {
  return customFetcher<ApiResponseString>(
    { url: `/m/member/existed-by-profile-name/${name}`, method: 'GET', signal },
    options,
  );
};

export const getExistedByNameQueryKey = (name: string) => {
  return [`/m/member/existed-by-profile-name/${name}`] as const;
};

export const getExistedByNameQueryOptions = <TData = Awaited<ReturnType<typeof existedByName>>, TError = unknown>(
  name: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof existedByName>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getExistedByNameQueryKey(name);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof existedByName>>> = ({ signal }) =>
    existedByName(name, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!name, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof existedByName>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type ExistedByNameQueryResult = NonNullable<Awaited<ReturnType<typeof existedByName>>>;
export type ExistedByNameQueryError = unknown;

export function useExistedByName<TData = Awaited<ReturnType<typeof existedByName>>, TError = unknown>(
  name: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof existedByName>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof existedByName>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useExistedByName<TData = Awaited<ReturnType<typeof existedByName>>, TError = unknown>(
  name: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof existedByName>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof existedByName>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useExistedByName<TData = Awaited<ReturnType<typeof existedByName>>, TError = unknown>(
  name: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof existedByName>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary (가입용)프로필명 조회
 */

export function useExistedByName<TData = Awaited<ReturnType<typeof existedByName>>, TError = unknown>(
  name: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof existedByName>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getExistedByNameQueryOptions(name, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 프로필명을 검색해서 이미 사용중이면 true, 없는 프로필명이면 false로 응답합니다.
 * @summary (가입용)프로필명 조회
 */
export const existedByNameV2 = (
  name: string,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseBoolean>(
    { url: `/m/member/existed-by-profile-name-v2/${name}`, method: 'GET', signal },
    options,
  );
};

export const getExistedByNameV2QueryKey = (name: string) => {
  return [`/m/member/existed-by-profile-name-v2/${name}`] as const;
};

export const getExistedByNameV2QueryOptions = <TData = Awaited<ReturnType<typeof existedByNameV2>>, TError = unknown>(
  name: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof existedByNameV2>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getExistedByNameV2QueryKey(name);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof existedByNameV2>>> = ({ signal }) =>
    existedByNameV2(name, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!name, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof existedByNameV2>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type ExistedByNameV2QueryResult = NonNullable<Awaited<ReturnType<typeof existedByNameV2>>>;
export type ExistedByNameV2QueryError = unknown;

export function useExistedByNameV2<TData = Awaited<ReturnType<typeof existedByNameV2>>, TError = unknown>(
  name: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof existedByNameV2>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof existedByNameV2>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useExistedByNameV2<TData = Awaited<ReturnType<typeof existedByNameV2>>, TError = unknown>(
  name: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof existedByNameV2>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof existedByNameV2>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useExistedByNameV2<TData = Awaited<ReturnType<typeof existedByNameV2>>, TError = unknown>(
  name: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof existedByNameV2>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary (가입용)프로필명 조회
 */

export function useExistedByNameV2<TData = Awaited<ReturnType<typeof existedByNameV2>>, TError = unknown>(
  name: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof existedByNameV2>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getExistedByNameV2QueryOptions(name, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 서버에서 설정한 기본 사진들을 조회합니다.
 * @summary 기본 프로필 사진 리스트 조회
 */
export const getAllPhotos = (options?: SecondParameter<typeof customFetcher>, signal?: AbortSignal) => {
  return customFetcher<ApiResponseListBasicProfilePhotoResult>(
    { url: `/m/member/basic-profile-photo`, method: 'GET', signal },
    options,
  );
};

export const getGetAllPhotosQueryKey = () => {
  return [`/m/member/basic-profile-photo`] as const;
};

export const getGetAllPhotosQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllPhotos>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllPhotos>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllPhotosQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllPhotos>>> = ({ signal }) =>
    getAllPhotos(requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllPhotos>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetAllPhotosQueryResult = NonNullable<Awaited<ReturnType<typeof getAllPhotos>>>;
export type GetAllPhotosQueryError = unknown;

export function useGetAllPhotos<TData = Awaited<ReturnType<typeof getAllPhotos>>, TError = unknown>(options: {
  query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllPhotos>>, TError, TData>> &
    Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getAllPhotos>>, TError, TData>, 'initialData'>;
  request?: SecondParameter<typeof customFetcher>;
}): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetAllPhotos<TData = Awaited<ReturnType<typeof getAllPhotos>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllPhotos>>, TError, TData>> &
    Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getAllPhotos>>, TError, TData>, 'initialData'>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetAllPhotos<TData = Awaited<ReturnType<typeof getAllPhotos>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllPhotos>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary 기본 프로필 사진 리스트 조회
 */

export function useGetAllPhotos<TData = Awaited<ReturnType<typeof getAllPhotos>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllPhotos>>, TError, TData>>;
  request?: SecondParameter<typeof customFetcher>;
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetAllPhotosQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 놀이계획을 id로 조회 합니다.
 * @summary 놀이계획 조회
 */
export const getLecturePlan = (
  lecturePlanId: number,
  params?: GetLecturePlanParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseLecturePlanResult>(
    { url: `/m/lecture-plan/${lecturePlanId}`, method: 'GET', params, signal },
    options,
  );
};

export const getGetLecturePlanQueryKey = (lecturePlanId: number, params?: GetLecturePlanParams) => {
  return [`/m/lecture-plan/${lecturePlanId}`, ...(params ? [params] : [])] as const;
};

export const getGetLecturePlanQueryOptions = <TData = Awaited<ReturnType<typeof getLecturePlan>>, TError = unknown>(
  lecturePlanId: number,
  params?: GetLecturePlanParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlan>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetLecturePlanQueryKey(lecturePlanId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLecturePlan>>> = ({ signal }) =>
    getLecturePlan(lecturePlanId, params, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!lecturePlanId, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getLecturePlan>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetLecturePlanQueryResult = NonNullable<Awaited<ReturnType<typeof getLecturePlan>>>;
export type GetLecturePlanQueryError = unknown;

export function useGetLecturePlan<TData = Awaited<ReturnType<typeof getLecturePlan>>, TError = unknown>(
  lecturePlanId: number,
  params: undefined | GetLecturePlanParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlan>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getLecturePlan>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetLecturePlan<TData = Awaited<ReturnType<typeof getLecturePlan>>, TError = unknown>(
  lecturePlanId: number,
  params?: GetLecturePlanParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlan>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getLecturePlan>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetLecturePlan<TData = Awaited<ReturnType<typeof getLecturePlan>>, TError = unknown>(
  lecturePlanId: number,
  params?: GetLecturePlanParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlan>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary 놀이계획 조회
 */

export function useGetLecturePlan<TData = Awaited<ReturnType<typeof getLecturePlan>>, TError = unknown>(
  lecturePlanId: number,
  params?: GetLecturePlanParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlan>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetLecturePlanQueryOptions(lecturePlanId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 시스템에서 설정한 추천키워드나 기간별 상태에 따라서 자신의 자료중에서 추천할 자료를 조회합니다.
 * @summary (놀이 계획)하단 내 자료 추천 조회.
 */
export const getRecommendPlansFromMyItems = (
  lecturePlanId: number,
  params?: GetRecommendPlansFromMyItemsParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListSmartFolderItemResult>(
    { url: `/m/lecture-plan/${lecturePlanId}/recommend/user-items`, method: 'GET', params, signal },
    options,
  );
};

export const getGetRecommendPlansFromMyItemsQueryKey = (
  lecturePlanId: number,
  params?: GetRecommendPlansFromMyItemsParams,
) => {
  return [`/m/lecture-plan/${lecturePlanId}/recommend/user-items`, ...(params ? [params] : [])] as const;
};

export const getGetRecommendPlansFromMyItemsQueryOptions = <
  TData = Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>,
  TError = unknown,
>(
  lecturePlanId: number,
  params?: GetRecommendPlansFromMyItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRecommendPlansFromMyItemsQueryKey(lecturePlanId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>> = ({ signal }) =>
    getRecommendPlansFromMyItems(lecturePlanId, params, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!lecturePlanId, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetRecommendPlansFromMyItemsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>
>;
export type GetRecommendPlansFromMyItemsQueryError = unknown;

export function useGetRecommendPlansFromMyItems<
  TData = Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>,
  TError = unknown,
>(
  lecturePlanId: number,
  params: undefined | GetRecommendPlansFromMyItemsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetRecommendPlansFromMyItems<
  TData = Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>,
  TError = unknown,
>(
  lecturePlanId: number,
  params?: GetRecommendPlansFromMyItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetRecommendPlansFromMyItems<
  TData = Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>,
  TError = unknown,
>(
  lecturePlanId: number,
  params?: GetRecommendPlansFromMyItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary (놀이 계획)하단 내 자료 추천 조회.
 */

export function useGetRecommendPlansFromMyItems<
  TData = Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>,
  TError = unknown,
>(
  lecturePlanId: number,
  params?: GetRecommendPlansFromMyItemsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecommendPlansFromMyItems>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetRecommendPlansFromMyItemsQueryOptions(lecturePlanId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 사용자의 프로필 id로 놀이계획목록을 조회 합니다.
 * @summary 사용자 프로필 id로 놀이계획 목록 조회
 */
export const getLecturePlanList = (
  params?: GetLecturePlanListParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListLecturePlanResult>(
    { url: `/m/lecture-plan/list`, method: 'GET', params, signal },
    options,
  );
};

export const getGetLecturePlanListQueryKey = (params?: GetLecturePlanListParams) => {
  return [`/m/lecture-plan/list`, ...(params ? [params] : [])] as const;
};

export const getGetLecturePlanListQueryOptions = <
  TData = Awaited<ReturnType<typeof getLecturePlanList>>,
  TError = unknown,
>(
  params?: GetLecturePlanListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlanList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetLecturePlanListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLecturePlanList>>> = ({ signal }) =>
    getLecturePlanList(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getLecturePlanList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetLecturePlanListQueryResult = NonNullable<Awaited<ReturnType<typeof getLecturePlanList>>>;
export type GetLecturePlanListQueryError = unknown;

export function useGetLecturePlanList<TData = Awaited<ReturnType<typeof getLecturePlanList>>, TError = unknown>(
  params: undefined | GetLecturePlanListParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlanList>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getLecturePlanList>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetLecturePlanList<TData = Awaited<ReturnType<typeof getLecturePlanList>>, TError = unknown>(
  params?: GetLecturePlanListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlanList>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getLecturePlanList>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetLecturePlanList<TData = Awaited<ReturnType<typeof getLecturePlanList>>, TError = unknown>(
  params?: GetLecturePlanListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlanList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary 사용자 프로필 id로 놀이계획 목록 조회
 */

export function useGetLecturePlanList<TData = Awaited<ReturnType<typeof getLecturePlanList>>, TError = unknown>(
  params?: GetLecturePlanListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getLecturePlanList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetLecturePlanListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 자료보드의 자료 id를 이용해서 자료의 세부정보를 조회합니다.
 * @summary 파일의 상세보기 구현을 위해 조회하는 api
 */
export const getSmartFolderItemInfo = (
  params: GetSmartFolderItemInfoParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseSmartFolderItemDetailedResult>(
    { url: `/m/file/detailed-info`, method: 'GET', params, signal },
    options,
  );
};

export const getGetSmartFolderItemInfoQueryKey = (params: GetSmartFolderItemInfoParams) => {
  return [`/m/file/detailed-info`, ...(params ? [params] : [])] as const;
};

export const getGetSmartFolderItemInfoQueryOptions = <
  TData = Awaited<ReturnType<typeof getSmartFolderItemInfo>>,
  TError = unknown,
>(
  params: GetSmartFolderItemInfoParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItemInfo>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSmartFolderItemInfoQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSmartFolderItemInfo>>> = ({ signal }) =>
    getSmartFolderItemInfo(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSmartFolderItemInfo>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetSmartFolderItemInfoQueryResult = NonNullable<Awaited<ReturnType<typeof getSmartFolderItemInfo>>>;
export type GetSmartFolderItemInfoQueryError = unknown;

export function useGetSmartFolderItemInfo<TData = Awaited<ReturnType<typeof getSmartFolderItemInfo>>, TError = unknown>(
  params: GetSmartFolderItemInfoParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItemInfo>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getSmartFolderItemInfo>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetSmartFolderItemInfo<TData = Awaited<ReturnType<typeof getSmartFolderItemInfo>>, TError = unknown>(
  params: GetSmartFolderItemInfoParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItemInfo>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getSmartFolderItemInfo>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetSmartFolderItemInfo<TData = Awaited<ReturnType<typeof getSmartFolderItemInfo>>, TError = unknown>(
  params: GetSmartFolderItemInfoParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItemInfo>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary 파일의 상세보기 구현을 위해 조회하는 api
 */

export function useGetSmartFolderItemInfo<TData = Awaited<ReturnType<typeof getSmartFolderItemInfo>>, TError = unknown>(
  params: GetSmartFolderItemInfoParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSmartFolderItemInfo>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetSmartFolderItemInfoQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 사용자의 id나 코드로 등록된 반 리스트를 얻습니다.
 * @summary 사용자의 반 리스트 조회
 */
export const getEducationalClasses = (
  params?: GetEducationalClassesParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListEducationalClassResult>(
    { url: `/m/educational-class/educational-classes`, method: 'GET', params, signal },
    options,
  );
};

export const getGetEducationalClassesQueryKey = (params?: GetEducationalClassesParams) => {
  return [`/m/educational-class/educational-classes`, ...(params ? [params] : [])] as const;
};

export const getGetEducationalClassesQueryOptions = <
  TData = Awaited<ReturnType<typeof getEducationalClasses>>,
  TError = unknown,
>(
  params?: GetEducationalClassesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getEducationalClasses>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetEducationalClassesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getEducationalClasses>>> = ({ signal }) =>
    getEducationalClasses(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getEducationalClasses>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetEducationalClassesQueryResult = NonNullable<Awaited<ReturnType<typeof getEducationalClasses>>>;
export type GetEducationalClassesQueryError = unknown;

export function useGetEducationalClasses<TData = Awaited<ReturnType<typeof getEducationalClasses>>, TError = unknown>(
  params: undefined | GetEducationalClassesParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getEducationalClasses>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getEducationalClasses>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetEducationalClasses<TData = Awaited<ReturnType<typeof getEducationalClasses>>, TError = unknown>(
  params?: GetEducationalClassesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getEducationalClasses>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getEducationalClasses>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetEducationalClasses<TData = Awaited<ReturnType<typeof getEducationalClasses>>, TError = unknown>(
  params?: GetEducationalClassesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getEducationalClasses>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary 사용자의 반 리스트 조회
 */

export function useGetEducationalClasses<TData = Awaited<ReturnType<typeof getEducationalClasses>>, TError = unknown>(
  params?: GetEducationalClassesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getEducationalClasses>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetEducationalClassesQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 사용자의 id나 코드로 등록된 기본반 정보를 얻습니다.
 * @summary 사용자의 기본반 정보 조회
 */
export const getBasicEducationalClass = (
  params?: GetBasicEducationalClassParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseEducationalClassResult>(
    { url: `/m/educational-class/basic-educational-class`, method: 'GET', params, signal },
    options,
  );
};

export const getGetBasicEducationalClassQueryKey = (params?: GetBasicEducationalClassParams) => {
  return [`/m/educational-class/basic-educational-class`, ...(params ? [params] : [])] as const;
};

export const getGetBasicEducationalClassQueryOptions = <
  TData = Awaited<ReturnType<typeof getBasicEducationalClass>>,
  TError = unknown,
>(
  params?: GetBasicEducationalClassParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getBasicEducationalClass>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetBasicEducationalClassQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getBasicEducationalClass>>> = ({ signal }) =>
    getBasicEducationalClass(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getBasicEducationalClass>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetBasicEducationalClassQueryResult = NonNullable<Awaited<ReturnType<typeof getBasicEducationalClass>>>;
export type GetBasicEducationalClassQueryError = unknown;

export function useGetBasicEducationalClass<
  TData = Awaited<ReturnType<typeof getBasicEducationalClass>>,
  TError = unknown,
>(
  params: undefined | GetBasicEducationalClassParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getBasicEducationalClass>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getBasicEducationalClass>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetBasicEducationalClass<
  TData = Awaited<ReturnType<typeof getBasicEducationalClass>>,
  TError = unknown,
>(
  params?: GetBasicEducationalClassParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getBasicEducationalClass>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getBasicEducationalClass>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetBasicEducationalClass<
  TData = Awaited<ReturnType<typeof getBasicEducationalClass>>,
  TError = unknown,
>(
  params?: GetBasicEducationalClassParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getBasicEducationalClass>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary 사용자의 기본반 정보 조회
 */

export function useGetBasicEducationalClass<
  TData = Awaited<ReturnType<typeof getBasicEducationalClass>>,
  TError = unknown,
>(
  params?: GetBasicEducationalClassParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getBasicEducationalClass>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetBasicEducationalClassQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * id로 벡터 정보를 조회합니다.
 * @summary id로 조회
 */
export const getStudentFaceVector = (
  id: number,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseStudentFaceVectorResult>(
    { url: `/api/student-feature-vector/${id}`, method: 'GET', signal },
    options,
  );
};

export const getGetStudentFaceVectorQueryKey = (id: number) => {
  return [`/api/student-feature-vector/${id}`] as const;
};

export const getGetStudentFaceVectorQueryOptions = <
  TData = Awaited<ReturnType<typeof getStudentFaceVector>>,
  TError = unknown,
>(
  id: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentFaceVector>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStudentFaceVectorQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getStudentFaceVector>>> = ({ signal }) =>
    getStudentFaceVector(id, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!id, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getStudentFaceVector>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetStudentFaceVectorQueryResult = NonNullable<Awaited<ReturnType<typeof getStudentFaceVector>>>;
export type GetStudentFaceVectorQueryError = unknown;

export function useGetStudentFaceVector<TData = Awaited<ReturnType<typeof getStudentFaceVector>>, TError = unknown>(
  id: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentFaceVector>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getStudentFaceVector>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetStudentFaceVector<TData = Awaited<ReturnType<typeof getStudentFaceVector>>, TError = unknown>(
  id: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentFaceVector>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getStudentFaceVector>>, TError, TData>, 'initialData'>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetStudentFaceVector<TData = Awaited<ReturnType<typeof getStudentFaceVector>>, TError = unknown>(
  id: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentFaceVector>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary id로 조회
 */

export function useGetStudentFaceVector<TData = Awaited<ReturnType<typeof getStudentFaceVector>>, TError = unknown>(
  id: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentFaceVector>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetStudentFaceVectorQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 전체 정보를 얻거나 아이 분류요청시 전달하는 profileCode로 사용자가 등록한 아이 리스트 조회합니다.
 * @summary 아이 리스트 조회
 */
export const getStudentFaceVectorList = (
  params?: GetStudentFaceVectorListParams,
  options?: SecondParameter<typeof customFetcher>,
  signal?: AbortSignal,
) => {
  return customFetcher<ApiResponseListStudentFaceVectorResult>(
    { url: `/api/student-feature-vector/list`, method: 'GET', params, signal },
    options,
  );
};

export const getGetStudentFaceVectorListQueryKey = (params?: GetStudentFaceVectorListParams) => {
  return [`/api/student-feature-vector/list`, ...(params ? [params] : [])] as const;
};

export const getGetStudentFaceVectorListQueryOptions = <
  TData = Awaited<ReturnType<typeof getStudentFaceVectorList>>,
  TError = unknown,
>(
  params?: GetStudentFaceVectorListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentFaceVectorList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStudentFaceVectorListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getStudentFaceVectorList>>> = ({ signal }) =>
    getStudentFaceVectorList(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 60000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getStudentFaceVectorList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetStudentFaceVectorListQueryResult = NonNullable<Awaited<ReturnType<typeof getStudentFaceVectorList>>>;
export type GetStudentFaceVectorListQueryError = unknown;

export function useGetStudentFaceVectorList<
  TData = Awaited<ReturnType<typeof getStudentFaceVectorList>>,
  TError = unknown,
>(
  params: undefined | GetStudentFaceVectorListParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentFaceVectorList>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getStudentFaceVectorList>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetStudentFaceVectorList<
  TData = Awaited<ReturnType<typeof getStudentFaceVectorList>>,
  TError = unknown,
>(
  params?: GetStudentFaceVectorListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentFaceVectorList>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getStudentFaceVectorList>>, TError, TData>,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetStudentFaceVectorList<
  TData = Awaited<ReturnType<typeof getStudentFaceVectorList>>,
  TError = unknown,
>(
  params?: GetStudentFaceVectorListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentFaceVectorList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary 아이 리스트 조회
 */

export function useGetStudentFaceVectorList<
  TData = Awaited<ReturnType<typeof getStudentFaceVectorList>>,
  TError = unknown,
>(
  params?: GetStudentFaceVectorListParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentFaceVectorList>>, TError, TData>>;
    request?: SecondParameter<typeof customFetcher>;
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetStudentFaceVectorListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}
